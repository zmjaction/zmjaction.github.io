<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>linux vim复制粘贴格式错乱</title>
    <url>/2018/03/20/Linux%20vim%E7%B2%98%E8%B4%B4%E6%A0%BC%E5%BC%8F%E9%94%99%E4%B9%B1/</url>
    <content><![CDATA[<h4 id="linux-vim复制粘贴格式错乱"><a href="#linux-vim复制粘贴格式错乱" class="headerlink" title="linux vim复制粘贴格式错乱"></a>linux vim复制粘贴格式错乱</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先按ESC输入:set paste再复制粘贴</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
        <category>vim</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>解决使用 rz 命令乱码问题</title>
    <url>/2018/05/20/Linux-%E4%BD%BF%E7%94%A8rz%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="解决使用-rz-命令乱码问题"><a href="#解决使用-rz-命令乱码问题" class="headerlink" title="解决使用 rz 命令乱码问题"></a>解决使用 rz 命令乱码问题</h4><h6 id="使用-rz-命令上传一个-tar-包出现一堆乱七八糟的乱码，这个时候使用"><a href="#使用-rz-命令上传一个-tar-包出现一堆乱七八糟的乱码，这个时候使用" class="headerlink" title="使用 rz 命令上传一个 tar 包出现一堆乱七八糟的乱码，这个时候使用"></a><strong>使用 rz 命令上传一个 tar 包出现一堆乱七八糟的乱码，这个时候使用</strong></h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rz -be</span><br><span class="line">或者</span><br><span class="line">rz -e</span><br><span class="line">解析：-e</span><br><span class="line">Force sender to escape all control characters; normally XON, XOFF, DLE, CR-@-CR, and Ctrl-X are escaped.</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
        <category>rz</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>rz</tag>
      </tags>
  </entry>
  <entry>
    <title>liunx中RPM、YUM、Systemd</title>
    <url>/2020/09/06/Linux-%E4%B8%ADRPM%E3%80%81YUM%E3%80%81Systemd/</url>
    <content><![CDATA[<h2 id="RPM软件包"><a href="#RPM软件包" class="headerlink" title="RPM软件包"></a>RPM软件包</h2><p>在RPM（红帽软件包管理器）公布之前，要想在Linux系统中安装软件只能采取源码包的方式安装。早期在Linux系统中安装程序是一件非常困难、耗费耐心的事情，而且大多数的服务程序仅仅提供源代码，需要运维人员自行编译代码并解决许多的软件依赖关系，因此要安装好一个服务程序，运维人员需要具备丰富知识、高超的技能，甚至良好的耐心。而且在安装、升级、卸载服务程序时还要考虑到其他程序、库的依赖关系，所以在进行校验、安装、卸载、查询、升级等管理软件操作时难度都非常大。</p>
<p>RPM机制则为解决这些问题而设计的。RPM有点像Windows系统中的控制面板，会建立统一的数据库文件，详细记录软件信息并能够自动分析依赖关系。目前RPM的优势已经被公众所认可，使用范围也已不局限在红帽系统中了。表1-1是一些常用的RPM软件包命令，当前不需要记住它们，大致混个“脸熟”就足够了。</p>
<a id="more"></a>
<p>表1-1                                                 常用的RPM软件包命令</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>rpm -ivh filename.rpm</td>
<td>安装软件</td>
</tr>
<tr>
<td>rpm -Uvh filename.rpm</td>
<td>升级软件</td>
</tr>
<tr>
<td>rpm -e filename.rpm</td>
<td>卸载软件</td>
</tr>
<tr>
<td>rpm -qpi filename.rpm</td>
<td>查询软件描述信息</td>
</tr>
<tr>
<td>rpm -qpl filename.rpm</td>
<td>列出软件文件信息</td>
</tr>
<tr>
<td>rpm -qf filename</td>
<td>查询文件属于哪个RPM</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Yum软件仓库"><a href="#Yum软件仓库" class="headerlink" title="Yum软件仓库"></a><strong>Yum软件仓库</strong></h2><p>尽管RPM能够帮助用户查询软件相关的依赖关系，但问题还是要运维人员自己来解决，而有些大型软件可能与数十个程序都有依赖关系，在这种情况下安装软件会是非常痛苦的。Yum软件仓库便是为了进一步降低软件安装难度和复杂度而设计的技术。Yum软件仓库可以根据用户的要求分析出所需软件包及其相关的依赖关系，然后自动从服务器下载软件包并安装到系统。Yum软件仓库的技术拓扑如图1-50所示。</p>
<p><img src="https://www.linuxprobe.com/wp-content/uploads/2015/01/yum.png" alt="第1章 部署虚拟环境安装linux系统。第1章 部署虚拟环境安装linux系统。"></p>
<p>图1-50  Yum软件仓库的技术拓扑图</p>
<p>Yum软件仓库中的RPM软件包可以是由红帽官方发布的，也可以是第三方发布的，当然也可以是自己编写的。《Linux就该这么学》随书提供的系统镜像（需在书籍站点中网络下载）内已经包含了大量可用的RPM红帽软件包，后文中详细讲解这些软件包。表1-2所示为一些常见的Yum命令，当前只需对它们有一个简单印象即可。</p>
<p>表1-2                                                      常见的Yum命令</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>yum repolist all</td>
<td>列出所有仓库</td>
</tr>
<tr>
<td>yum list all</td>
<td>列出仓库中所有软件包</td>
</tr>
<tr>
<td>yum info 软件包名称</td>
<td>查看软件包信息</td>
</tr>
<tr>
<td>yum install 软件包名称</td>
<td>安装软件包</td>
</tr>
<tr>
<td>yum reinstall 软件包名称</td>
<td>重新安装软件包</td>
</tr>
<tr>
<td>yum update 软件包名称</td>
<td>升级软件包</td>
</tr>
<tr>
<td>yum remove 软件包名称</td>
<td>移除软件包</td>
</tr>
<tr>
<td>yum clean all</td>
<td>清除所有仓库缓存</td>
</tr>
<tr>
<td>yum check-update</td>
<td>检查可更新的软件包</td>
</tr>
<tr>
<td>yum grouplist</td>
<td>查看系统中已经安装的软件包组</td>
</tr>
<tr>
<td>yum groupinstall 软件包组</td>
<td>安装指定的软件包组</td>
</tr>
<tr>
<td>yum groupremove 软件包组</td>
<td>移除指定的软件包组</td>
</tr>
<tr>
<td>yum groupinfo 软件包组</td>
<td>查询指定的软件包组信息</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Systemd初始化进程"><a href="#Systemd初始化进程" class="headerlink" title="Systemd初始化进程"></a><strong>Systemd初始化进程</strong></h2><p>Linux操作系统的开机过程是这样的，即从BIOS开始，然后进入Boot Loader，再加载系统内核，然后内核进行初始化，最后启动初始化进程。初始化进程作为Linux系统的第一个进程，它需要完成Linux系统中相关的初始化工作，为用户提供合适的工作环境。红帽RHEL 7系统已经替换掉了熟悉的初始化进程服务System V init，正式采用全新的systemd初始化进程服务。如果您之前学习的是RHEL 5或RHEL 6系统，可能会不习惯。systemd初始化进程服务采用了并发启动机制，开机速度得到了不小的提升。虽然systemd初始化进程服务具有很多新特性和优势，但目前还是下面4个槽点。</p>
<blockquote>
<p>槽点1：systemd初始化进程服务的开发人员Lennart Poettering就职于红帽公司，这让其他系统的粉丝很不爽。</p>
<p>槽点2： systemd初始化进程服务仅仅可在Linux系统下运行，“抛弃”了UNIX系统用户。</p>
<p>槽点3：systemd接管了诸如syslogd、udev、cgroup等服务的工作，不再甘心只做初始化进程服务。</p>
<p>槽点4：使用systemd初始化进程服务后，RHEL 7系统变化太大，而相关的参考文档不多，令用户着实为难。</p>
</blockquote>
<p>无论怎样，RHEL 7系统选择systemd初始化进程服务已经是一个既定事实，因此也没有了“运行级别”这个概念，Linux系统在启动时要进行大量的初始化工作，比如挂载文件系统和交换分区、启动各类进程服务等，这些都可以看作是一个一个的单元（Unit），systemd用目标（target）代替了System V init中运行级别的概念，这两者的区别如表1-3所示。</p>
<p>表1-3                                   systemd与System V init的区别以及作用</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>System V init运行级别</th>
<th>systemd目标名称</th>
<th>systemd 目标作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>poweroff.target</td>
<td>关机</td>
</tr>
<tr>
<td>1</td>
<td>rescue.target</td>
<td>单用户模式</td>
</tr>
<tr>
<td>2</td>
<td>multi-user.target</td>
<td>多用户的文本界面</td>
</tr>
<tr>
<td>3</td>
<td>multi-user.target</td>
<td>多用户的文本界面</td>
</tr>
<tr>
<td>4</td>
<td>multi-user.target</td>
<td>多用户的文本界面</td>
</tr>
<tr>
<td>5</td>
<td>graphical.target</td>
<td>多用户的图形界面</td>
</tr>
<tr>
<td>6</td>
<td>reboot.target</td>
<td>重启</td>
</tr>
<tr>
<td>emergency</td>
<td>emergency.target</td>
<td>救援模式</td>
</tr>
</tbody>
</table>
</div>
<p>如果想要将系统默认的运行目标修改为“多用户，无图形”模式，可直接用ln命令把多用户模式目标文件连接到/etc/systemd/system/目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@linuxprobe ~]# ln -sf &#x2F;lib&#x2F;systemd&#x2F;system&#x2F;multi-user.target &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;default.target</span><br></pre></td></tr></table></figure>
<p>如果有读者之前学习过RHEL 6系统，或者已经习惯使用service、chkconfig等命令来管理系统服务，那么现在就比较郁闷了，因为在RHEL 7系统中是使用systemctl命令来管理服务的。表1-4和表1-5所示RHEL 6系统中System V init命令与RHEL 7系统中systemctl命令的对比，您可以先大致了解一下，后续章节中会经常用到它们。</p>
<p>表1-4            systemctl管理服务的启动、重启、停止、重载、查看状态等常用命令</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>老系统命令</th>
<th>新系统命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>service foo start</td>
<td>systemctl start httpd</td>
<td>启动服务</td>
</tr>
<tr>
<td>service foo restart</td>
<td>systemctl restart httpd</td>
<td>重启服务</td>
</tr>
<tr>
<td>service foo stop</td>
<td>systemctl stop httpd</td>
<td>停止服务</td>
</tr>
<tr>
<td>service foo reload</td>
<td>systemctl reload httpd</td>
<td>重新加载配置文件（不终止服务）</td>
</tr>
<tr>
<td>service foo status</td>
<td>systemctl status httpd</td>
<td>查看服务状态</td>
</tr>
</tbody>
</table>
</div>
<p>表1-5    systemctl设置服务开机启动、不启动、查看各级别下服务启动状态等常用命令</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>老系统命令</th>
<th>新系统命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>chkconfig foo on</td>
<td>systemctl enable httpd</td>
<td>开机自动启动</td>
</tr>
<tr>
<td>chkconfig foo off</td>
<td>systemctl disable httpd</td>
<td>开机不自动启动</td>
</tr>
<tr>
<td>chkconfig foo</td>
<td>systemctl is-enabled httpd</td>
<td>查看特定服务是否为开机自启动</td>
</tr>
<tr>
<td>chkconfig —list</td>
<td>systemctl list-unit-files —type=httpd</td>
<td>查看各个级别下服务的启动与禁用情况</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>RPM</tag>
        <tag>YUM</tag>
        <tag>Systemd</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux -- 中man 1 和 man 2 ...</title>
    <url>/2020/03/09/Linux%E4%B8%ADman1-man2-man3%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、Standard commands （标准命令）</span><br><span class="line">2、System calls （系统调用）</span><br><span class="line">3、Library <span class="built_in">functions</span> （库函数）</span><br><span class="line">4、Special devices （设备说明）</span><br><span class="line">5、File formats （文件格式）</span><br><span class="line">6、Games and toys （游戏和娱乐）</span><br><span class="line">7、Miscellaneous （杂项）</span><br><span class="line">8、Administrative Commands （管理员命令）</span><br><span class="line">9 其他（Linux特定的）， 用来存放内核例行程序的文档。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
        <category>man</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>man</tag>
      </tags>
  </entry>
  <entry>
    <title>docker -- Hub -- 镜像加速器</title>
    <url>/2020/05/12/Docker-%20Hub%20%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E5%99%A8/</url>
    <content><![CDATA[<h2 id="Docker-Hub-镜像加速器列表"><a href="#Docker-Hub-镜像加速器列表" class="headerlink" title="Docker Hub 镜像加速器列表"></a>Docker Hub 镜像加速器列表</h2><div class="table-container">
<table>
<thead>
<tr>
<th>镜像加速器</th>
<th>镜像加速器地址</th>
<th>专属加速器<a href="#" title="需登录后获取平台分配的专属加速器">？</a></th>
<th>其它加速<a href="#" title="支持哪些镜像来源的镜像加速">？</a></th>
</tr>
</thead>
<tbody>
<tr>
<td><del><a href="https://docker-cn.com/registry-mirror" target="_blank" rel="noopener">Docker 中国官方镜像</a></del></td>
<td><del><code>https://registry.docker-cn.com</code></del></td>
<td></td>
<td><del>Docker Hub</del>（<a href="https://github.com/docker/docker.github.io/issues/8793" target="_blank" rel="noopener">已关闭</a>）</td>
</tr>
<tr>
<td><a href="https://daocloud.io/mirror" target="_blank" rel="noopener">DaoCloud 镜像站</a></td>
<td><code>http://f1361db2.m.daocloud.io</code></td>
<td>可登录，系统分配</td>
<td>Docker Hub</td>
</tr>
<tr>
<td><a href="https://github.com/Azure/container-service-for-azure-china/blob/master/aks/README.md#22-container-registry-proxy" target="_blank" rel="noopener">Azure 中国镜像</a></td>
<td><code>https://dockerhub.azk8s.cn</code></td>
<td></td>
<td>Docker Hub、GCR、Quay</td>
</tr>
<tr>
<td><a href="https://mirrors.ustc.edu.cn/help/dockerhub.html" target="_blank" rel="noopener">科大镜像站</a></td>
<td><code>https://docker.mirrors.ustc.edu.cn</code></td>
<td></td>
<td>Docker Hub、<a href="https://github.com/ustclug/mirrorrequest/issues/91" target="_blank" rel="noopener">GCR</a>、<a href="https://github.com/ustclug/mirrorrequest/issues/135" target="_blank" rel="noopener">Quay</a></td>
</tr>
<tr>
<td><a href="https://cr.console.aliyun.com" target="_blank" rel="noopener">阿里云</a></td>
<td><code>https://&lt;your_code&gt;.mirror.aliyuncs.com</code></td>
<td>需登录，系统分配</td>
<td>Docker Hub</td>
</tr>
<tr>
<td><a href="https://kirk-enterprise.github.io/hub-docs/#/user-guide/mirror" target="_blank" rel="noopener">七牛云</a></td>
<td><code>https://reg-mirror.qiniu.com</code></td>
<td></td>
<td>Docker Hub、GCR、Quay</td>
</tr>
<tr>
<td><a href="https://c.163yun.com/hub" target="_blank" rel="noopener">网易云</a></td>
<td><code>https://hub-mirror.c.163.com</code></td>
<td></td>
<td>Docker Hub</td>
</tr>
<tr>
<td><a href="https://cloud.tencent.com/document/product/457/9113" target="_blank" rel="noopener">腾讯云</a></td>
<td><code>https://mirror.ccs.tencentyun.com</code></td>
<td></td>
<td>Docker Hub</td>
</tr>
</tbody>
</table>
</div>
<p>由于镜像服务可能出现宕机，建议同时配置多个镜像。各个镜像站测试结果请到 docker-practice/docker-registry-cn-mirror-test 查看。<br><a id="more"></a></p>
<h2 id="配置加速地址"><a href="#配置加速地址" class="headerlink" title="配置加速地址"></a>配置加速地址</h2><blockquote>
<p>Ubuntu 16.04+、Debian 8+、CentOS 7<br>创建或修改 <code>/etc/docker/daemon.json</code>：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"registry-mirrors"</span>: [</span><br><span class="line">        <span class="string">"https://1nj0zren.mirror.aliyuncs.com"</span>,</span><br><span class="line">        <span class="string">"https://docker.mirrors.ustc.edu.cn"</span>,</span><br><span class="line">        <span class="string">"http://f1361db2.m.daocloud.io"</span>,</span><br><span class="line">        <span class="string">"https://dockerhub.azk8s.cn"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<h3 id="Windows-10"><a href="#Windows-10" class="headerlink" title="Windows 10"></a>Windows 10</h3><p>对于使用 Windows 10 的用户，在任务栏托盘 Docker 图标内右键菜单选择 Settings，打开配置窗口后在左侧导航菜单选择 Docker Engine，在右侧像下边一样编辑 json 文件，之后点击 Apply &amp; Restart 保存后 Docker 就会重启并应用配置的镜像地址了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https:&#x2F;&#x2F;hub-mirror.c.163.com&quot;,</span><br><span class="line">    &quot;https:&#x2F;&#x2F;mirror.baidubce.com&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h3><p>对于使用 macOS 的用户，在任务栏点击 Docker Desktop 应用图标 -&gt; Perferences，在左侧导航菜单选择 Docker Engine，在右侧像下边一样编辑 json 文件。修改完成之后，点击 Apply &amp; Restart 按钮，Docker 就会重启并应用配置的镜像地址了。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https:&#x2F;&#x2F;hub-mirror.c.163.com&quot;,</span><br><span class="line">    &quot;https:&#x2F;&#x2F;mirror.baidubce.com&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="检查加速器是否生效"><a href="#检查加速器是否生效" class="headerlink" title="检查加速器是否生效"></a>检查加速器是否生效</h2><p>执行 <code>$ docker info</code>，如果从结果中看到了如下内容，说明配置成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Registry Mirrors:</span><br><span class="line"> https://hub-mirror.c.163.com/</span><br></pre></td></tr></table></figure>
<h2 id="k8s-gcr-io-镜像"><a href="#k8s-gcr-io-镜像" class="headerlink" title="k8s.gcr.io 镜像"></a><code>k8s.gcr.io</code> 镜像</h2><p>可以登录 <a href="https://www.aliyun.com/product/acr?source=5176.11533457&amp;userCode=8lx5zmtu&amp;type=copy" target="_blank" rel="noopener">阿里云 容器镜像服务</a> <strong>镜像中心</strong> -&gt; <strong>镜像搜索</strong> 查找。</p>
<p>例如 <code>k8s.gcr.io/coredns:1.6.7</code> 镜像可以用 <code>registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.6.7</code> 代替。</p>
<p>一般情况下有如下对应关系：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># $ docker pull k8s.gcr.io/xxx</span></span><br><span class="line"></span><br><span class="line">$ docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/xxx</span><br></pre></td></tr></table></figure>
<p>参考：</p>
<blockquote>
<p><a href="https://gist.github.com/y0ngb1n/7e8f16af3242c7815e7ca2f0833d3ea6" target="_blank" rel="noopener">https://gist.github.com/y0ngb1n/7e8f16af3242c7815e7ca2f0833d3ea6</a><br><a href="https://github.com/yeasy/docker_practice/blob/master/install/mirror.md" target="_blank" rel="noopener">https://github.com/yeasy/docker_practice/blob/master/install/mirror.md</a><br><a href="https://www.ilanni.com/?p=14534" target="_blank" rel="noopener">https://www.ilanni.com/?p=14534</a></p>
</blockquote>
]]></content>
      <categories>
        <category>docker</category>
        <category>Hub镜像</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>Hub镜像</tag>
      </tags>
  </entry>
  <entry>
    <title>postgresql -- case-- case when</title>
    <url>/2020/05/01/PostgreSql-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%9ACASE%E3%80%81CASE%20WHEN/</url>
    <content><![CDATA[<h4 id="1-CASE条件判断"><a href="#1-CASE条件判断" class="headerlink" title="1. CASE条件判断"></a>1. <code>CASE</code>条件判断</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CASE input_expression</span><br><span class="line">WHEN when_expression THEN result_expression</span><br><span class="line">    [ ...n ]</span><br><span class="line">[ELSE else_result_expression]</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<p><code>CASE</code>函数会判断表达式<code>input_expression</code>的值，并根据判断结果执行对应的<code>WHEN</code>分支流程</p>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_test (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">serial</span>,</span><br><span class="line">	<span class="keyword">name</span> <span class="built_in">text</span>,</span><br><span class="line">	sex <span class="built_in">int</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_test (<span class="keyword">name</span>,sex) <span class="keyword">values</span> </span><br><span class="line">(<span class="string">'张三'</span>, <span class="string">'1'</span>),</span><br><span class="line">(<span class="string">'李四'</span>, <span class="string">'2'</span>),</span><br><span class="line">(<span class="string">'王五'</span>, <span class="string">'1'</span>),</span><br><span class="line">(<span class="string">'小六'</span>, <span class="string">'2'</span>),</span><br><span class="line">(<span class="string">'小七'</span>, <span class="string">'1'</span>)</span><br><span class="line"><span class="comment">-- 使用case查询</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> sex = <span class="string">'1'</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> 男,<span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> sex=<span class="string">'2'</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)<span class="keyword">as</span> 女 <span class="keyword">from</span> t_test;</span><br><span class="line"> 男 | 女 </span><br><span class="line"><span class="comment">----+----</span></span><br><span class="line">  3 |  2</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<h4 id="2-CASE-THEN条件判断"><a href="#2-CASE-THEN条件判断" class="headerlink" title="2. CASE THEN条件判断"></a>2. <code>CASE THEN</code>条件判断</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CASE    </span><br><span class="line">WHEN Boolean_expression THEN result_expression</span><br><span class="line">    [ ...n ]</span><br><span class="line">[ELSE else_result_expression]</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<p><code>CASE THEN</code>语句与<code>CASE</code>语句类似，其条件判断语句<code>Boolean_expression</code>是一个计算结果是布尔值的表达式。</p>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="number">1</span>&gt;<span class="number">2</span> <span class="keyword">THEN</span> <span class="string">'com.itbilu'</span> <span class="keyword">ELSE</span> <span class="string">'itbilu.com'</span> <span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
        <category>postgresql</category>
        <category>case</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>postgresql</tag>
        <tag>case</tag>
      </tags>
  </entry>
  <entry>
    <title>postgresql -- 窗口函数</title>
    <url>/2020/06/03/PostgreSql-%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h4 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h4><ul>
<li><ol>
<li>与使用聚合函数执行的计算类似</li>
</ol>
</li>
<li><ol>
<li>不会使多行聚合成一行，与聚合的函数的区别</li>
</ol>
</li>
</ul>
<h5 id="窗口函数的语法"><a href="#窗口函数的语法" class="headerlink" title="窗口函数的语法"></a>窗口函数的语法</h5><figure class="highlight"><table><tr><td class="code"><pre><span class="line">function_name ([expression [, expression ... ]]) OVER ( window_definition )</span><br><span class="line">window_definition语法：</span><br><span class="line">	[PARTITION BY expression [,...]]</span><br><span class="line">	[ORDER BY expression [ASC|DESC|USING operator] [NULLS &#123;FIRST|LAST&#125;] [,...] ]</span><br></pre></td></tr></table></figure>
<ul>
<li><ol>
<li>总是包含一个<code>OVER</code>子句，即窗口函数的名称和参数, 决定究竟将 查询的行如何通过窗口函数拆分处理</li>
</ol>
</li>
<li><ol>
<li><code>partition by</code> ：对结果集进行分组</li>
</ol>
</li>
<li><ol>
<li><code>OVER</code>不使用<code>PARTITION BY</code>时即代表整个表</li>
</ol>
</li>
<li><ol>
<li><code>order by</code>：设定结果集的分组数据排序</li>
</ol>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>返回类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>row_number()</code></td>
<td><code>bigint</code></td>
<td>在其分区中的当前行号，从1计</td>
</tr>
<tr>
<td><code>rank()</code></td>
<td><code>bigint</code></td>
<td>有间隔的当前行排名；与它的第一个相同行的<code>row_number</code>相同</td>
</tr>
<tr>
<td><code>dense_rank()</code></td>
<td><code>bigint</code></td>
<td>没有间隔的当前行排名；这个函数计数对等组。</td>
</tr>
<tr>
<td><code>percent_rank()</code></td>
<td><code>double precision</code></td>
<td>当前行的相对排名: (<code>rank</code> - 1) / (总行数 - 1)</td>
</tr>
<tr>
<td><code>cume_dist()</code></td>
<td><code>double precision</code></td>
<td>当前行的相对排名：(前面的行数或与当前行相同的行数)/(总行数)</td>
</tr>
<tr>
<td><code>ntile(*num_buckets* integer)</code></td>
<td><code>integer</code></td>
<td>从1到参数值的整数范围，尽可能相等的划分分区。</td>
</tr>
<tr>
<td><code>lag(*value* any [, *offset* integer [, *default* any ]])</code></td>
<td><code>类型同 value</code></td>
<td>计算分区当前行的前<code>*offset*</code> 行，返回<code>*value*</code> 。如果没有这样的行， 返回<code>*default*</code>替代。 <code>*offset*</code>和<code>*default*</code> 都是当前行计算的结果。如果忽略了，则<code>*offset*</code> 默认是1，<code>*default*</code>默认是 null。</td>
</tr>
<tr>
<td><code>lead(*value* any [, *offset* integer [, *default* any ]])</code></td>
<td><code>类型同value</code></td>
<td>计算分区当前行的后<code>*offset*</code>行， 返回<code>*value*</code>。如果没有这样的行， 返回<code>*default*</code>替代。 <code>*offset*</code>和<code>*default*</code> 都是当前行计算的结果。如果忽略了，则<code>*offset*</code> 默认是1，<code>*default*</code>默认是 null。</td>
</tr>
<tr>
<td><code>first_value(*value* any)</code></td>
<td><code>类型同value</code></td>
<td>返回窗口第一行的计算<code>*value*</code>值。</td>
</tr>
<tr>
<td><code>last_value(*value* any)</code></td>
<td><code>类型同value</code></td>
<td>返回窗口最后一行的计算<code>*value*</code>值。</td>
</tr>
<tr>
<td><code>nth_value(*value* any, *nth* integer)</code></td>
<td><code>类型同value</code></td>
<td>返回窗口第<code>*nth*</code>行的计算 <code>*value*</code>值（行从1计数）；没有这样的行则返回 null。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>最近在看《深入浅出PostgreSql》想总结下窗口函数，书上示例比较少，网上搜索一番，发现了一篇好的文章，借以引用望原作者知晓，<a href="https://www.cnblogs.com/funnyzpc/p/9311281.html" target="_blank" rel="noopener">参考连接</a></p>
</blockquote>
<h5 id="创建表，插入原始测试数据"><a href="#创建表，插入原始测试数据" class="headerlink" title="创建表，插入原始测试数据"></a>创建表，插入原始测试数据</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">"public"</span>.<span class="string">"products"</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">"public"</span>.<span class="string">"products"</span> (</span><br><span class="line">    <span class="string">"id"</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">COLLATE</span> <span class="string">"default"</span>,</span><br><span class="line">    <span class="string">"name"</span> <span class="built_in">text</span> <span class="keyword">COLLATE</span> <span class="string">"default"</span>,</span><br><span class="line">    <span class="string">"price"</span> <span class="built_in">numeric</span>,</span><br><span class="line">    <span class="string">"uid"</span> <span class="built_in">varchar</span>(<span class="number">14</span>) <span class="keyword">COLLATE</span> <span class="string">"default"</span>,</span><br><span class="line">    <span class="string">"type"</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">COLLATE</span> <span class="string">"default"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">WITH</span> (OIDS=<span class="literal">FALSE</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">"public"</span>.<span class="string">"products"</span> <span class="keyword">VALUES</span> (<span class="string">'0006'</span>, <span class="string">'iPhone X'</span>, <span class="string">'9600'</span>, <span class="literal">null</span>, <span class="string">'电器'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">"public"</span>.<span class="string">"products"</span> <span class="keyword">VALUES</span> (<span class="string">'0012'</span>, <span class="string">'电视'</span>, <span class="string">'3299'</span>, <span class="string">'4'</span>, <span class="string">'电器'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">"public"</span>.<span class="string">"products"</span> <span class="keyword">VALUES</span> (<span class="string">'0004'</span>, <span class="string">'辣条'</span>, <span class="string">'5.6'</span>, <span class="string">'4'</span>, <span class="string">'零食'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">"public"</span>.<span class="string">"products"</span> <span class="keyword">VALUES</span> (<span class="string">'0007'</span>, <span class="string">'薯条'</span>, <span class="string">'7.5'</span>, <span class="string">'1'</span>, <span class="string">'零食'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">"public"</span>.<span class="string">"products"</span> <span class="keyword">VALUES</span> (<span class="string">'0009'</span>, <span class="string">'方便面'</span>, <span class="string">'3.5'</span>, <span class="string">'1'</span>, <span class="string">'零食'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">"public"</span>.<span class="string">"products"</span> <span class="keyword">VALUES</span> (<span class="string">'0005'</span>, <span class="string">'铅笔'</span>, <span class="string">'7'</span>, <span class="string">'4'</span>, <span class="string">'文具'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">"public"</span>.<span class="string">"products"</span> <span class="keyword">VALUES</span> (<span class="string">'0014'</span>, <span class="string">'作业本'</span>, <span class="string">'1'</span>, <span class="literal">null</span>, <span class="string">'文具'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">"public"</span>.<span class="string">"products"</span> <span class="keyword">VALUES</span> (<span class="string">'0001'</span>, <span class="string">'鞋子'</span>, <span class="string">'27'</span>, <span class="string">'2'</span>, <span class="string">'衣物'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">"public"</span>.<span class="string">"products"</span> <span class="keyword">VALUES</span> (<span class="string">'0002'</span>, <span class="string">'外套'</span>, <span class="string">'110.9'</span>, <span class="string">'3'</span>, <span class="string">'衣物'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">"public"</span>.<span class="string">"products"</span> <span class="keyword">VALUES</span> (<span class="string">'0013'</span>, <span class="string">'围巾'</span>, <span class="string">'93'</span>, <span class="string">'5'</span>, <span class="string">'衣物'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">"public"</span>.<span class="string">"products"</span> <span class="keyword">VALUES</span> (<span class="string">'0008'</span>, <span class="string">'香皂'</span>, <span class="string">'17.5'</span>, <span class="string">'2'</span>, <span class="string">'日用品'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">"public"</span>.<span class="string">"products"</span> <span class="keyword">VALUES</span> (<span class="string">'0010'</span>, <span class="string">'水杯'</span>, <span class="string">'27'</span>, <span class="string">'3'</span>, <span class="string">'日用品'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">"public"</span>.<span class="string">"products"</span> <span class="keyword">VALUES</span> (<span class="string">'0015'</span>, <span class="string">'洗发露'</span>, <span class="string">'36'</span>, <span class="string">'1'</span>, <span class="string">'日用品'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">"public"</span>.<span class="string">"products"</span> <span class="keyword">VALUES</span> (<span class="string">'0011'</span>, <span class="string">'毛巾'</span>, <span class="string">'15'</span>, <span class="string">'1'</span>, <span class="string">'日用品'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">"public"</span>.<span class="string">"products"</span> <span class="keyword">VALUES</span> (<span class="string">'0003'</span>, <span class="string">'手表'</span>, <span class="string">'1237.55'</span>, <span class="string">'5'</span>, <span class="string">'电器'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">"public"</span>.<span class="string">"products"</span> <span class="keyword">VALUES</span> (<span class="string">'0016'</span>, <span class="string">'绘图笔'</span>, <span class="string">'15'</span>, <span class="literal">null</span>, <span class="string">'文具'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">"public"</span>.<span class="string">"products"</span> <span class="keyword">VALUES</span> (<span class="string">'0017'</span>, <span class="string">'汽水'</span>, <span class="string">'3.5'</span>, <span class="literal">null</span>, <span class="string">'零食'</span>);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>
<h5 id="row-number-使用"><a href="#row-number-使用" class="headerlink" title="row_number()使用"></a><strong>row_number()</strong>使用</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">type</span>,<span class="keyword">name</span>,price,row_number() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> price <span class="keyword">asc</span>) <span class="keyword">as</span> idx <span class="keyword">from</span> products</span><br></pre></td></tr></table></figure>
<p><img src="//tvax1.sinaimg.cn/large/d479ba17gy1gfmef0ig19j208a0cwglx.jpg" alt=""></p>
<h5 id="Partition-by"><a href="#Partition-by" class="headerlink" title="Partition by"></a>Partition by</h5><blockquote>
<p>以上输出想要在type 类别，按照价格price 升序排序</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">type</span>,<span class="keyword">name</span>,price,row_number() <span class="keyword">over</span>(<span class="keyword">PARTITION</span> <span class="keyword">by</span> <span class="keyword">type</span> <span class="keyword">order</span> <span class="keyword">by</span> price <span class="keyword">asc</span>) <span class="keyword">as</span> idx <span class="keyword">from</span> products ;</span><br></pre></td></tr></table></figure>
<p><img src="//tva4.sinaimg.cn/large/d479ba17gy1gfmei9kezrj208j0cpmxg.jpg" alt=""></p>
<h5 id="rank"><a href="#rank" class="headerlink" title="rank()"></a>rank()</h5><blockquote>
<p>以上输出，方便面和汽水价格是一样，如何将零食和汽水并列第一呢？</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">type</span>,<span class="keyword">name</span>,price,<span class="keyword">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">type</span> <span class="keyword">order</span> <span class="keyword">by</span> price <span class="keyword">asc</span>) <span class="keyword">from</span> products</span><br></pre></td></tr></table></figure>
<p><img src="//tva4.sinaimg.cn/large/d479ba17gy1gfmel68ud8j209b0cudg2.jpg" alt=""></p>
<h5 id="dense-rank"><a href="#dense-rank" class="headerlink" title="dense_rank()"></a><strong>dense_rank</strong>()</h5><blockquote>
<p>以上输出中，辣条排在了第三位，想要排在第二位怎么处理呢？</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">type</span>,<span class="keyword">name</span>,price,<span class="keyword">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">type</span> <span class="keyword">order</span> <span class="keyword">by</span> price <span class="keyword">asc</span>) <span class="keyword">from</span> products;</span><br></pre></td></tr></table></figure>
<p><img src="//tva1.sinaimg.cn/large/d479ba17gy1gfmenzzfekj20a00cq74m.jpg" alt=""></p>
<h5 id="percernt-rank"><a href="#percernt-rank" class="headerlink" title="percernt_rank()"></a><strong>percernt_rank</strong>()</h5><blockquote>
<p>限制序号在0~1之间,(0作为第一个序)</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">type</span>,<span class="keyword">name</span>,price,<span class="keyword">percent_rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">type</span> <span class="keyword">order</span> <span class="keyword">by</span> price <span class="keyword">asc</span>) <span class="keyword">from</span> products</span><br></pre></td></tr></table></figure>
<p><img src="//tva1.sinaimg.cn/large/d479ba17gy1gfmeqwjuxlj20be0d30t4.jpg" alt=""></p>
<h5 id="cume-dist"><a href="#cume-dist" class="headerlink" title="cume_dist()"></a><strong>cume_dist</strong>()</h5><blockquote>
<p>限制序号在0~1之间相对排名</p>
</blockquote>
<p><img src="//tvax4.sinaimg.cn/large/d479ba17gy1gfmes99eh7j20bb0d374p.jpg" alt=""></p>
<h5 id="ntile-val1"><a href="#ntile-val1" class="headerlink" title="ntile(val1)"></a><strong>ntile(val1)</strong></h5><blockquote>
<p>限制最大序列号</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">type</span>,<span class="keyword">name</span>,price,ntile(<span class="number">10</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">type</span> <span class="keyword">order</span> <span class="keyword">by</span> price <span class="keyword">asc</span>) <span class="keyword">from</span> products;</span><br></pre></td></tr></table></figure>
<p><img src="//tva1.sinaimg.cn/large/d479ba17gy1gfmeud4oj3j208w0ciaae.jpg" alt=""></p>
<h5 id="lag-val1-val2-val3"><a href="#lag-val1-val2-val3" class="headerlink" title="lag(val1,val2,val3)"></a>l<strong>ag(val1,val2,val3)</strong></h5><blockquote>
<p>获取偏移值(向下偏移)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT id,type,name,price,lag(id,1,&#39;&#39;) over(partition by type order by price asc) as topid from products;</span><br></pre></td></tr></table></figure>
<p><img src="//tva4.sinaimg.cn/large/d479ba17gy1gfmewwinw8j20ak0cr74p.jpg" alt=""></p>
<h5 id="lead-val1-val2-val3"><a href="#lead-val1-val2-val3" class="headerlink" title="lead(val1,val2,val3)"></a><strong>lead(val1,val2,val3)</strong></h5><blockquote>
<p>偏移值(向上偏移) </p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>,<span class="keyword">type</span>,<span class="keyword">name</span>,price,<span class="keyword">lead</span>(<span class="keyword">id</span>,<span class="number">1</span>,<span class="string">''</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">type</span> <span class="keyword">order</span> <span class="keyword">by</span> price <span class="keyword">asc</span>) <span class="keyword">as</span> downid <span class="keyword">from</span> products;</span><br></pre></td></tr></table></figure>
<h5 id="first-value-val1"><a href="#first-value-val1" class="headerlink" title="first_value(val1)"></a><strong>first_value(val1)</strong></h5><blockquote>
<p>第一条记录的某个字段的值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT id,type,name,price,first_value(name) over(partition by type order by price asc) from products;</span><br></pre></td></tr></table></figure>
<p><img src="//tva3.sinaimg.cn/large/d479ba17gy1gfmf0vqrooj20ar0cv0t7.jpg" alt=""></p>
<h5 id="last-value-val1"><a href="#last-value-val1" class="headerlink" title="last_value(val1)"></a><strong>last_value(val1)</strong></h5><blockquote>
<p>最后一条记录的某个字段</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT id,type,name,price,last_value(name) over(partition by type order by price range between unbounded preceding and unbounded following) from products;</span><br></pre></td></tr></table></figure>
<h5 id="nth-value-val1-val2"><a href="#nth-value-val1-val2" class="headerlink" title="nth_value(val1,val2)"></a><strong>nth_value(val1,val2)</strong></h5><blockquote>
<p>指定序号记录的某个字段值</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>,<span class="keyword">type</span>,<span class="keyword">name</span>,price,<span class="keyword">nth_value</span>(<span class="keyword">name</span>,<span class="number">2</span>) <span class="keyword">OVER</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">type</span> <span class="keyword">order</span> <span class="keyword">by</span> price <span class="keyword">range</span> <span class="keyword">between</span> <span class="keyword">unbounded</span> <span class="keyword">preceding</span> <span class="keyword">and</span> <span class="keyword">unbounded</span> <span class="keyword">following</span> ) <span class="keyword">from</span> products;</span><br></pre></td></tr></table></figure>
<h5 id="窗口函数-聚合函数"><a href="#窗口函数-聚合函数" class="headerlink" title="窗口函数+聚合函数"></a>窗口函数+聚合函数</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sum(price) over (partition by type) 类别金额合计,</span><br><span class="line">(sum(price) over (order by type))/sum(price) over() 类别总额占所有品类商品百分比,</span><br><span class="line">round(price/(sum(price) over (partition by type rows between unbounded preceding and unbounded following)),3) 子除类别百分比,</span><br><span class="line">rank() over (partition by type order by price desc) 排名,</span><br><span class="line">sum(price) over() 金额总计</span><br><span class="line">from products ORDER BY type,price asc;</span><br><span class="line"><span class="comment">-- 放在from后使用</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">    <span class="keyword">id</span>,<span class="keyword">type</span>,<span class="keyword">name</span>,price,</span><br><span class="line">    <span class="keyword">sum</span>(price) <span class="keyword">over</span> w1 类别金额合计,</span><br><span class="line">    (<span class="keyword">sum</span>(price) <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">type</span>))/<span class="keyword">sum</span>(price) <span class="keyword">over</span>() 类别总额占所有品类商品百分比,</span><br><span class="line">    <span class="keyword">round</span>(price/(<span class="keyword">sum</span>(price) <span class="keyword">over</span> w2),<span class="number">3</span>) 子除类别百分比,</span><br><span class="line">    <span class="keyword">rank</span>() <span class="keyword">over</span> w3 排名,</span><br><span class="line">    <span class="keyword">sum</span>(price) <span class="keyword">over</span>() 金额总计</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    products</span><br><span class="line"><span class="keyword">WINDOW</span></span><br><span class="line">    w1 <span class="keyword">as</span> (<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">type</span>),</span><br><span class="line">    w2 <span class="keyword">as</span> (<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">type</span> <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">unbounded</span> <span class="keyword">preceding</span> <span class="keyword">and</span> <span class="keyword">unbounded</span> <span class="keyword">following</span>),</span><br><span class="line">    w3 <span class="keyword">as</span> (<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">type</span> <span class="keyword">order</span> <span class="keyword">by</span> price <span class="keyword">desc</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    <span class="keyword">type</span>,price <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
        <category>postgresql</category>
        <category>窗口函数</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>postgresql</tag>
        <tag>窗口函数</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7 安装 supervisor</title>
    <url>/2017/06/01/centos7%20%E5%AE%89%E8%A3%85supervisor/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -qa|grep epel-release &gt;&amp;/dev/null ||yum install -y epel-release</span><br><span class="line">rpm -qa|grep supervisor &gt;&amp;/dev/null ||yum install -y supervisor</span><br><span class="line">supervisord -c /etc/supervisord.conf</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>supervisor</tag>
      </tags>
  </entry>
  <entry>
    <title>postman -- 上传文件</title>
    <url>/2020/05/11/Postman-upload_file/</url>
    <content><![CDATA[<h4 id="1-选择post请求"><a href="#1-选择post请求" class="headerlink" title="1.选择post请求"></a>1.选择post请求</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1:9810&#x2F;data&#x2F;site_upload_file</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="2-填写Headers"><a href="#2-填写Headers" class="headerlink" title="2.填写Headers"></a>2.填写Headers</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Type : multipart&#x2F;form-data</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdn.net/20180601143717485?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hb3dlbmRp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<h4 id="3-选择form-data，上传文件"><a href="#3-选择form-data，上传文件" class="headerlink" title="3.选择form-data，上传文件"></a>3.选择form-data，上传文件</h4><p><img src="https://img-blog.csdn.net/20180601143141175?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hb3dlbmRp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
]]></content>
      <categories>
        <category>postman</category>
      </categories>
      <tags>
        <tag>postman</tag>
        <tag>上传文件</tag>
      </tags>
  </entry>
  <entry>
    <title>postgresql -- 模糊查询</title>
    <url>/2020/06/03/PostgreSql-%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2-%E4%B8%8D%E5%8C%B9%E9%85%8D%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h3 id="like-和-not-like"><a href="#like-和-not-like" class="headerlink" title="like  和 not like"></a><code>like</code>  和 <code>not like</code></h3><ul>
<li><code>like、not like</code>在SQL中用于模糊查询，<code>%</code>表示任意个字符，<code>_</code>表示单个任意字符</li>
<li><code>ESCAPE</code>转义使用</li>
</ul>
<h3 id="ilike-和-not-ilike"><a href="#ilike-和-not-ilike" class="headerlink" title="ilike 和 not ilike"></a><code>ilike</code> 和 <code>not ilike</code></h3><ul>
<li><code>ilike</code>表示在模糊匹配字符串时不区分大小写，<code>i</code>即是ignore的意思。</li>
<li><code>not ilike</code>表示不模糊匹配字符串且不区分大小写。</li>
</ul>
<h3 id="和-，-和"><a href="#和-，-和" class="headerlink" title="~和~*，!~和!~*"></a><code>~</code>和<code>~*</code>，<code>!~</code>和<code>!~*</code></h3><ul>
<li><code>~</code>表示匹配正则表达式，且区分大小写。</li>
<li><code>~*</code>表示匹配正则表达式，且不区分大小写。</li>
<li><code>!~</code>是<code>~</code>的否定用法，表示不匹配正则表达式，且区分大小写。</li>
<li><code>!~*</code>是<code>~*</code>的否定用法，表示不匹配正则表达式，且不区分大小写。</li>
</ul>
<h3 id="和-，-和-1"><a href="#和-，-和-1" class="headerlink" title="~~和~~*，!~~和!~~*"></a><code>~~</code>和<code>~~*</code>，<code>!~~</code>和<code>!~~*</code></h3><ul>
<li><code>~~</code>等效于like，<code>~~*</code>等效于ilike。</li>
<li><code>!~~</code>等效于not like，<code>!~~*</code>等效于not ilike。</li>
</ul>
<p>实例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 模糊查询，不匹配的数据</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">		c.id,</span><br><span class="line">		c.licenseKey,</span><br><span class="line">		c.siteName,</span><br><span class="line">		c.topDomain,</span><br><span class="line">		c.website_type,</span><br><span class="line">		c.system_decide,</span><br><span class="line">		c.handle_result,</span><br><span class="line">		c.webmaster,</span><br><span class="line">		c.webmaster_phone,</span><br><span class="line">		c.webmaster_fixed_phone,</span><br><span class="line">		c.organizer_unit_name,</span><br><span class="line">		c.unitType,</span><br><span class="line">		c.principal_person,</span><br><span class="line">		c.principal_phone,</span><br><span class="line">		c.principal_fixed_phone,</span><br><span class="line">		c.belongingCity,</span><br><span class="line">		c.organizer_unit_addr,</span><br><span class="line">		to_char(c.r_time,<span class="string">'YYYY-MM-DD hh24:mi:ss'</span>)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">		 (<span class="keyword">select</span> * <span class="keyword">from</span> public.t_record_detail_info <span class="keyword">where</span> belongingcity ~ <span class="string">'杭州市'</span>) <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">where</span> <span class="number">1</span>=<span class="number">1</span>  <span class="keyword">and</span> organizer_unit_addr <span class="keyword">not</span> <span class="keyword">like</span>  <span class="keyword">all</span>(<span class="built_in">array</span>[<span class="string">'%上城区%'</span>,<span class="string">'%下城区%'</span>,<span class="string">'%江干区%'</span>,<span class="string">'%拱墅区%'</span>,<span class="string">'%滨江区%'</span>,<span class="string">'%西湖区%'</span>,<span class="string">'%萧山区%'</span>,<span class="string">'%余杭区%'</span>,<span class="string">'%富阳区%'</span>,<span class="string">'%临安区%'</span>,<span class="string">'%桐庐县%'</span>,<span class="string">'%淳安县%'</span>,<span class="string">'%建德市%'</span>])</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> c.r_time <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
        <category>postgresql</category>
        <category>模糊查询</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>postgresql</tag>
        <tag>like</tag>
        <tag>not like</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建 Docker私有仓库</title>
    <url>/2018/03/12/docker-%E6%90%AD%E5%BB%BA%20Docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<h4 id="Registry部署"><a href="#Registry部署" class="headerlink" title="Registry部署"></a>Registry部署</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">docker search registry</span><br><span class="line">docker pull registry</span><br></pre></td></tr></table></figure>
<p>然后启动一个容器，这里的 /opt/registry 是我们本地的目录，用于存储上传的镜象，/var/lib/registry是Registry服务默认的保存镜象目录<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">docker run -d -v /opt/registry:/<span class="keyword">var</span>/lib/registry -p <span class="number">5000</span>:<span class="number">5000</span> --restart=always --name registry registry</span><br></pre></td></tr></table></figure><br>运行 docker ps 看一下容器情况，</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line">9ea93421fc13        registry            &quot;&#x2F;entrypoint.sh &#x2F;etc…&quot;   27 minutes ago      Up 11 minutes                 0.0.0.0:5000-&gt;5000&#x2F;tcp   registry</span><br></pre></td></tr></table></figure>
<p>说明我们已经启动了registry服务，打开浏览器输入<a href="http://主机ip:5000/v2，正常返回如下数据" target="_blank" rel="noopener">http://主机ip:5000/v2，正常返回如下数据</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><br>注意：在/etc/docker/daemon.json中需要添加,不然推送不成功<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; &quot;insecure-registries&quot;:[&quot;192.168.1.71:5000&quot;] &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>现在我们通过将镜像push到registry来验证一下。</p>
<p>我的机器上有个hello-world的镜像，我们要通过docker tag将该镜像标志为要推送到私有仓库，<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker tag hello-world 127.0.0.1:5000&#x2F;hello-world</span><br></pre></td></tr></table></figure><br>然后查看以下本地的镜像<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REPOSITORY                      TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">192.168.1.71:5000&#x2F;hello-world   v1.1                bf756fb1ae65        7 months ago        13.3kB</span><br><span class="line">hello-world                     latest              bf756fb1ae65        7 months ago        13.3kB</span><br></pre></td></tr></table></figure><br>接下来，我们运行docker push将hello-world镜像push到我们的私有仓库中，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> docker push <span class="number">192.168</span><span class="number">.1</span><span class="number">.71</span>:<span class="number">5000</span>/hello-world:v1<span class="number">.1</span> </span><br><span class="line"></span><br><span class="line">The push refers to repository [<span class="number">192.168</span><span class="number">.1</span><span class="number">.71</span>:<span class="number">5000</span>/hello-world]</span><br><span class="line"><span class="number">9</span>c27e219663c: Pushed </span><br><span class="line">v1<span class="number">.1</span>: digest: sha256:<span class="number">90659</span>bf80b44ce6be8234e6ff90a1ac34acbeb826903b02cfa0da11c82cbc042 size: <span class="number">525</span></span><br></pre></td></tr></table></figure>
<p>现在我们可以查看我们本地/opt/registry目录下已经有了刚推送上来的hello-world。我们也在浏览器中输入<a href="http://192.168.1.71:5000/v2/_catalog，正常返回如下数据" target="_blank" rel="noopener">http://192.168.1.71:5000/v2/_catalog，正常返回如下数据</a><br>现在我们可以先将我们本地的127.0.0.1:5000/hello-world和hello-world先删除掉，<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rmi hello-world</span><br><span class="line">docker rmi 127.0.0.1:5000&#x2F;hello-world</span><br></pre></td></tr></table></figure><br>然后使用docker pull从我们的私有仓库中获取hello-world镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull 127.0.0.1:5000&#x2F;hello-world</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>docker</category>
        <category>repositories</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>repositories</tag>
      </tags>
  </entry>
  <entry>
    <title>go -- [译]配置 sql.DB  --  获得更好的性能</title>
    <url>/2020/01/21/go-%5B%E8%AF%91%5D%E9%85%8D%E7%BD%AE%20sql.DB%20%E8%8E%B7%E5%BE%97%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<p>网上有很多教程介绍<code>sql.DB</code>, 以及如何使用它来执行SQL数据库查询和语句, 但是大部分都没有介绍<code>SetMaxOpenConns（）</code>、<code>SetMaxIdleConns（）</code>和<code>SetConnmaxLifetime（）</code>方法。事实上你可以使用这些方法来配置<code>sql.DB</code>的行为并改善其性能。</p>
<p>在这篇文章中，我想准确地解释这些设置的作用，并演示它们可能产生的（正面和负面）影响。</p>
<h4 id="打开和空闲连接"><a href="#打开和空闲连接" class="headerlink" title="打开和空闲连接"></a>打开和空闲连接</h4><p>我将从一些背景开始。</p>
<p>sql.db对象是包含多个<strong>open</strong>和<strong>idle</strong>数据库连接的连接池。当使用连接执行数据库任务（如执行SQL语句或查询数据）时，该连接被标记为<strong>open</strong>(打开)。任务完成后，连接将变为<strong>idle</strong>(空闲)。</p>
<p>当您指示<code>sql.db</code>执行数据库任务时，它将首先检查池中是否有空闲连接可用。如果有可用的连接，Go将重用现有连接，并在任务期间将其标记为打开。如果在需要连接时池中没有空闲连接的话，go将创建一个新的附加连接并<strong>打开</strong>它。</p>
<h4 id="SetMaxOpenConns-方法"><a href="#SetMaxOpenConns-方法" class="headerlink" title="SetMaxOpenConns 方法"></a>SetMaxOpenConns 方法</h4><p>默认情况下，可以同时打开的连接数没有限制。但您可以通过<code>setMaxOpenConns()</code>方法实现自己的限制，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化一个新的连接池</span></span><br><span class="line">db, err := sql.Open(<span class="string">"postgres"</span>, <span class="string">"postgres://user:pass@localhost/db"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置最大的并发打开连接数为5。</span></span><br><span class="line"><span class="comment">// 设置这个数小于等于0则表示没有显示，也就是默认设置。</span></span><br><span class="line">db.SetMaxOpenConns(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>在此示例代码中，池中最多有5个并发打开的连接。如果5个连接都已经打开被使用，并且应用程序需要另一个连接的话，那么应用程序将被迫等待，直到5个打开的连接其中的一个被释放并变为空闲。</p>
<p>为了说明更改<strong>MaxOpenConns</strong>的影响，我运行了一个基准测试，将最大开放连接设置为1、2、5、10和无限制。基准测试在PostgreSQL数据库上执行并行的insert语句，您可以在这个<a href="https://gist.github.com/alexedwards/5d1db82e6358b5b6efcb038ca888ab07" target="_blank" rel="noopener">gist</a>中找到代码。结果如下：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"database/sql"</span></span><br><span class="line">	<span class="string">"testing"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">	_ <span class="string">"github.com/lib/pq"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertRecord</span><span class="params">(b *testing.B, db *sql.DB)</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), <span class="number">3</span>*time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	</span><br><span class="line">	_, err := db.ExecContext(ctx, <span class="string">"INSERT INTO isbns VALUES ('978-3-598-21500-1')"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		b.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMaxOpenConns1</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	db, err := sql.Open(<span class="string">"postgres"</span>, <span class="string">"postgres://user:pass@localhost/bookstore"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		b.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	db.SetMaxOpenConns(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line">	b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">			insertRecord(b, db)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMaxOpenConns2</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	db, err := sql.Open(<span class="string">"postgres"</span>, <span class="string">"postgres://user:pass@localhost/bookstore"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		b.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	db.SetMaxOpenConns(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line">	b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">			insertRecord(b, db)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMaxOpenConns5</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	db, err := sql.Open(<span class="string">"postgres"</span>, <span class="string">"postgres://user:pass@localhost/bookstore"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		b.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	db.SetMaxOpenConns(<span class="number">5</span>)</span><br><span class="line">	<span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line">	b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">			insertRecord(b, db)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMaxOpenConns10</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	db, err := sql.Open(<span class="string">"postgres"</span>, <span class="string">"postgres://user:pass@localhost/bookstore"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		b.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	db.SetMaxOpenConns(<span class="number">10</span>)</span><br><span class="line">	<span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line">	b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">			insertRecord(b, db)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMaxOpenConnsUnlimited</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	db, err := sql.Open(<span class="string">"postgres"</span>, <span class="string">"postgres://user:pass@localhost/bookstore"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		b.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line">	b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">			insertRecord(b, db)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMaxIdleConnsNone</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	db, err := sql.Open(<span class="string">"postgres"</span>, <span class="string">"postgres://user:pass@localhost/bookstore"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		b.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	db.SetMaxIdleConns(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line">	b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">			insertRecord(b, db)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMaxIdleConns1</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	db, err := sql.Open(<span class="string">"postgres"</span>, <span class="string">"postgres://user:pass@localhost/bookstore"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		b.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	db.SetMaxIdleConns(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line">	b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">			insertRecord(b, db)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMaxIdleConns2</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	db, err := sql.Open(<span class="string">"postgres"</span>, <span class="string">"postgres://user:pass@localhost/bookstore"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		b.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	db.SetMaxIdleConns(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line">	b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">			insertRecord(b, db)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMaxIdleConns5</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	db, err := sql.Open(<span class="string">"postgres"</span>, <span class="string">"postgres://user:pass@localhost/bookstore"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		b.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	db.SetMaxIdleConns(<span class="number">5</span>)</span><br><span class="line">	<span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line">	b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">			insertRecord(b, db)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMaxIdleConns10</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	db, err := sql.Open(<span class="string">"postgres"</span>, <span class="string">"postgres://user:pass@localhost/bookstore"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		b.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	db.SetMaxIdleConns(<span class="number">10</span>)</span><br><span class="line">	<span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line">	b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">			insertRecord(b, db)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkConnMaxLifetimeUnlimited</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	db, err := sql.Open(<span class="string">"postgres"</span>, <span class="string">"postgres://user:pass@localhost/bookstore"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		b.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	db.SetConnMaxLifetime(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line">	b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">			insertRecord(b, db)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkConnMaxLifetime1000</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	db, err := sql.Open(<span class="string">"postgres"</span>, <span class="string">"postgres://user:pass@localhost/bookstore"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		b.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	db.SetConnMaxLifetime(<span class="number">1000</span> * time.Millisecond)</span><br><span class="line">	<span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line">	b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">			insertRecord(b, db)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkConnMaxLifetime500</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	db, err := sql.Open(<span class="string">"postgres"</span>, <span class="string">"postgres://user:pass@localhost/bookstore"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		b.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	db.SetConnMaxLifetime(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">	<span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line">	b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">			insertRecord(b, db)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkConnMaxLifetime200</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	db, err := sql.Open(<span class="string">"postgres"</span>, <span class="string">"postgres://user:pass@localhost/bookstore"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		b.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	db.SetConnMaxLifetime(<span class="number">200</span> * time.Millisecond)</span><br><span class="line">	<span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line">	b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">			insertRecord(b, db)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkConnMaxLifetime100</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	db, err := sql.Open(<span class="string">"postgres"</span>, <span class="string">"postgres://user:pass@localhost/bookstore"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		b.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	db.SetConnMaxLifetime(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">	<span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line">	b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">			insertRecord(b, db)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BenchmarkMaxOpenConns1-8                 500       3129633 ns&#x2F;op         478 B&#x2F;op         10 allocs&#x2F;op</span><br><span class="line">BenchmarkMaxOpenConns2-8                1000       2181641 ns&#x2F;op         470 B&#x2F;op         10 allocs&#x2F;op</span><br><span class="line">BenchmarkMaxOpenConns5-8                2000        859654 ns&#x2F;op         493 B&#x2F;op         10 allocs&#x2F;op</span><br><span class="line">BenchmarkMaxOpenConns10-8               2000        545394 ns&#x2F;op         510 B&#x2F;op         10 allocs&#x2F;op</span><br><span class="line">BenchmarkMaxOpenConnsUnlimited-8        2000        531030 ns&#x2F;op         479 B&#x2F;op          9 allocs&#x2F;op</span><br><span class="line">PASS</span><br><span class="line">-- 3129633 ns&#x2F;op 表示每次执行耗时3129633纳秒，</span><br><span class="line">-- 470 B&#x2F;op  表示每次执行分配了 470字节的内存</span><br><span class="line">-- 10 allocs&#x2F;op 表示每次执行分配了10个对象</span><br></pre></td></tr></table></figure>
<blockquote>
<p>准确地说，此基准的目的不是模拟应用程序的“真实”行为。它只是帮助说明<code>SQL.DB</code>在幕后的行为，以及更改<strong>MaxOpenConns</strong>对该行为的影响。</p>
</blockquote>
<p>对于这个基准，我们可以看到允许的开放连接越多，在数据库上执行<strong>插入</strong>操作所花费的时间就越少（3129633 ns/op，其中1个开放连接，而无限连接为531030 ns/op，大约快6倍）。这是因为存在的开放连接越多，基准代码等待开放连接释放并再次空闲（准备使用）所需的时间（平均值）就越少。</p>
<h4 id="SetMaxIdleConns"><a href="#SetMaxIdleConns" class="headerlink" title="SetMaxIdleConns"></a>SetMaxIdleConns</h4><p>默认情况下，<code>sql.DB</code>允许在连接池中最多保留<strong>2</strong>个空闲连接。您可以通过<code>SetMaxIdleConns（）</code>方法进行更改，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化连接池</span></span><br><span class="line">db, err := sql.Open(<span class="string">"postgres"</span>, <span class="string">"postgres://user:pass@localhost/db"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置最大的空闲连接数为5。</span></span><br><span class="line"><span class="comment">// 设置小于等于0的数意味着不保留空闲连接。</span></span><br><span class="line">db.SetMaxIdleConns(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>理论上，在池中允许更多的空闲连接将提高性能，因为这样可以减少从头开始建立新连接的可能性，从而有助于节省资源。</p>
<p>让我们来看看相同的基准，最大空闲连接设置为无、1、2、5和10（并且开放连接的数量是无限的）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">BenchmarkMaxIdleConnsNone<span class="number">-8</span>          <span class="number">300</span>       <span class="number">4567245</span> ns/op       <span class="number">58174</span> B/op        <span class="number">625</span> allocs/op</span><br><span class="line">BenchmarkMaxIdleConns1<span class="number">-8</span>            <span class="number">2000</span>        <span class="number">568765</span> ns/op        <span class="number">2596</span> B/op         <span class="number">32</span> allocs/op</span><br><span class="line">BenchmarkMaxIdleConns2<span class="number">-8</span>            <span class="number">2000</span>        <span class="number">529359</span> ns/op         <span class="number">596</span> B/op         <span class="number">11</span> allocs/op</span><br><span class="line">BenchmarkMaxIdleConns5<span class="number">-8</span>            <span class="number">2000</span>        <span class="number">506207</span> ns/op         <span class="number">451</span> B/op          <span class="number">9</span> allocs/op</span><br><span class="line">BenchmarkMaxIdleConns10<span class="number">-8</span>           <span class="number">2000</span>        <span class="number">501639</span> ns/op         <span class="number">450</span> B/op          <span class="number">9</span> allocs/op</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure>
<p>当<code>MaxIdleConns</code>设置为none时，必须为每个插入操作创建新的连接，从基准中我们可以看到平均运行时间和内存分配相对较高。</p>
<p>只允许保留和重用一个空闲连接，在我们这个特定的基准测试中有很大的不同——它将平均运行时间减少了8倍左右，并将内存分配减少了20倍左右。继续增加空闲连接池的大小会使性能更好，尽管这些改进不那么明显。</p>
<p>那么我们应该维护一个大的空闲连接池吗？答案是它取决于应用程序。</p>
<p>重要的是要认识到保持空闲连接的存活是要付出代价的——它会占用内存，否则这些内存可以同时用于应用程序和数据库。</p>
<p>也有一种可能，如果一个连接空闲太久，那么它也可能会变得不可用。例如，MySQL的<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_wait_timeout" target="_blank" rel="noopener">wait_timeout</a>设置将自动关闭8小时内未使用的任何连接（默认情况下）。</p>
<p>当发生这种情况时，<code>sql.DB</code>会优雅地处理它。在放弃之前，将自动重试两次坏连接，之后Go将从池中删除坏连接并创建新连接。因此，将<code>MaxIdleConns</code>设置得太高实际上可能会导致连接变得不可用，并且使用的资源比使用较小的空闲连接池（使用的连接更少，使用频率更高）的情况下要多。所以只有你很可能马上再次使用浙西连接，你才会保持这些连接空闲。</p>
<p>最后要指出的一点是，<code>MaxIdleConns</code>应该始终小于或等于<code>MaxOpenConns</code>。Go会检查并在必要时自动减少<code>MaxIdleConns</code> StackOverflow上的一个解释很好地描述了原因：</p>
<blockquote>
<p>设置比<code>MaxOpenConns</code>更多的空闲连接数是没有意义的，因为你最多也就能拿到所有打开的连接，剩余的空闲连接依然保持的空闲。这就像一座四车道的桥，但是只允许三辆车同时通过。</p>
</blockquote>
<h4 id="SetConnMaxLifetime-方法"><a href="#SetConnMaxLifetime-方法" class="headerlink" title="SetConnMaxLifetime 方法"></a>SetConnMaxLifetime 方法</h4><p>现在让我们来看一下<code>SetConnMaxLifetime（）</code>方法，它设置了连接可重用的最大时间长度。如果您的SQL数据库也实现了最大的连接生存期，或者（例如）您希望在负载均衡器后面方便地切换数据库，那么这将非常有用。</p>
<p>您可以这样使用它：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化连接池</span></span><br><span class="line">db, err := sql.Open(<span class="string">"postgres"</span>, <span class="string">"postgres://user:pass@localhost/db"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置连接的最大生命周期为一小时。</span></span><br><span class="line"><span class="comment">// 设置为0的话意味着没有最大生命周期，连接总是可重用(默认行为)。</span></span><br><span class="line">db.SetConnMaxLifetime(time.Hour)</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们的所有连接将在第一次创建后1小时“过期”，并且在它们过期后无法重用。但是注意：</p>
<ul>
<li>这并不能保证连接将在池中存在完整的一小时；很可能由于某种原因连接将变得不可用，并且在此之前自动关闭。</li>
<li>一个连接在创建后仍可以使用一个多小时，只是说一个小时后不能再被重用了。</li>
<li>这不是空闲超时。连接将在第一次创建后1小时后过期，而不是1小时后变成空闲。</li>
<li>每秒自动运行一次清理操作以便从池中删除“过期”连接。</li>
</ul>
<p>理论上，<strong>ConnMaxLifetime</strong>越短，从零开始创建连接的频率就越高。</p>
<p>为了说明这一点，我运行了基准测试，将<strong>ConnMaxLifetime</strong>设置为100ms、200ms、500ms、1000ms和unlimited（永远重复使用），默认设置为unlimited open connections和2个idle connections。这些时间段显然比您在大多数应用程序中使用的要短得多，但它们有助于很好地说明连接库的行为。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BenchmarkConnMaxLifetime100-8               2000        637902 ns&#x2F;op        2770 B&#x2F;op         34 allocs&#x2F;op</span><br><span class="line">BenchmarkConnMaxLifetime200-8               2000        576053 ns&#x2F;op        1612 B&#x2F;op         21 allocs&#x2F;op</span><br><span class="line">BenchmarkConnMaxLifetime500-8               2000        558297 ns&#x2F;op         913 B&#x2F;op         14 allocs&#x2F;op</span><br><span class="line">BenchmarkConnMaxLifetime1000-8              2000        543601 ns&#x2F;op         740 B&#x2F;op         12 allocs&#x2F;op</span><br><span class="line">BenchmarkConnMaxLifetimeUnlimited-8         3000        532789 ns&#x2F;op         412 B&#x2F;op          9 allocs&#x2F;op</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure>
<p>在这些特定的基准测试中，我们可以看到100毫秒的内存分配要比unlimited的内存分配多三倍，而且每个插入的操作的平均运行时间也稍长一些</p>
<h4 id="超出连接限制"><a href="#超出连接限制" class="headerlink" title="超出连接限制"></a>超出连接限制</h4><p>最后，如果不提及超过了数据库连接数的硬限制的话，那么本文就不算一个完整的教程了。</p>
<p>如图所示，我将更改<strong>postgresql.conf</strong>文件，因此只允许总共5个连接（默认值为100）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">max_connections &#x3D; 5</span><br></pre></td></tr></table></figure>
<p>使用 unlimited open connections 的配置进行基准测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BenchmarkMaxOpenConnsUnlimited-8    --- FAIL: BenchmarkMaxOpenConnsUnlimited-8</span><br><span class="line">    main_test.go:14: pq: sorry, too many clients already</span><br><span class="line">    main_test.go:14: pq: sorry, too many clients already</span><br><span class="line">    main_test.go:14: pq: sorry, too many clients already</span><br><span class="line">FAIL</span><br></pre></td></tr></table></figure>
<p>一旦达到5个连接的硬限制，我的数据库驱动程序（PQ）立即返回一条<code>sorry, too many clients already</code>错误信息，而不是完成插入操作。</p>
<p>为了避免这个错误，我们需要将<code>sql.DB</code>中打开和空闲连接的最大总数设置为5以下。像这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化连接池</span></span><br><span class="line">db, err := sql.Open(<span class="string">"postgres"</span>, <span class="string">"postgres://user:pass@localhost/db"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置open和idle的总连接数为3</span></span><br><span class="line">db.SetMaxOpenConns(<span class="number">2</span>)</span><br><span class="line">db.SetMaxIdleConns(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>现在，由<code>sql.DB</code>创建的连接数最多只能有3个，基准测试运行时应该没有错误。</p>
<p>但是这样也会给我们带来一个很大的警示：当达到开放连接限制时，应用程序需要执行的任何新数据库任务都将被强制等待，直到连接变为空闲。</p>
<p>对于某些应用程序，该行为可能很好，但对于其他应用程序，则可能不好。例如，在Web应用程序中，最好立即记录错误消息并向用户发送<code>500 Internal Server Error</code>，而不是让他们的HTTP请求挂起，并可能在等待空闲连接时超时。</p>
<h2 id="综上所述"><a href="#综上所述" class="headerlink" title="综上所述"></a>综上所述</h2><ol>
<li>根据经验，应该显式设置一个<code>MaxOpenConns</code>值。这应该舒适地低于数据库和基础结构所施加的对连接数的任何硬性限制。</li>
<li>通常，更高的<code>MaxOpenConns</code>和<code>MaxIdleConns</code>值将导致更好的性能。但是收益却在下降，您应该意识到，空闲连接池过大（连接没有被重用并最终变为坏连接）实际上会导致性能下降。</li>
<li>为了减轻上述第2点的风险，您可能需要设置相对较短的<code>ConnMaxLifetime</code>。但是，您不希望如此短，以免导致连接被不必要地终止和重新创建。</li>
<li><code>MaxIdleConns</code>应始终小于或等于<code>MaxOpenConns</code>。</li>
</ol>
<p>对于中小型Web应用程序，我通常使用以下设置作为起点，然后根据负载测试的结果（具有真实的吞吐量水平）从那里进行优化。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.SetMaxOpenConns(<span class="number">25</span>)</span><br><span class="line">db.SetMaxIdleConns(<span class="number">25</span>)</span><br><span class="line">db.SetConnMaxLifetime(<span class="number">5</span>*time.Minute)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
        <category>sql.DB</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>sql.DB</tag>
      </tags>
  </entry>
  <entry>
    <title>go -- goroutine -- 示例解析</title>
    <url>/2018/07/01/Go%E8%AF%AD%E8%A8%80goroutine/</url>
    <content><![CDATA[<p>简单的goroutine示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span>  &#123;</span><br><span class="line">				fmt.Printf(<span class="string">"Hello goroutine %d\n"</span>, i) <span class="comment">// i/O操作</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Microsecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上边的代码如果不加go执行的话，只会在第一次i=0的时候无限循环执行<code>fmt.Printf(&quot;Hello goroutine %d\n&quot;, i)</code></li>
<li>main()也是一个goroutine，主goroutine已经结束， 子goroutine还没有执行，所以需要加上<code>time.Sleep(time.Microsecond)</code></li>
</ul>
<h4 id="go开启的其实不是线程，而是协程"><a href="#go开启的其实不是线程，而是协程" class="headerlink" title="go开启的其实不是线程，而是协程"></a>go开启的其实不是线程，而是协程</h4><ul>
<li>轻量级的协程</li>
<li><strong>非抢占式</strong> 多任务处理，由协程主动交出控制权</li>
<li>而线程再任何时候都可以被系统切换，所有线程又称之为抢占式多任务处理，哪怕程序执行到一半，都可以被系统切换</li>
<li>编译器，解析器或者虚拟机层面的多任务</li>
<li>协程可以看作是编译器层面的多任务而不是操作系统的多任务 操作系统只有线程没有协程</li>
<li>go语言在执行goroutine时 编译器会有一个调度器为他调度协程 操作系统有调度器 go语言有自己的调度器</li>
<li>多个协程可能再一个或多个线程上运行</li>
</ul>
<h4 id="非抢占式"><a href="#非抢占式" class="headerlink" title="非抢占式"></a>非抢占式</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span>  &#123;</span><br><span class="line">				a[i]++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Microsecond)</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行发现程序 夯住了，查看cpu占用，发现已经快达到100%了<br>产生的原因：</p>
<pre><code>* a[i]++ 无法主动交出控制权
* main函数事主goroutine，由于 go func 没有交出控制权，导致main一直等待
</code></pre><p>从之前的代码可以看到，io操作时可以自动交出控制权的，如何手动交出控制权？可以使用<code>runtime.Gosched()</code>。一般情况下不会用到<code>runtime.Gosched()</code><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span>  &#123;</span><br><span class="line">				a[i]++</span><br><span class="line">				runtime.Gosched()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Microsecond)</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="go-func-中不传入变量可不可以？"><a href="#go-func-中不传入变量可不可以？" class="headerlink" title="go func(){}() 中不传入变量可不可以？"></a>go func(){}() 中不传入变量可不可以？</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过执行发现 报错了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span>  &#123;</span><br><span class="line">				a[i]++</span><br><span class="line">				runtime.Gosched()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Microsecond)</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过执行发现报错了，但是为什么报错呢？</p>
<ul>
<li>go run -race goroutine.go 看下究竟发生了什么</li>
<li>从上边的执行命令,可以看出，出错的原因是因为如果不把i作为参数传给func，就不会形成闭包，在最后一次执行for的时候i会是10，导致a[10]超出范围</li>
</ul>
<h4 id="go语言调度器"><a href="#go语言调度器" class="headerlink" title="go语言调度器"></a>go语言调度器</h4><p>在go语言里，具体每个协程如何分配到线程里，都是交给调度器来分配，我们不用操心。</p>
<h4 id="goroutine的定义"><a href="#goroutine的定义" class="headerlink" title="goroutine的定义"></a>goroutine的定义</h4><ul>
<li>直接在函数前加入go</li>
<li>不需要再定义时区分是否是异步函数</li>
<li>调度器在合适的点进行切换</li>
<li>使用-race检测数据访问冲突<h4 id="goroutine的切换点"><a href="#goroutine的切换点" class="headerlink" title="goroutine的切换点"></a>goroutine的切换点</h4>下面这些点可以参考，但是由于我们无法100%控制，所以只能是参考。</li>
<li>I/O select</li>
<li>channel</li>
<li>等待锁</li>
<li>函数调用（有时）</li>
<li>runtime.Gosched()</li>
</ul>
]]></content>
      <categories>
        <category>go</category>
        <category>goroutine</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>goroutine</tag>
      </tags>
  </entry>
  <entry>
    <title>postgresql -- 高级操作</title>
    <url>/2020/06/04/PostgreSql-%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h4 id="归并数据"><a href="#归并数据" class="headerlink" title="归并数据"></a>归并数据</h4><p>归并数据又称为<code>UPSERT</code>语法，指的是<code>INSERT .. ON CONFLICT UPDATE</code></p>
<blockquote>
<p>当发生冲突的时候，可以忽略改插入操作，也可以执行指定的更新<code>UPDATE</code>操作</p>
</blockquote>
<p>语法格式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[ <span class="keyword">WITH</span> [ <span class="keyword">RECURSIVE</span> ] with_query [, ...] ]  </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name [ <span class="keyword">AS</span> <span class="keyword">alias</span> ] [ ( column_name [, ...] ) ]  </span><br><span class="line">    &#123; <span class="keyword">DEFAULT</span> <span class="keyword">VALUES</span> | <span class="keyword">VALUES</span> ( &#123; expression | <span class="keyword">DEFAULT</span> &#125; [, ...] ) [, ...] | <span class="keyword">query</span> &#125;  </span><br><span class="line">    [ <span class="keyword">ON</span> CONFLICT [ conflict_target ] conflict_action ]  </span><br><span class="line">    [ <span class="keyword">RETURNING</span> * | output_expression [ [ <span class="keyword">AS</span> ] output_name ] [, ...] ]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ON CONFLICT DO NOTHING</code>:不采取任何动作</li>
<li><code>ON CONFLICT DO UPDATE</code>: 更新与要插入的行冲突的已有行<ul>
<li><code>conflict_target:指定冲突的目标，哪些可用约束或唯一索引产生的冲突</code></li>
<li><code>conflict_action:</code>指定一个冲突发生时的可选的动作</li>
</ul>
</li>
</ul>
<p>1.创建一张测试表:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span>(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>, <span class="keyword">name</span> <span class="built_in">text</span>, r_time <span class="built_in">timestamp</span>);  </span><br><span class="line"><span class="comment">-- 注意：on conflict (必须是主键，或者唯一索引)，如果指定name 需要创建唯一索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> name_idx <span class="keyword">ON</span> <span class="keyword">test</span> (<span class="keyword">name</span>)</span><br></pre></td></tr></table></figure>
<p>2.不存在则插入，存在则更新</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">'xiaoming'</span>,<span class="keyword">now</span>()) <span class="keyword">on</span> conflict (<span class="keyword">id</span>) <span class="keyword">do</span> <span class="keyword">update</span> <span class="keyword">set</span> <span class="keyword">name</span>=excluded.name,r_time=excluded.r_time; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看数据</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 通过指定id，再插入一条，发现已经被更新</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">'lilei'</span>,<span class="keyword">now</span>()) <span class="keyword">on</span> conflict (<span class="keyword">id</span>) <span class="keyword">do</span> <span class="keyword">update</span> <span class="keyword">set</span> <span class="keyword">name</span>=excluded.name,r_time=excluded.r_time;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看数据，发现已经被更新</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure>
<p>3.不存在则插入，存在则直接返回(不做任何处理)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">'tom'</span>,<span class="keyword">now</span>()) <span class="keyword">on</span> conflict (<span class="keyword">id</span>) <span class="keyword">do</span> <span class="keyword">nothing</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">'marry'</span>,<span class="keyword">now</span>()) <span class="keyword">on</span> conflict (<span class="keyword">id</span>) <span class="keyword">do</span> <span class="keyword">nothing</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span> (<span class="number">2</span>,<span class="string">'tony'</span>,<span class="keyword">now</span>()) <span class="keyword">on</span> conflict (<span class="keyword">id</span>) <span class="keyword">do</span> <span class="keyword">nothing</span>;</span><br><span class="line"><span class="comment">-- 查看数据，发现只有tom,tony这两条数据</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure>
<h4 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h4><h5 id="1-INSERT-INTO-SELECT"><a href="#1-INSERT-INTO-SELECT" class="headerlink" title="1. INSERT INTO ... SELECT ..."></a>1. <code>INSERT INTO ... SELECT ...</code></h5><blockquote>
<p>注意必须是表结构相同的两个表</p>
</blockquote>
<p>语法格式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test1 <span class="keyword">SELECT</span> * <span class="keyword">from</span> test2</span><br></pre></td></tr></table></figure>
<h5 id="2-INSERT-INTO-…-VALUES"><a href="#2-INSERT-INTO-…-VALUES" class="headerlink" title="2. INSERT INTO … VALUES(),(),()"></a>2. INSERT INTO … VALUES(),(),()</h5><p>语法格式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span>  </span><br><span class="line">	test1 (<span class="keyword">name</span>,r_time)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">	(<span class="string">"tom"</span>, <span class="keyword">now</span>()),</span><br><span class="line">	(<span class="string">"tony"</span>, <span class="keyword">now</span>()),</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<h5 id="3-BEGIN-…-多条insert-…-END"><a href="#3-BEGIN-…-多条insert-…-END" class="headerlink" title="3. BEGIN … 多条insert …; END"></a>3. BEGIN … 多条insert …; END</h5><blockquote>
<p>通过一个事务，插入多条sql，减少commit次数</p>
</blockquote>
<p>语法格式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">"public"</span>.<span class="string">"products"</span> <span class="keyword">VALUES</span> (<span class="string">'0006'</span>, <span class="string">'iPhone X'</span>, <span class="string">'9600'</span>, <span class="literal">null</span>, <span class="string">'电器'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">"public"</span>.<span class="string">"products"</span> <span class="keyword">VALUES</span> (<span class="string">'0012'</span>, <span class="string">'电视'</span>, <span class="string">'3299'</span>, <span class="string">'4'</span>, <span class="string">'电器'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">"public"</span>.<span class="string">"products"</span> <span class="keyword">VALUES</span> (<span class="string">'0004'</span>, <span class="string">'辣条'</span>, <span class="string">'5.6'</span>, <span class="string">'4'</span>, <span class="string">'零食'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">"public"</span>.<span class="string">"products"</span> <span class="keyword">VALUES</span> (<span class="string">'0007'</span>, <span class="string">'薯条'</span>, <span class="string">'7.5'</span>, <span class="string">'1'</span>, <span class="string">'零食'</span>);</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>
<h5 id="4-COPY"><a href="#4-COPY" class="headerlink" title="4. COPY"></a>4. COPY</h5><p>语法格式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">COPY table_name [ ( column_name [, ...] ) ]</span><br><span class="line">    FROM &#123; 'filename' | PROGRAM 'command' | STDIN &#125;</span><br><span class="line">    [ [ <span class="keyword">WITH</span> ] ( <span class="keyword">option</span> [, ...] ) ]</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">COPY test1 from '/home/action/batch.txt'</span><br><span class="line">copy tbl_test1(a,b,c) from stdin delimiter ',' csv header;</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- copy 标准输出，字段间用','分隔</span></span><br><span class="line">copy tbl_test1(a,b) to stdout delimiter ',' csv header;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>copy 文件—&gt; 表</p>
<p>copy to 表—&gt; 文件</p>
</blockquote>
<h4 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h4><p>语法格式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">FROM</span> ... <span class="keyword">VALUES</span>(),()...</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">test</span> <span class="keyword">set</span> info=tmp.info <span class="keyword">from</span> (<span class="keyword">values</span> (<span class="number">1</span>,<span class="string">'new1'</span>),(<span class="number">2</span>,<span class="string">'new2'</span>),(<span class="number">6</span>,<span class="string">'new6'</span>)) <span class="keyword">as</span> tmp (<span class="keyword">id</span>,info) <span class="keyword">where</span> test.id=tmp.id;</span><br></pre></td></tr></table></figure>
<h4 id="关联更新"><a href="#关联更新" class="headerlink" title="关联更新"></a>关联更新</h4><h4 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h4><p>语法格式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">using</span> (<span class="keyword">values</span> (<span class="number">3</span>),(<span class="number">4</span>),(<span class="number">5</span>)) <span class="keyword">as</span> tmp(<span class="keyword">id</span>) <span class="keyword">where</span> test.id=tmp.id;</span><br></pre></td></tr></table></figure>
<h4 id="关联删除"><a href="#关联删除" class="headerlink" title="关联删除"></a>关联删除</h4><h4 id="移动数据到历史表"><a href="#移动数据到历史表" class="headerlink" title="移动数据到历史表"></a>移动数据到历史表</h4><h4 id="清空表"><a href="#清空表" class="headerlink" title="清空表"></a>清空表</h4><p>语法格式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
        <category>postgresql</category>
        <category>高级操作</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>postgresql</tag>
        <tag>UPSERT</tag>
      </tags>
  </entry>
  <entry>
    <title>git cherry-pick 教程</title>
    <url>/2019/07/08/git-cherry-pick%20%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="git-cherry-pick-教程"><a href="#git-cherry-pick-教程" class="headerlink" title="git cherry-pick 教程"></a>git cherry-pick 教程</h1><p>对于多分支的代码库，将代码从一个分支转移到另一个分支是常见需求。</p>
<p>这时分两种情况。一种情况是，你需要另一个分支的所有代码变动，那么就采用合并（<code>git merge</code>）。另一种情况是，你只需要部分代码变动（某几个提交），这时可以采用 Cherry pick。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/202004/bg2020042723.jpg" alt=""><br><a id="more"></a></p>
<h2 id="一、基本用法"><a href="#一、基本用法" class="headerlink" title="一、基本用法"></a>一、基本用法</h2><p><code>git cherry-pick</code>命令的作用，就是将指定的提交（commit）应用于其他分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick &lt;commitHash&gt;</span><br></pre></td></tr></table></figure>
<p>上面命令就会将指定的提交<code>commitHash</code>，应用于当前分支。这会在当前分支产生一个新的提交，当然它们的哈希值会不一样。</p>
<p>举例来说，代码仓库有<code>master</code>和<code>feature</code>两个分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a - b - c - d   Master</span><br><span class="line">     \</span><br><span class="line">       e - f - g Feature</span><br></pre></td></tr></table></figure>
<p>现在将提交<code>f</code>应用到<code>master</code>分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到 master 分支</span></span><br><span class="line">$ git checkout master</span><br><span class="line"></span><br><span class="line"><span class="comment"># Cherry pick 操作</span></span><br><span class="line">$ git cherry-pick f</span><br></pre></td></tr></table></figure>
<p>上面的操作完成以后，代码库就变成了下面的样子。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a - b - c - d - f   Master</span><br><span class="line">     \</span><br><span class="line">       e - f - g Feature</span><br></pre></td></tr></table></figure>
<p>从上面可以看到，<code>master</code>分支的末尾增加了一个提交<code>f</code>。</p>
<p><code>git cherry-pick</code>命令的参数，不一定是提交的哈希值，分支名也是可以的，表示转移该分支的最新提交。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick feature</span><br></pre></td></tr></table></figure>
<p>上面代码表示将<code>feature</code>分支的最近一次提交，转移到当前分支。</p>
<h2 id="二、转移多个提交"><a href="#二、转移多个提交" class="headerlink" title="二、转移多个提交"></a>二、转移多个提交</h2><p>Cherry pick 支持一次转移多个提交。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick &lt;HashA&gt; &lt;HashB&gt;</span><br></pre></td></tr></table></figure>
<p>上面的命令将 A 和 B 两个提交应用到当前分支。这会在当前分支生成两个对应的新提交。</p>
<p>如果想要转移一系列的连续提交，可以使用下面的简便语法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick A..B</span><br></pre></td></tr></table></figure>
<p>上面的命令可以转移从 A 到 B 的所有提交。它们必须按照正确的顺序放置：提交 A 必须早于提交 B，否则命令将失败，但不会报错。</p>
<p>注意，使用上面的命令，提交 A 将不会包含在 Cherry pick 中。如果要包含提交 A，可以使用下面的语法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick A^..B</span><br></pre></td></tr></table></figure>
<h2 id="三、配置项"><a href="#三、配置项" class="headerlink" title="三、配置项"></a>三、配置项</h2><p><code>git cherry-pick</code>命令的常用配置项如下。</p>
<p><strong>（1）<code>-e</code>，<code>--edit</code></strong></p>
<p>打开外部编辑器，编辑提交信息。</p>
<p><strong>（2）<code>-n</code>，<code>--no-commit</code></strong></p>
<p>只更新工作区和暂存区，不产生新的提交。</p>
<p><strong>（3）<code>-x</code></strong></p>
<p>在提交信息的末尾追加一行<code>(cherry picked from commit ...)</code>，方便以后查到这个提交是如何产生的。</p>
<p><strong>（4）<code>-s</code>，<code>--signoff</code></strong></p>
<p>在提交信息的末尾追加一行操作者的签名，表示是谁进行了这个操作。</p>
<p><strong>（5）<code>-m parent-number</code>，<code>--mainline parent-number</code></strong></p>
<p>如果原始提交是一个合并节点，来自于两个分支的合并，那么 Cherry pick 默认将失败，因为它不知道应该采用哪个分支的代码变动。</p>
<p><code>-m</code>配置项告诉 Git，应该采用哪个分支的变动。它的参数<code>parent-number</code>是一个从<code>1</code>开始的整数，代表原始提交的父分支编号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick -m 1 &lt;commitHash&gt;</span><br></pre></td></tr></table></figure>
<p>上面命令表示，Cherry pick 采用提交<code>commitHash</code>来自编号1的父分支的变动。</p>
<p>一般来说，1号父分支是接受变动的分支（the branch being merged into），2号父分支是作为变动来源的分支（the branch being merged from）。 </p>
<h2 id="四、代码冲突"><a href="#四、代码冲突" class="headerlink" title="四、代码冲突"></a>四、代码冲突</h2><p>如果操作过程中发生代码冲突，Cherry pick 会停下来，让用户决定如何继续操作。</p>
<p><strong>（1）<code>--continue</code></strong></p>
<p>用户解决代码冲突后，第一步将修改的文件重新加入暂存区（<code>git add .</code>），第二步使用下面的命令，让 Cherry pick 过程继续执行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure>
<p><strong>（2）<code>--abort</code></strong></p>
<p>发生代码冲突后，放弃合并，回到操作前的样子。</p>
<p><strong>（3）<code>--quit</code></strong></p>
<p>发生代码冲突后，退出 Cherry pick，但是不回到操作前的样子。</p>
<h2 id="五、转移到另一个代码库"><a href="#五、转移到另一个代码库" class="headerlink" title="五、转移到另一个代码库"></a>五、转移到另一个代码库</h2><p>Cherry pick 也支持转移另一个代码库的提交，方法是先将该库加为远程仓库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote add target git://gitUrl</span><br></pre></td></tr></table></figure>
<p>上面命令添加了一个远程仓库<code>target</code>。</p>
<p>然后，将远程代码抓取到本地。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git fetch target</span><br></pre></td></tr></table></figure>
<p>上面命令将远程代码仓库抓取到本地。</p>
<p>接着，检查一下要从远程仓库转移的提交，获取它的哈希值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> target/master</span><br></pre></td></tr></table></figure>
<p>最后，使用<code>git cherry-pick</code>命令转移提交。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick &lt;commitHash&gt;</span><br></pre></td></tr></table></figure>
<p>（完）<br>来源：<a href="http://www.ruanyifeng.com/blog/2020/04/git-cherry-pick.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2020/04/git-cherry-pick.html</a></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>cherry-pick</tag>
      </tags>
  </entry>
  <entry>
    <title>go -- os.File -- bufio -- ioutil -- 操作文件</title>
    <url>/2020/08/21/go-os.File%E3%80%81bufio%E3%80%81ioutil%20%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<h2 id="os-File、bufio、ioutil-比较"><a href="#os-File、bufio、ioutil-比较" class="headerlink" title="os.File、bufio、ioutil 比较"></a>os.File、bufio、ioutil 比较</h2><h3 id="效率测试"><a href="#效率测试" class="headerlink" title="效率测试"></a>效率测试</h3><p>文件的读取效率是所有开发者都会关心的话题，尤其是当文件特别大的时候。为了尽可能的展示这三者对文件读取的性能，我准备了三个文件，分别为<code>small.txt</code>，<code>midium.txt</code>、<code>large.txt</code>，分别对应 KB 级别、MB 级别和 GB 级别。</p>
<h4 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"math"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">		<span class="string">"name"</span>: <span class="string">"harry"</span>,</span><br><span class="line">		<span class="string">"age"</span>: <span class="number">20</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	sStr, err := json.Marshal(s)</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(sStr))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">	CreateFixedFile(<span class="number">4</span>*<span class="number">1024</span>, <span class="keyword">string</span>(sStr), <span class="string">"./small.txt"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建指定大小文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateFixedFile</span><span class="params">(size <span class="keyword">float64</span>, source <span class="keyword">string</span>, fileName <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	file, err := os.OpenFile(fileName, os.O_CREATE|os.O_WRONLY|os.O_APPEND, os.ModePerm)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	count := math.Ceil(<span class="keyword">float64</span>(size) / <span class="keyword">float64</span>(<span class="built_in">len</span>(source)))</span><br><span class="line"></span><br><span class="line">	fmt.Println(count)</span><br><span class="line">	n, err := file.WriteString(strings.Repeat(source+<span class="string">","</span> + <span class="string">"\r\n"</span>, <span class="keyword">int</span>(count)) )</span><br><span class="line">	HandleErr(err)</span><br><span class="line">	fmt.Println(n)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleErr</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="开始测试"><a href="#开始测试" class="headerlink" title="开始测试"></a>开始测试</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bufio"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用File自带的Read</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read1</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	file, err := os.Open(filename)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4096</span>)</span><br><span class="line">	<span class="keyword">var</span> countBytes <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span>  &#123;</span><br><span class="line">		n, err := file.Read(buf)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">0</span> || err ==io.EOF&#123;</span><br><span class="line">			fmt.Println(<span class="string">"读取文件的末尾了。。。"</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		countBytes += n</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> countBytes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用bufio</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read2</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	file, err := os.Open(filename)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4096</span>)</span><br><span class="line">	<span class="keyword">var</span> countBytes <span class="keyword">int</span></span><br><span class="line">	rd := bufio.NewReader(file)</span><br><span class="line">	<span class="keyword">for</span>  &#123;</span><br><span class="line">		n, err := rd.Read(buf)</span><br><span class="line">		<span class="keyword">if</span> n== <span class="number">0</span> || err == io.EOF&#123;</span><br><span class="line">			fmt.Println(<span class="string">"读取文件的末尾了。。。"</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		countBytes += n</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> countBytes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用ioutil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read3</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	file, err := os.Open(filename)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	all, err := ioutil.ReadAll(file)</span><br><span class="line">	countBytes := <span class="built_in">len</span>(all)</span><br><span class="line">	<span class="keyword">return</span> countBytes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testfile</span><span class="params">(filename <span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"============test1 %s ===========\n"</span>, filename)</span><br><span class="line">	start := time.Now()</span><br><span class="line">	size1 := read1(filename)</span><br><span class="line">	t1 := time.Now()</span><br><span class="line">	fmt.Printf(<span class="string">"Read 1 cost: %v, size: %d\n"</span>, t1.Sub(start), size1)</span><br><span class="line">	size2 := read2(filename)</span><br><span class="line">	t2 := time.Now()</span><br><span class="line">	fmt.Printf(<span class="string">"Read 2 cost: %v, size: %d\n"</span>, t2.Sub(t1), size2)</span><br><span class="line">	size3 := read3(filename)</span><br><span class="line">	t3 := time.Now()</span><br><span class="line">	fmt.Printf(<span class="string">"Read 3 cost: %v, size: %d\n"</span>, t3.Sub(t2), size3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	testfile(<span class="string">"small.txt"</span>)</span><br><span class="line">	testfile(<span class="string">"midium.txt"</span>)</span><br><span class="line">	testfile(<span class="string">"large.txt"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://imghosting-1257040086.cos.ap-nanjing.myqcloud.com/img/read_file_all.jpg" alt=""></p>
<ul>
<li>当文件较小（KB 级别）时，ioutil &gt; bufio &gt; os。</li>
<li>当文件大小比较常规（MB 级别）时，三者差别不大，但 bufio 又是已经显现出来。</li>
<li>当文件较大（GB 级别）时，bufio &gt; os &gt; ioutil。</li>
</ul>
<h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>为什么会出现上面的不同结果？其实<code>ioutil</code>最好理解，当文件较小时，<code>ioutil</code>使用<code>ReadAll</code>函数将文件中所有内容直接读入内存，只进行了一次 io 操作，但是<code>os</code>和<code>bufio</code>都是进行了多次读取，才将文件处理完，所以<code>ioutil</code>肯定要快于<code>os</code>和<code>bufio</code>的。但是随着文件的增大，达到接近 GB 级别时，<code>ioutil</code>直接读入内存的弊端就显现出来，要将 GB 级别的文件内容全部读入内存，也就意味着要开辟一块 GB 大小的内存用来存放文件数据，这对内存的消耗是非常大的，因此效率就慢了下来。如果文件继续增大，达到 3GB 甚至以上，<code>ioutil</code>这种读取方式就完全无能为力了。（一个单独的进程空间为 4GB，真正存放数据的堆区和栈区更是远远小于 4GB）。而<code>os</code>为什么在面对大文件时，效率会低于<code>bufio</code>？通过查看<code>bufio</code>的<code>NewReader</code>源码不难发现，在<code>NewReader</code>里，默认为我们提供了一个大小为 4096 的缓冲区，所以系统调用会每次先读取 4096 字节到缓冲区，然后<code>rd.Read</code>会从缓冲区去读取。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    defaultBufSize = <span class="number">4096</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(rd io.Reader)</span> *<span class="title">Reader</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> NewReaderSize(rd, defaultBufSize)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReaderSize</span><span class="params">(rd io.Reader, size <span class="keyword">int</span>)</span> *<span class="title">Reader</span></span> &#123;</span><br><span class="line">    <span class="comment">// Is it already a Reader?</span></span><br><span class="line">    b, ok := rd.(*Reader)</span><br><span class="line">    <span class="keyword">if</span> ok &amp;&amp; <span class="built_in">len</span>(b.buf) &gt;= size &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> size &lt; minReadBufferSize &#123;</span><br><span class="line">        size = minReadBufferSize</span><br><span class="line">    &#125;</span><br><span class="line">    r := <span class="built_in">new</span>(Reader)</span><br><span class="line">    r.reset(<span class="built_in">make</span>([]<span class="keyword">byte</span>, size), rd)</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而<code>os</code>因为少了这一层缓冲区，每次读取，都会执行系统调用，因此内核频繁的在用户态和内核态之间切换，而这种切换，也是需要消耗的，故而会慢于<code>bufio</code>的读取方式。笔者翻阅网上资料，关于缓冲，有<strong>内核中的缓冲</strong>和<strong>进程中的缓冲</strong>两种，其中，内核中的缓冲是内核提供的，即系统对磁盘提供一个缓冲区，不管有没有提供进程中的缓冲，内核缓冲都是存在的。而进程中的缓冲是对输入输出流做了一定的改进，提供的一种流缓冲，它在读写操作发生时，先将数据存入流缓冲中，只有当流缓冲区满了或者刷新（如调用<code>flush</code>函数）时，才将数据取出，送往内核缓冲区，它起到了一定的保护内核的作用。因此，我们不难发现，<code>os</code>是典型的内核中的缓冲，而<code>bufio</code>和<code>ioutil</code>都属于进程中的缓冲。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>当读取小文件时，使用ioutil效率明显优于os和bufio，但如果是大文件，bufio读取会更快。</strong></p>
<h2 id="读取一行数据"><a href="#读取一行数据" class="headerlink" title="读取一行数据"></a>读取一行数据</h2><p>前面简要分析了 go 语言三种不同读取文件方式之间的区别。但实际的开发中，我们对文件的读取往往是以行为单位的，即每次读取一行进行处理。go 语言并没有像 C 语言一样给我们提供好了类似于<code>fgets</code>这样的函数可以正好读取一行内容，因此，需要自己去实现。从前面的对比分析可以知道，无论是处理大文件还是小文件，<code>bufio</code>始终是最为平滑和高效的，因此我们考虑使用<code>bufio</code>库进行处理。翻阅<code>bufio</code>库的源码，发现可以使用如下几种方式进行读取一行文件的处理：</p>
<ul>
<li><code>ReadBytes</code></li>
<li><code>ReadString</code></li>
<li><code>ReadSlice</code></li>
<li><code>ReadLine</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bufio"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readline1</span><span class="params">(filename <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	fi, err := os.Open(filename)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> fi.Close()</span><br><span class="line">	rd := bufio.NewReader(fi)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		_, err := rd.ReadBytes(<span class="string">'\n'</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> || err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readline2</span><span class="params">(filename <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	fi, err := os.Open(filename)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> fi.Close()</span><br><span class="line">	rd := bufio.NewReader(fi)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		_, err := rd.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> || err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readline3</span><span class="params">(filename <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	fi, err := os.Open(filename)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> fi.Close()</span><br><span class="line">	rd := bufio.NewReader(fi)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		_, err := rd.ReadSlice(<span class="string">'\n'</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> || err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readline4</span><span class="params">(filename <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	fi, err := os.Open(filename)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> fi.Close()</span><br><span class="line">	rd := bufio.NewReader(fi)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		_, _, err := rd.ReadLine()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> || err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testfile2</span><span class="params">(filename <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"============test %s ===========\n"</span>, filename)</span><br><span class="line">	start := time.Now()</span><br><span class="line">	readline1(filename)</span><br><span class="line">	t1 := time.Now()</span><br><span class="line">	fmt.Printf(<span class="string">"Readline 1 ReadBytes cost: %v\n"</span>, t1.Sub(start))</span><br><span class="line">	readline2(filename)</span><br><span class="line">	t2 := time.Now()</span><br><span class="line">	fmt.Printf(<span class="string">"Readline 2  ReadString cost: %v\n"</span>, t2.Sub(t1))</span><br><span class="line">	readline3(filename)</span><br><span class="line">	t3 := time.Now()</span><br><span class="line">	fmt.Printf(<span class="string">"Readline 3 ReadSlice cost: %v\n"</span>, t3.Sub(t2))</span><br><span class="line">	readline4(filename)</span><br><span class="line">	t4 := time.Now()</span><br><span class="line">	fmt.Printf(<span class="string">"Readline 4  ReadLine cost: %v\n"</span>, t4.Sub(t3))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	testfile2(<span class="string">"small.txt"</span>)</span><br><span class="line">	testfile2(<span class="string">"midium.txt"</span>)</span><br><span class="line">	testfile2(<span class="string">"large.txt"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://imghosting-1257040086.cos.ap-nanjing.myqcloud.com/img/read_file_line.jpg" alt=""></p>
<p>通过现象，除了<code>small.txt</code>之外，大致可以分为两组：</p>
<ul>
<li><code>ReadBytes</code>对文件处理效率最差</li>
<li>在处理大文件时，<code>ReadLine</code>和<code>ReadSlice</code>效率相近，要明显快于<code>ReadString</code>和<code>ReadBytes</code>。</li>
</ul>
<h3 id="原因分析-1"><a href="#原因分析-1" class="headerlink" title="原因分析"></a>原因分析</h3><p>为什么会出现上面的现象，不防从源码层面进行分析。通过阅读源码，我们发现这四个函数之间存在这样一个关系：</p>
<ul>
<li><code>ReadLine</code> &lt;- (调用) <code>ReadSlice</code></li>
<li><code>ReadString</code> &lt;- (调用)<code>ReadBytes</code>&lt;-(调用)<code>ReadSlice</code></li>
</ul>
<p>既然如此，那为什么在处理大文件时，<code>ReadLine</code>效率要明显高于<code>ReadBytes</code>呢？</p>
<p>首先，我们要知道，<code>ReadSlice</code>是切片式读取，即根据分隔符去进行切片。通过源码发下，<code>ReadLine</code>只是在切片读取的基础上，对换行符<code>\n</code>和<code>\r\n</code>做了一些处理：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadLine</span><span class="params">()</span> <span class="params">(line []<span class="keyword">byte</span>, isPrefix <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">    line, err = b.ReadSlice(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">if</span> err == ErrBufferFull &#123;</span><br><span class="line">        <span class="comment">// Handle the case where "\r\n" straddles the buffer.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(line) &gt; <span class="number">0</span> &amp;&amp; line[<span class="built_in">len</span>(line)<span class="number">-1</span>] == <span class="string">'\r'</span> &#123;</span><br><span class="line">            <span class="comment">// Put the '\r' back on buf and drop it from line.</span></span><br><span class="line">            <span class="comment">// Let the next call to ReadLine check for "\r\n".</span></span><br><span class="line">            <span class="keyword">if</span> b.r == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// should be unreachable</span></span><br><span class="line">                <span class="built_in">panic</span>(<span class="string">"bufio: tried to rewind past start of buffer"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            b.r--</span><br><span class="line">            line = line[:<span class="built_in">len</span>(line)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> line, <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(line) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            line = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    err = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> line[<span class="built_in">len</span>(line)<span class="number">-1</span>] == <span class="string">'\n'</span> &#123;</span><br><span class="line">        drop := <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(line) &gt; <span class="number">1</span> &amp;&amp; line[<span class="built_in">len</span>(line)<span class="number">-2</span>] == <span class="string">'\r'</span> &#123;</span><br><span class="line">            drop = <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        line = line[:<span class="built_in">len</span>(line)-drop]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而<code>ReadBytes</code>则是通过<code>append</code>先将读取的内容暂存到<code>full</code>数组中，最后再<code>copy</code>出来，<code>append</code>和<code>copy</code>都是要消耗内存和 io 的，因此效率自然就慢了。其源码如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadBytes</span><span class="params">(delim <span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Use ReadSlice to look for array,</span></span><br><span class="line">    <span class="comment">// accumulating full buffers.</span></span><br><span class="line">    <span class="keyword">var</span> frag []<span class="keyword">byte</span></span><br><span class="line">    <span class="keyword">var</span> full [][]<span class="keyword">byte</span></span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> e error</span><br><span class="line">        frag, e = b.ReadSlice(delim)</span><br><span class="line">        <span class="keyword">if</span> e == <span class="literal">nil</span> &#123; <span class="comment">// got final fragment</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> e != ErrBufferFull &#123; <span class="comment">// unexpected error</span></span><br><span class="line">            err = e</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make a copy of the buffer.</span></span><br><span class="line">        buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(frag))</span><br><span class="line">        <span class="built_in">copy</span>(buf, frag)</span><br><span class="line">        full = <span class="built_in">append</span>(full, buf)</span><br><span class="line">        n += <span class="built_in">len</span>(buf)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n += <span class="built_in">len</span>(frag)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate new buffer to hold the full pieces and the fragment.</span></span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, n)</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="comment">// Copy full pieces and fragment in.</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> full &#123;</span><br><span class="line">        n += <span class="built_in">copy</span>(buf[n:], full[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">copy</span>(buf[n:], frag)</span><br><span class="line">    <span class="keyword">return</span> buf, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>读取文件中一行内容时，<code>ReadSlice</code>和<code>ReadLine</code>性能优于<code>ReadBytes</code>和<code>ReadString</code>，但由于<code>ReadLine</code>对换行的处理更加全面（兼容<code>\n</code>和<code>\r\n</code>换行），因此，实际开发过程中，建议使用<code>ReadLine</code>函数。</p>
<blockquote>
<p>参考原文链接：<a href="https://segmentfault.com/a/1190000023691973" target="_blank" rel="noopener">https://segmentfault.com/a/1190000023691973</a></p>
</blockquote>
]]></content>
      <categories>
        <category>go</category>
        <category>os</category>
        <category>bufio</category>
        <category>ioutil</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>os</tag>
        <tag>bufio</tag>
        <tag>ioutil</tag>
      </tags>
  </entry>
  <entry>
    <title>Gin中使用JWT</title>
    <url>/2020/08/27/go-Gin%E4%B8%AD%E4%BD%BF%E7%94%A8JWT/</url>
    <content><![CDATA[<h2 id="为什么需要JWT？"><a href="#为什么需要JWT？" class="headerlink" title="为什么需要JWT？"></a>为什么需要JWT？</h2><p>在之前的一些web项目中，我们通常使用的是Cookie-Session模式实现用户认证。相关流程大致如下：</p>
<ol>
<li>用户在浏览器端填写用户名和密码，并发送给服务端</li>
<li>服务端对用户名和密码校验通过后会生成一份保存当前用户相关信息的session数据和一个与之对应的标识（通常称为session_id）</li>
<li>服务端返回响应时将上一步的session_id写入用户浏览器的Cookie</li>
<li>后续用户来自该浏览器的每次请求都会自动携带包含session_id的Cookie</li>
<li>服务端通过请求中的session_id就能找到之前保存的该用户那份session数据，从而获取该用户的相关信息。</li>
</ol>
<a id="more"></a>
<p>这种方案依赖于客户端（浏览器）保存Cookie，并且需要在服务端存储用户的session数据。</p>
<p>在移动互联网时代，我们的用户可能使用浏览器也可能使用APP来访问我们的服务，我们的web应用可能是前后端分开部署在不同的端口，有时候我们还需要支持第三方登录，这下Cookie-Session的模式就有些力不从心了。</p>
<p>JWT就是一种基于Token的轻量级认证模式，服务端认证通过后，会生成一个JSON对象，经过签名后得到一个Token（令牌）再发回给用户，用户后续请求只需要带上这个Token，服务端解密之后就能获取该用户的相关信息了。</p>
<p>参考：<a href="https://www.liwenzhou.com/posts/Go/jwt_in_gin/" target="_blank" rel="noopener">李文周博客</a> <a href="https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">阮一峰的网络日志</a> <a href="https://segmentfault.com/a/1190000013297828" target="_blank" rel="noopener">煎鱼的博客</a></p>
<h4 id="下载依赖包"><a href="#下载依赖包" class="headerlink" title="下载依赖包"></a>下载依赖包</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u github.com/dgrijalva/jwt-go</span><br></pre></td></tr></table></figure>
<h4 id="定义需求"><a href="#定义需求" class="headerlink" title="定义需求"></a>定义需求</h4><p>我们需要定制自己的需求来决定JWT中保存哪些数据，比如我们规定在JWT中要存储<code>username</code>信息，那么我们就定义一个<code>MyClaims</code>结构体如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Claims 自定义声明结构体并内嵌jwt.StandardClaims</span><br><span class="line">&#x2F;&#x2F; jwt包自带的jwt.StandardClaims只包含了官方字段</span><br><span class="line">&#x2F;&#x2F; 我们这里需要额外记录一个username字段，所以要自定义结构体</span><br><span class="line">&#x2F;&#x2F; 如果想要保存更多信息，都可以添加到这个结构体中</span><br><span class="line"></span><br><span class="line">type Claims struct &#123;</span><br><span class="line">    Username string &#96;json:&quot;username&quot;&#96;</span><br><span class="line">    Password string &#96;json:&quot;password&quot;&#96;</span><br><span class="line">    jwt.StandardClaims</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们定义JWT的过期时间，这里以2小时为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const TokenExpireDuration &#x3D; time.Hour * 2</span><br></pre></td></tr></table></figure>
<p>接下来还需要定义Secret：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var jwtSecret &#x3D; []byte(setting.JwtSecret)</span><br></pre></td></tr></table></figure>
<h4 id="生成JWT"><a href="#生成JWT" class="headerlink" title="生成JWT"></a>生成JWT</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateToken</span><span class="params">(username, password <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    claims := Claims&#123;</span><br><span class="line">        username,</span><br><span class="line">        password,</span><br><span class="line">        jwt.StandardClaims &#123;</span><br><span class="line">            ExpiresAt : time.Now().Add(TokenExpireDuration).Unix(),</span><br><span class="line">            Issuer : <span class="string">"gin-blog"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 使用指定的签名方法创建签名对象</span></span><br><span class="line">    tokenClaims := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)</span><br><span class="line">    <span class="comment">// 使用指定的secret签名并获得完整的编码后的字符串token</span></span><br><span class="line">    token, err := tokenClaims.SignedString(jwtSecret)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> token, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解析JWT"><a href="#解析JWT" class="headerlink" title="解析JWT"></a>解析JWT</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseToken</span><span class="params">(token <span class="keyword">string</span>)</span> <span class="params">(*Claims, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 解析token</span></span><br><span class="line">    tokenClaims, err := jwt.ParseWithClaims(token, &amp;Claims&#123;&#125;, <span class="function"><span class="keyword">func</span><span class="params">(token *jwt.Token)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jwtSecret, <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> tokenClaims != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> claims, ok := tokenClaims.Claims.(*Claims); ok &amp;&amp; tokenClaims.Valid &#123;</span><br><span class="line">            <span class="keyword">return</span> claims, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>NewWithClaims(method SigningMethod, claims Claims)</code>，<code>method</code>对应着<code>SigningMethodHMAC struct{}</code>，其包含<code>SigningMethodHS256</code>、<code>SigningMethodHS384</code>、<code>SigningMethodHS512</code>三种<code>crypto.Hash</code>方案</li>
<li><code>func (t *Token) SignedString(key interface{})</code> 该方法内部生成签名字符串，再用于获取完整、已签名的<code>token</code></li>
<li><code>func (p *Parser) ParseWithClaims</code> 用于解析鉴权的声明，<a href="https://gowalker.org/github.com/dgrijalva/jwt-go#Parser_ParseWithClaims" target="_blank" rel="noopener">方法内部</a>主要是具体的解码和校验的过程，最终返回<code>*Token</code></li>
<li><code>func (m MapClaims) Valid()</code> 验证基于时间的声明<code>exp, iat, nbf</code>，注意如果没有任何声明在令牌中，仍然会被认为是有效的。并且对于时区偏差没有计算方法</li>
</ul>
<h4 id="GIn中间件"><a href="#GIn中间件" class="headerlink" title="GIn中间件"></a>GIn中间件</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jwt</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"gin-blog/pkg/util"</span></span><br><span class="line">    <span class="string">"gin-blog/pkg/e"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">JWTAuthMiddleware</span><span class="params">()</span> <span class="title">gin</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> code <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">var</span> data <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        code = e.SUCCESS</span><br><span class="line">        token := c.Query(<span class="string">"token"</span>)</span><br><span class="line">        <span class="keyword">if</span> token == <span class="string">""</span> &#123;</span><br><span class="line">            code = e.INVALID_PARAMS</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            claims, err := util.ParseToken(token)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                code = e.ERROR_AUTH_CHECK_TOKEN_FAIL</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> time.Now().Unix() &gt; claims.ExpiresAt &#123;</span><br><span class="line">                code = e.ERROR_AUTH_CHECK_TOKEN_TIMEOUT</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> code != e.SUCCESS &#123;</span><br><span class="line">            c.JSON(http.StatusUnauthorized, gin.H&#123;</span><br><span class="line">                <span class="string">"code"</span> : code,</span><br><span class="line">                <span class="string">"msg"</span> : e.GetMsg(code),</span><br><span class="line">                <span class="string">"data"</span> : data,</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            c.Abort()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        c.Next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="获取TOKEN"><a href="#获取TOKEN" class="headerlink" title="获取TOKEN"></a>获取TOKEN</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">authHandler</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> user UserInfo</span><br><span class="line">	err := c.ShouldBind(&amp;user)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			<span class="string">"code"</span>:<span class="number">2001</span>,</span><br><span class="line">			<span class="string">"msg"</span>:<span class="string">"无效参数"</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">		c.Abort()</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> user.Username == <span class="string">"qimi"</span> &amp;&amp; user.Password==<span class="string">"123456"</span>&#123;</span><br><span class="line">		tokenString, _ := GenToken(user.Username)</span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			<span class="string">"code"</span>:<span class="number">2000</span>,</span><br><span class="line">			<span class="string">"msg"</span>:<span class="string">"success"</span>,</span><br><span class="line">			<span class="string">"data"</span>:gin.H&#123;<span class="string">"token"</span>:tokenString&#125;,</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">		<span class="string">"code"</span>:<span class="number">2002</span>,</span><br><span class="line">		<span class="string">"msg"</span>:<span class="string">"鉴权失败"</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="验证TOKEN"><a href="#验证TOKEN" class="headerlink" title="验证TOKEN"></a>验证TOKEN</h4><p>用<code>GET</code>方式访问<code>http:127.0.0.1:8080/login?username=qimi&amp;password=123456</code> 查看返回值是否正确</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"code"</span>: <span class="number">2000</span>,</span><br><span class="line">    <span class="string">"data"</span>: &#123;</span><br><span class="line">        <span class="string">"token"</span>: <span class="string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InFpbWkiLCJleHAiOjE1OTkxMjQ1OTgsImlzcyI6Im15LXByb2plY3QifQ.omnDmr9-wSXjjxIZmIysRu7khVB_ginuY9FUqd40q1w"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"msg"</span>: <span class="string">"success"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证方法 路由</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">homeHandler</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	<span class="comment">//username := c.MustGet("username").(string)</span></span><br><span class="line">	c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">		<span class="string">"code"</span>: <span class="number">2000</span>,</span><br><span class="line">		<span class="string">"msg"</span>:  <span class="string">"success"</span>,</span><br><span class="line">		<span class="comment">//"data": gin.H&#123;"username": username&#125;,</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用<code>GET</code>方式访问<code>127.0.0.1:8080/home?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InFpbWkiLCJleHAiOjE1OTkxMjQ1OTgsImlzcyI6Im15LXByb2plY3QifQ.omnDmr9-wSXjjxIZmIysRu7khVB_ginuY9FUqd40q1p</code> 查看返回值是否正确</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"code"</span>: <span class="number">2000</span>,</span><br><span class="line">    <span class="string">"msg"</span>: <span class="string">"success"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试demo</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"github.com/dgrijalva/jwt-go"</span></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">	Username <span class="keyword">string</span> <span class="string">`form:"username" json:"username" binding:"required"`</span></span><br><span class="line">	Password <span class="keyword">string</span> <span class="string">`form:"password" json:"password" binding:"required"`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> MyClaims <span class="keyword">struct</span> &#123;</span><br><span class="line">	Username <span class="keyword">string</span> <span class="string">`json:"username"`</span></span><br><span class="line">	jwt.StandardClaims</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> TokenExpireDuration = time.Minute * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> MySecret = []<span class="keyword">byte</span>(<span class="string">"夏天夏天悄悄过去"</span>)</span><br><span class="line"><span class="comment">// GenToken 生成JWT</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenToken</span><span class="params">(username <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个我们自己的声明</span></span><br><span class="line">	c := MyClaims&#123;</span><br><span class="line">		username, <span class="comment">// 自定义字段</span></span><br><span class="line">		jwt.StandardClaims&#123;</span><br><span class="line">			ExpiresAt: time.Now().Add(TokenExpireDuration).Unix(), <span class="comment">// 过期时间</span></span><br><span class="line">			Issuer:    <span class="string">"my-project"</span>,                               <span class="comment">// 签发人</span></span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 使用指定的签名方法创建签名对象</span></span><br><span class="line">	token := jwt.NewWithClaims(jwt.SigningMethodHS256, c)</span><br><span class="line">	<span class="comment">// 使用指定的secret签名并获得完整的编码后的字符串token</span></span><br><span class="line">	<span class="keyword">return</span> token.SignedString(MySecret)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">authHandler</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> user UserInfo</span><br><span class="line">	err := c.ShouldBind(&amp;user)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			<span class="string">"code"</span>:<span class="number">2001</span>,</span><br><span class="line">			<span class="string">"msg"</span>:<span class="string">"无效参数"</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">		c.Abort()</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> user.Username == <span class="string">"qimi"</span> &amp;&amp; user.Password==<span class="string">"123456"</span>&#123;</span><br><span class="line">		tokenString, _ := GenToken(user.Username)</span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			<span class="string">"code"</span>:<span class="number">2000</span>,</span><br><span class="line">			<span class="string">"msg"</span>:<span class="string">"success"</span>,</span><br><span class="line">			<span class="string">"data"</span>:gin.H&#123;<span class="string">"token"</span>:tokenString&#125;,</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">		<span class="string">"code"</span>:<span class="number">2002</span>,</span><br><span class="line">		<span class="string">"msg"</span>:<span class="string">"鉴权失败"</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseToken</span><span class="params">(tokenString <span class="keyword">string</span>)</span> <span class="params">(*MyClaims, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 解析token</span></span><br><span class="line">	token, err := jwt.ParseWithClaims(tokenString, &amp;MyClaims&#123;&#125;, <span class="function"><span class="keyword">func</span><span class="params">(token *jwt.Token)</span> <span class="params">(i <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> MySecret, <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> claims, ok := token.Claims.(*MyClaims); ok &amp;&amp; token.Valid &#123; <span class="comment">// 校验token</span></span><br><span class="line">		<span class="keyword">return</span> claims, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"invalid token"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//func JWTAuthMiddleware() func(c *gin.Context) &#123;</span></span><br><span class="line"><span class="comment">//	return func(c *gin.Context) &#123;</span></span><br><span class="line"><span class="comment">//		authHeader := c.Request.Header.Get("Authorization")</span></span><br><span class="line"><span class="comment">//		fmt.Println("==========================")</span></span><br><span class="line"><span class="comment">//		fmt.Println(authHeader)</span></span><br><span class="line"><span class="comment">//		fmt.Println("==========================")</span></span><br><span class="line"><span class="comment">//		if authHeader == ""&#123;</span></span><br><span class="line"><span class="comment">//			c.JSON(http.StatusOK, gin.H&#123;</span></span><br><span class="line"><span class="comment">//				"code":2003,</span></span><br><span class="line"><span class="comment">//				"msg":"请求头中auth为空",</span></span><br><span class="line"><span class="comment">//			&#125;)</span></span><br><span class="line"><span class="comment">//			c.Abort()</span></span><br><span class="line"><span class="comment">//			return</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		// 按空格分割</span></span><br><span class="line"><span class="comment">//		parts := strings.SplitN(authHeader, " ", 2)</span></span><br><span class="line"><span class="comment">//		fmt.Println("111111111111111111111", parts)</span></span><br><span class="line"><span class="comment">//		//if !(len(parts) == 2 &amp;&amp; parts[0] == "Bearer") &#123;</span></span><br><span class="line"><span class="comment">//		//	c.JSON(http.StatusOK, gin.H&#123;</span></span><br><span class="line"><span class="comment">//		//		"code": 2004,</span></span><br><span class="line"><span class="comment">//		//		"msg":  "请求头中auth格式有误",</span></span><br><span class="line"><span class="comment">//		//	&#125;)</span></span><br><span class="line"><span class="comment">//		//	c.Abort()</span></span><br><span class="line"><span class="comment">//		//	return</span></span><br><span class="line"><span class="comment">//		//&#125;</span></span><br><span class="line"><span class="comment">//		// parts[1]是获取到的tokenString，我们使用之前定义好的解析JWT的函数来解析它</span></span><br><span class="line"><span class="comment">//		fmt.Println("===============================")</span></span><br><span class="line"><span class="comment">//		fmt.Println(parts[0])</span></span><br><span class="line"><span class="comment">//		fmt.Println("===============================")</span></span><br><span class="line"><span class="comment">//		mc, err := ParseToken(parts[0])</span></span><br><span class="line"><span class="comment">//		if err != nil &#123;</span></span><br><span class="line"><span class="comment">//			c.JSON(http.StatusOK, gin.H&#123;</span></span><br><span class="line"><span class="comment">//				"code": 2005,</span></span><br><span class="line"><span class="comment">//				"msg":  "无效的Token",</span></span><br><span class="line"><span class="comment">//			&#125;)</span></span><br><span class="line"><span class="comment">//			c.Abort()</span></span><br><span class="line"><span class="comment">//			return</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		// 将当前请求的username信息保存到请求的上下文c上</span></span><br><span class="line"><span class="comment">//		c.Set("username", mc.Username)</span></span><br><span class="line"><span class="comment">//		c.Next() // 后续的处理函数可以用过c.Get("username")来获取当前请求的用户信息</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">JWT</span><span class="params">()</span> <span class="title">gin</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> code <span class="keyword">int</span></span><br><span class="line">		<span class="keyword">var</span> data <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">		code = <span class="number">200</span></span><br><span class="line">		token := c.Query(<span class="string">"token"</span>)</span><br><span class="line">		<span class="keyword">if</span> token == <span class="string">""</span> &#123;</span><br><span class="line">			code = <span class="number">400</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			_, err := ParseToken(token)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">switch</span> err.(*jwt.ValidationError).Errors &#123;</span><br><span class="line">				<span class="keyword">case</span> jwt.ValidationErrorExpired:</span><br><span class="line">					code = <span class="number">500</span></span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					code = <span class="number">500</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> code != <span class="number">200</span> &#123;</span><br><span class="line">			c.JSON(http.StatusUnauthorized, gin.H&#123;</span><br><span class="line">				<span class="string">"code"</span>: code,</span><br><span class="line">				<span class="string">"msg"</span>:  <span class="number">600</span>,</span><br><span class="line">				<span class="string">"data"</span>: data,</span><br><span class="line">			&#125;)</span><br><span class="line"></span><br><span class="line">			c.Abort()</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		c.Next()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">homeHandler</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	<span class="comment">//username := c.MustGet("username").(string)</span></span><br><span class="line">	c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">		<span class="string">"code"</span>: <span class="number">2000</span>,</span><br><span class="line">		<span class="string">"msg"</span>:  <span class="string">"success"</span>,</span><br><span class="line">		<span class="comment">//"data": gin.H&#123;"username": username&#125;,</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := gin.Default()</span><br><span class="line">	c.GET(<span class="string">"/login"</span>, authHandler)</span><br><span class="line">	<span class="comment">//c.GET("/home", JWTAuthMiddleware(), homeHandler)</span></span><br><span class="line">	c.GET(<span class="string">"/home"</span>, JWT(), homeHandler)</span><br><span class="line"></span><br><span class="line">	err := c.Run(<span class="string">":8080"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
        <category>Gin</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>gin</tag>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title>go -- 标准库-- bufio</title>
    <url>/2018/03/06/go-%E6%A0%87%E5%87%86%E5%BA%93-bufio/</url>
    <content><![CDATA[<p><a href="https://golang.org/pkg/bufio/" target="_blank" rel="noopener">bufio</a> 用来帮助处理 <a href="https://www.quora.com/In-C-what-does-buffering-I-O-or-buffered-I-O-mean/answer/Robert-Love-1" target="_blank" rel="noopener">I/O 缓存</a>。 我们将通过一些示例来熟悉其为我们提供的：Reader, Writer and Scanner 等一系列功能</p>
<h2 id="bufio-Writer"><a href="#bufio-Writer" class="headerlink" title="bufio.Writer"></a>bufio.Writer</h2><p>多次进行小量的写操作会影响程序性能。每一次写操作最终都会体现为系统层调用，频繁进行该操作将有可能对 CPU 造成伤害。而且很多硬件设备更适合处理块对齐的数据，例如硬盘。为了减少进行多次写操作所需的开支，golang 提供了 <a href="https://golang.org/pkg/bufio/#Writer" target="_blank" rel="noopener">bufio.Writer</a>。数据将不再直接写入目的地(实现了 <a href="https://golang.org/pkg/io/#Writer" target="_blank" rel="noopener">io.Writer</a> 接口)，而是先写入缓存，当缓存写满后再统一写入目的地：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">producer --&gt; buffer --&gt; io.Writer</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>下面具体看一下在9次写入操作中(每次写入一个字符)具有4个字符空间的缓存是如何工作的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">producer        buffer       destination (io.Writer)</span><br><span class="line">   a    -----&gt;    a</span><br><span class="line">   b    -----&gt;    ab</span><br><span class="line">   c    -----&gt;    abc</span><br><span class="line">   d    -----&gt;    abcd</span><br><span class="line">   e    -----&gt;    e      -----&gt;   abcd</span><br><span class="line">   f    -----&gt;    ef</span><br><span class="line">   g    -----&gt;    efg</span><br><span class="line">   h    -----&gt;    efgh</span><br><span class="line">   i    -----&gt;    i      -----&gt;   abcdefgh</span><br></pre></td></tr></table></figure>
<p><code>-----&gt;</code> 箭头代表写入操作</p>
<p><a href="https://golang.org/pkg/bufio/#Writer" target="_blank" rel="noopener"><code>bufio.Writer</code></a> 底层使用 <code>[]byte</code> 进行缓存</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Writer)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(p))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(p), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Unbuffered I/O"</span>)</span><br><span class="line">    w := <span class="built_in">new</span>(Writer)</span><br><span class="line">    w.Write([]<span class="keyword">byte</span>&#123;<span class="string">'a'</span>&#125;)</span><br><span class="line">    w.Write([]<span class="keyword">byte</span>&#123;<span class="string">'b'</span>&#125;)</span><br><span class="line">    w.Write([]<span class="keyword">byte</span>&#123;<span class="string">'c'</span>&#125;)</span><br><span class="line">    w.Write([]<span class="keyword">byte</span>&#123;<span class="string">'d'</span>&#125;)</span><br><span class="line">    fmt.Println(<span class="string">"Buffered I/O"</span>)</span><br><span class="line">    bw := bufio.NewWriterSize(w, <span class="number">3</span>)</span><br><span class="line">    bw.Write([]<span class="keyword">byte</span>&#123;<span class="string">'a'</span>&#125;)</span><br><span class="line">    bw.Write([]<span class="keyword">byte</span>&#123;<span class="string">'b'</span>&#125;)</span><br><span class="line">    bw.Write([]<span class="keyword">byte</span>&#123;<span class="string">'c'</span>&#125;)</span><br><span class="line">    bw.Write([]<span class="keyword">byte</span>&#123;<span class="string">'d'</span>&#125;)</span><br><span class="line">    err := bw.Flush()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Unbuffered I/O</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">Buffered I/O</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>没有被缓存的 <code>I/O</code>：意味着每一次写操作都将直接写入目的地。我们进行4次写操作，每次写操作都映射为对 <code>Write</code> 的调用，调用时传入的参数为一个长度为1的 <code>byte</code> 切片。</p>
<p>使用了缓存的 <code>I/O</code>：我们使用三个字节长度的缓存来存储数据，当缓存满时进行一次 <code>flush</code> 操作(将缓存中的数据进行处理)。前三次写入写满了缓存。第四次写入时检测到缓存没有剩余空间，所以将缓存中的积累的数据写出。字母 <code>d</code> 被存储了，但在此之前 <code>Flush</code> 被调用以腾出空间。当缓存被写到末尾时，缓存中未被处理的数据需要被处理。<code>bufio.Writer</code> 仅在缓存充满或者显式调用 <code>Flush</code> 方法时处理(发送)数据。</p>
<blockquote>
<p><code>bufio.Writer</code> 默认使用 4096 长度字节的缓存，可以使用 <a href="https://golang.org/pkg/bufio/#NewWriterSize" target="_blank" rel="noopener"><code>NewWriterSize</code></a> 方法来设定该值</p>
</blockquote>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>实现十分简单：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">struct</span> &#123;</span><br><span class="line">    err error</span><br><span class="line">    buf []<span class="keyword">byte</span></span><br><span class="line">    n   <span class="keyword">int</span></span><br><span class="line">    wr  io.Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字段 <code>buf</code> 用来存储数据，当缓存满或者 <code>Flush</code> 被调用时，消费者(<code>wr</code>)可以从缓存中获取到数据。如果写入过程中发生了 I/O error，此 error 将会被赋给 <code>err</code> 字段， error 发生之后，writer 将停止操作(writer is no-op)：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Writer)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Write: %q\n"</span>, p)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">"boom!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    w := <span class="built_in">new</span>(Writer)</span><br><span class="line">    bw := bufio.NewWriterSize(w, <span class="number">3</span>)</span><br><span class="line">    bw.Write([]<span class="keyword">byte</span>&#123;<span class="string">'a'</span>&#125;)</span><br><span class="line">    bw.Write([]<span class="keyword">byte</span>&#123;<span class="string">'b'</span>&#125;)</span><br><span class="line">    bw.Write([]<span class="keyword">byte</span>&#123;<span class="string">'c'</span>&#125;)</span><br><span class="line">    bw.Write([]<span class="keyword">byte</span>&#123;<span class="string">'d'</span>&#125;)</span><br><span class="line">    err := bw.Flush()</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">Write: <span class="string">"abc"</span></span><br><span class="line">boom!</span><br></pre></td></tr></table></figure>
<p>这里我们可以看到 <code>Flush</code> 没有第二次调用消费者的 <code>write</code> 方法。如果发生了 error， 使用了缓存的 writer 不会尝试再次执行写操作。</p>
<p>字段 <code>n</code> 标识缓存内部当前操作的位置。<code>Buffered</code> 方法返回 <code>n</code> 的值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Writer)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(p), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    w := <span class="built_in">new</span>(Writer)</span><br><span class="line">    bw := bufio.NewWriterSize(w, <span class="number">3</span>)</span><br><span class="line">    fmt.Println(bw.Buffered())</span><br><span class="line">    bw.Write([]<span class="keyword">byte</span>&#123;<span class="string">'a'</span>&#125;)</span><br><span class="line">    fmt.Println(bw.Buffered())</span><br><span class="line">    bw.Write([]<span class="keyword">byte</span>&#123;<span class="string">'b'</span>&#125;)</span><br><span class="line">    fmt.Println(bw.Buffered())</span><br><span class="line">    bw.Write([]<span class="keyword">byte</span>&#123;<span class="string">'c'</span>&#125;)</span><br><span class="line">    fmt.Println(bw.Buffered())</span><br><span class="line">    bw.Write([]<span class="keyword">byte</span>&#123;<span class="string">'d'</span>&#125;)</span><br><span class="line">    fmt.Println(bw.Buffered())</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><code>n</code> 从 0 开始，当有数据被添加到缓存中时，该数据的长度值将会被加和到 <code>n</code>中(操作位置向后移动)。当<code>bw.Write([] byte{&#39;d&#39;})</code>被调用时，flush会被触发，<code>n</code> 会被重设为0。</p>
<h2 id="Large-writes"><a href="#Large-writes" class="headerlink" title="Large writes"></a>Large writes</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Writer)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, p)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(p), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    w := <span class="built_in">new</span>(Writer)</span><br><span class="line">    bw := bufio.NewWriterSize(w, <span class="number">3</span>)</span><br><span class="line">    bw.Write([]<span class="keyword">byte</span>(<span class="string">"abcd"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于使用了 <code>bufio</code>，程序打印了 <code>&quot;abcd&quot;</code>。如果 <code>Writer</code> 检测到 <code>Write</code> 方法被调用时传入的数据长度大于缓存的长度(示例中是三个字节)。其将直接调用 writer(目的对象)的 <code>Write</code> 方法。当数据量足够大时，其会自动跳过内部缓存代理。</p>
<h2 id="重置"><a href="#重置" class="headerlink" title="重置"></a>重置</h2><p>缓存是 <code>bufio</code> 的核心部分。通过使用 <code>Reset</code> 方法，<code>Writer</code> 可以用于不同的目的对象。重复使用 <code>Writer</code> 缓存减少了内存的分配。而且减少了额外的垃圾回收工作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer1 <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Writer1)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"writer#1: %q\n"</span>, p)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(p), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Writer2 <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Writer2)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"writer#2: %q\n"</span>, p)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(p), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    w1 := <span class="built_in">new</span>(Writer1)</span><br><span class="line">    bw := bufio.NewWriterSize(w1, <span class="number">2</span>)</span><br><span class="line">    bw.Write([]<span class="keyword">byte</span>(<span class="string">"ab"</span>))</span><br><span class="line">    bw.Write([]<span class="keyword">byte</span>(<span class="string">"cd"</span>))</span><br><span class="line">    w2 := <span class="built_in">new</span>(Writer2)</span><br><span class="line">    bw.Reset(w2)</span><br><span class="line">    bw.Write([]<span class="keyword">byte</span>(<span class="string">"ef"</span>))</span><br><span class="line">    bw.Flush()</span><br><span class="line">&#125;</span><br><span class="line">writer#<span class="number">1</span>: <span class="string">"ab"</span></span><br><span class="line">writer#<span class="number">2</span>: <span class="string">"ef"</span></span><br></pre></td></tr></table></figure>
<p>这段代码中有一个 bug。在调用 <code>Reset</code> 方法之前，我们应该使用 <code>Flush</code> flush缓存。 由于 <a href="https://github.com/golang/go/blob/7b8a7f8272fd1941a199af1adb334bd9996e8909/src/bufio/bufio.go#L559" target="_blank" rel="noopener"><code>Reset</code></a> 只是简单的丢弃未被处理的数据，所以已经被写入的数据 <code>cd</code> 丢失了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Reset</span><span class="params">(w io.Writer)</span></span> &#123;</span><br><span class="line">    b.err = <span class="literal">nil</span></span><br><span class="line">    b.n = <span class="number">0</span></span><br><span class="line">    b.wr = w</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="缓存剩余空间"><a href="#缓存剩余空间" class="headerlink" title="缓存剩余空间"></a>缓存剩余空间</h2><p>为了检测缓存中还剩余多少空间, 我们可以使用方法 <code>Available</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">w := <span class="built_in">new</span>(Writer)</span><br><span class="line">bw := bufio.NewWriterSize(w, <span class="number">2</span>)</span><br><span class="line">fmt.Println(bw.Available())</span><br><span class="line">bw.Write([]<span class="keyword">byte</span>&#123;<span class="string">'a'</span>&#125;)</span><br><span class="line">fmt.Println(bw.Available())</span><br><span class="line">bw.Write([]<span class="keyword">byte</span>&#123;<span class="string">'b'</span>&#125;)</span><br><span class="line">fmt.Println(bw.Available())</span><br><span class="line">bw.Write([]<span class="keyword">byte</span>&#123;<span class="string">'c'</span>&#125;)</span><br><span class="line">fmt.Println(bw.Available())</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="写-Byte-Rune-String-的方法"><a href="#写-Byte-Rune-String-的方法" class="headerlink" title="写{Byte,Rune,String}的方法"></a>写<code>{Byte,Rune,String}</code>的方法</h2><p>为了方便, 我们有三个用来写普通类型的实用方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">w := <span class="built_in">new</span>(Writer)</span><br><span class="line">bw := bufio.NewWriterSize(w, <span class="number">10</span>)</span><br><span class="line">fmt.Println(bw.Buffered())</span><br><span class="line">bw.WriteByte(<span class="string">'a'</span>)</span><br><span class="line">fmt.Println(bw.Buffered())</span><br><span class="line">bw.WriteRune(<span class="string">'ł'</span>) <span class="comment">// 'ł' occupies 2 bytes</span></span><br><span class="line">fmt.Println(bw.Buffered())</span><br><span class="line">bw.WriteString(<span class="string">"aa"</span>)</span><br><span class="line">fmt.Println(bw.Buffered())</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<h2 id="ReadFrom"><a href="#ReadFrom" class="headerlink" title="ReadFrom"></a>ReadFrom</h2><p>io 包中定义了 <a href="https://golang.org/pkg/io/#ReaderFrom" target="_blank" rel="noopener"><code>io.ReaderFrom</code></a> 接口。 该接口通常被 writer 实现，用于从指定的 reader 中读取所有数据(直到 EOF)并对读到的数据进行底层处理：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReaderFrom <span class="keyword">interface</span> &#123;</span><br><span class="line">        ReadFrom(r Reader) (n <span class="keyword">int64</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>比如 <a href="https://golang.org/pkg/io/#Copy" target="_blank" rel="noopener"><code>io.Copy</code></a> 使用了 <code>io.ReaderFrom</code> 接口</p>
</blockquote>
<p><code>bufio.Writer</code> 实现了此接口：因此我们可以通过调用 <code>ReadFrom</code> 方法来处理从 <code>io.Reader</code> 获取到的所有数据：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Writer)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, p)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(p), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := strings.NewReader(<span class="string">"onetwothree"</span>)</span><br><span class="line">    w := <span class="built_in">new</span>(Writer)</span><br><span class="line">    bw := bufio.NewWriterSize(w, <span class="number">3</span>)</span><br><span class="line">    bw.ReadFrom(s)</span><br><span class="line">    err := bw.Flush()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">"one"</span></span><br><span class="line"><span class="string">"two"</span></span><br><span class="line"><span class="string">"thr"</span></span><br><span class="line"><span class="string">"ee"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用 <code>ReadFrom</code> 方法的同时，调用 <code>Flush</code> 方法也很重要</p>
</blockquote>
<h2 id="bufio-Reader"><a href="#bufio-Reader" class="headerlink" title="bufio.Reader"></a>bufio.Reader</h2><p>通过它，我们可以从底层的 <code>io.Reader</code> 中更大批量的读取数据。这会使读取操作变少。如果数据读取时的块数量是固定合适的，底层媒体设备将会有更好的表现，也因此会提高程序的性能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">io.Reader --&gt; buffer --&gt; consumer</span><br></pre></td></tr></table></figure>
<p>假设消费者想要从硬盘上读取10个字符(每次读取一个字符)。在底层实现上，这将会触发10次读取操作。如果硬盘按每个数据块四个字节来读取数据，那么 <code>bufio.Reader</code> 将会起到帮助作用。底层引擎将会缓存整个数据块，然后提供一个可以挨个读取字节的 API 给消费者：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abcd -----&gt; abcd -----&gt; a</span><br><span class="line">            abcd -----&gt; b</span><br><span class="line">            abcd -----&gt; c</span><br><span class="line">            abcd -----&gt; d</span><br><span class="line">efgh -----&gt; efgh -----&gt; e</span><br><span class="line">            efgh -----&gt; f</span><br><span class="line">            efgh -----&gt; g</span><br><span class="line">            efgh -----&gt; h</span><br><span class="line">ijkl -----&gt; ijkl -----&gt; i</span><br><span class="line">            ijkl -----&gt; j</span><br></pre></td></tr></table></figure>
<p><code>-----&gt;</code> 代表读取操作<br>这个方法仅需要从硬盘读取三次，而不是10次。</p>
<h2 id="Peek"><a href="#Peek" class="headerlink" title="Peek"></a>Peek</h2><p><code>Peek</code> 方法可以帮助我们查看缓存的前 n 个字节而不会真的『吃掉』它：</p>
<ul>
<li>如果缓存不满，而且缓存中缓存的数据少于 <code>n</code> 个字节，其将会尝试从 <code>io.Reader</code> 中读取</li>
<li>如果请求的数据量大于缓存的容量，将会返回 <code>bufio.ErrBufferFull</code></li>
<li>如果 <code>n</code> 大于流的大小，将会返回 EOF</li>
</ul>
<p>让我们来看看它是如何工作的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := strings.NewReader(strings.Repeat(<span class="string">"a"</span>, <span class="number">20</span>))</span><br><span class="line">r := bufio.NewReaderSize(s1, <span class="number">16</span>)</span><br><span class="line">b, err := r.Peek(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%q\n"</span>, b)</span><br><span class="line">b, err = r.Peek(<span class="number">17</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">s2 := strings.NewReader(<span class="string">"aaa"</span>)</span><br><span class="line">r.Reset(s2)</span><br><span class="line">b, err = r.Peek(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">"aaa"</span></span><br><span class="line">bufio: buffer full</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<blockquote>
<p>被 <code>bufio.Reader</code> 使用的最小的缓存容器是 16。</p>
</blockquote>
<p>返回的切片和被 <code>bufio.Reader</code> 使用的内部缓存底层使用相同的数组。因此引擎底层在执行任何读取操作之后内部返回的切片将会变成无效的。这是由于其将有可能被其他的缓存数据覆盖：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := strings.NewReader(strings.Repeat(<span class="string">"a"</span>, <span class="number">16</span>) + strings.Repeat(<span class="string">"b"</span>, <span class="number">16</span>))</span><br><span class="line">r := bufio.NewReaderSize(s1, <span class="number">16</span>)</span><br><span class="line">b, _ := r.Peek(<span class="number">3</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%q\n"</span>, b)</span><br><span class="line">r.Read(<span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">16</span>))</span><br><span class="line">r.Read(<span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">15</span>))</span><br><span class="line">fmt.Printf(<span class="string">"%q\n"</span>, b)</span><br><span class="line"><span class="string">"aaa"</span></span><br><span class="line"><span class="string">"bbb"</span></span><br></pre></td></tr></table></figure>
<h2 id="Reset"><a href="#Reset" class="headerlink" title="Reset"></a>Reset</h2><p>就像 <code>bufio.Writer</code> 那样，缓存也可以用相似的方式被复用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := strings.NewReader(<span class="string">"abcd"</span>)</span><br><span class="line">r := bufio.NewReader(s1)</span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">3</span>)</span><br><span class="line">_, err := r.Read(b)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%q\n"</span>, b)</span><br><span class="line">s2 := strings.NewReader(<span class="string">"efgh"</span>)</span><br><span class="line">r.Reset(s2)</span><br><span class="line">_, err = r.Read(b)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%q\n"</span>, b)</span><br><span class="line"><span class="string">"abc"</span></span><br><span class="line"><span class="string">"efg"</span></span><br></pre></td></tr></table></figure>
<p>通过使用 <code>Reset</code>，我们可以避免冗余的内存分配和不必要的垃圾回收工作。</p>
<h2 id="Discard"><a href="#Discard" class="headerlink" title="Discard"></a>Discard</h2><p>这个方法将会丢弃 <code>n</code> 个字节的，返回时也不会返回被丢弃的 <code>n</code> 个字节。如果 <code>bufio.Reader</code> 缓存了超过或者等于 <code>n</code> 个字节的数据。那么其将不必从 <code>io.Reader</code> 中读取任何数据。其只是简单的从缓存中略去前 <code>n</code> 个字节：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> R <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *R)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Read"</span>)</span><br><span class="line">    <span class="built_in">copy</span>(p, <span class="string">"abcdefghijklmnop"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">16</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := <span class="built_in">new</span>(R)</span><br><span class="line">    br := bufio.NewReaderSize(r, <span class="number">16</span>)</span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span><br><span class="line">    br.Read(buf)</span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, buf)</span><br><span class="line">    br.Discard(<span class="number">4</span>)</span><br><span class="line">    br.Read(buf)</span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, buf)</span><br><span class="line">&#125;</span><br><span class="line">Read</span><br><span class="line"><span class="string">"abcd"</span></span><br><span class="line"><span class="string">"ijkl"</span></span><br></pre></td></tr></table></figure>
<p>调用 <code>Discard</code> 方法将不会从 reader <code>r</code> 中读取数据。另一种情况，缓存中数据量小于 <code>n</code>，那么 <code>bufio.Reader</code> 将会读取需要数量的数据来确保被丢弃的数据量不会少于 <code>n</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> R <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *R)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Read"</span>)</span><br><span class="line">    <span class="built_in">copy</span>(p, <span class="string">"abcdefghijklmnop"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">16</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := <span class="built_in">new</span>(R)</span><br><span class="line">    br := bufio.NewReaderSize(r, <span class="number">16</span>)</span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span><br><span class="line">    br.Read(buf)</span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, buf)</span><br><span class="line">    br.Discard(<span class="number">13</span>)</span><br><span class="line">    fmt.Println(<span class="string">"Discard"</span>)</span><br><span class="line">    br.Read(buf)</span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, buf)</span><br><span class="line">&#125;</span><br><span class="line">Read</span><br><span class="line"><span class="string">"abcd"</span></span><br><span class="line">Read</span><br><span class="line">Discard</span><br><span class="line"><span class="string">"bcde"</span></span><br></pre></td></tr></table></figure>
<p>由于调用了 <code>Discard</code> 方法，所以读取方法被调用了两次。</p>
<h2 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h2><p><code>Read</code> 方法是 <code>bufio.Reader</code> 的核心。它和 <a href="https://golang.org/pkg/io/#Reader" target="_blank" rel="noopener"><code>io.Reader</code></a> 的唯一方法具有相同的签名。因此 <code>bufio.Reader</code> 实现了这个普遍存在的接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">        Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>bufio.Reader</code> 的 <code>Read</code> 方法从底层的 <code>io.Reader</code> 中一次读取最大的数量:</p>
<ol>
<li><p>如果内部缓存具有至少一个字节的数据，那么无论传入的切片的大小(<code>len(p)</code>)是多少，<code>Read</code> 方法都将仅仅从内部缓存中获取数据，不会从底层的 reader 中读取任何数据:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *R)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"> fmt.Println(<span class="string">"Read"</span>)</span><br><span class="line"> <span class="built_in">copy</span>(p, <span class="string">"abcd"</span>)</span><br><span class="line"> <span class="keyword">return</span> <span class="number">4</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> r := <span class="built_in">new</span>(R)</span><br><span class="line"> br := bufio.NewReader(r)</span><br><span class="line"> buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">2</span>)</span><br><span class="line"> n, err := br.Read(buf)</span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">     <span class="built_in">panic</span>(err)</span><br><span class="line"> &#125;</span><br><span class="line"> buf = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span><br><span class="line"> n, err = br.Read(buf)</span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">     <span class="built_in">panic</span>(err)</span><br><span class="line"> &#125;</span><br><span class="line"> fmt.Printf(<span class="string">"read = %q, n = %d\n"</span>, buf[:n], n)</span><br><span class="line">&#125;</span><br><span class="line">Read</span><br><span class="line">read = <span class="string">"cd"</span>, n = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>我们的 <code>io.Reader</code> 实例无线返回「abcd」(不会返回 <code>io.EOF</code>)。 第二次调用 <code>Read</code>并传入长度为4的切片，但是内部缓存在第一次从 <code>io.Reader</code> 中读取数据之后已经具有数据「cd」，所以 <code>bufio.Reader</code> 返回缓存中的数据数据，而不和底层 reader 进行通信。</p>
</li>
<li><p>如果内部缓存是空的，那么将会执行一次从底层 io.Reader 的读取操作。 从前面的例子中我们可以清晰的看到如果我们开启了一个空的缓存，然后调用:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">n, err := br.Read(buf)</span><br></pre></td></tr></table></figure>
<p>将会触发读取操作来填充缓存。</p>
</li>
<li><p>如果内部缓存是空的，但是传入的切片长度大于缓存长度，那么 <code>bufio.Reader</code> 将会跳过缓存，直接读取传入切片长度的数据到切片中:</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> R <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *R)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"> fmt.Println(<span class="string">"Read"</span>)</span><br><span class="line"> <span class="built_in">copy</span>(p, strings.Repeat(<span class="string">"a"</span>, <span class="built_in">len</span>(p)))</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">len</span>(p), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> r := <span class="built_in">new</span>(R)</span><br><span class="line"> br := bufio.NewReaderSize(r, <span class="number">16</span>)</span><br><span class="line"> buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">17</span>)</span><br><span class="line"> n, err := br.Read(buf)</span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">     <span class="built_in">panic</span>(err)</span><br><span class="line"> &#125;</span><br><span class="line"> fmt.Printf(<span class="string">"read = %q, n = %d\n"</span>, buf[:n], n)</span><br><span class="line"> fmt.Printf(<span class="string">"buffered = %d\n"</span>, br.Buffered())</span><br><span class="line">&#125;</span><br><span class="line">Read</span><br><span class="line">read = <span class="string">"aaaaaaaaaaaaaaaaa"</span>, n = <span class="number">17</span></span><br><span class="line">buffered = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>从 <code>bufio.Reader</code> 读取之后，内部缓存中没有任何数据(<code>buffered = 0</code>)</p>
<h2 id="Read-Unread-Byte"><a href="#Read-Unread-Byte" class="headerlink" title="{Read, Unread}Byte"></a>{Read, Unread}Byte</h2><p>这些方法都实现了从缓存中读取单个字节或者将最后一个读取的字节返回到缓存:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r := strings.NewReader(<span class="string">"abcd"</span>)</span><br><span class="line">br := bufio.NewReader(r)</span><br><span class="line"><span class="keyword">byte</span>, err := br.ReadByte()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%q\n"</span>, <span class="keyword">byte</span>)</span><br><span class="line">fmt.Printf(<span class="string">"buffered = %d\n"</span>, br.Buffered())</span><br><span class="line">err = br.UnreadByte()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"buffered = %d\n"</span>, br.Buffered())</span><br><span class="line"><span class="keyword">byte</span>, err = br.ReadByte()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%q\n"</span>, <span class="keyword">byte</span>)</span><br><span class="line">fmt.Printf(<span class="string">"buffered = %d\n"</span>, br.Buffered())</span><br><span class="line"><span class="string">'a'</span></span><br><span class="line">buffered = <span class="number">3</span></span><br><span class="line">buffered = <span class="number">4</span></span><br><span class="line"><span class="string">'a'</span></span><br><span class="line">buffered = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="Read-Unread-Rune"><a href="#Read-Unread-Rune" class="headerlink" title="{Read, Unread}Rune"></a>{Read, Unread}Rune</h2><p>这两个方法的功能和前面方法的功能差不多, 但是用来处理 Unicode 字符(UTF-8 encoded)。</p>
<h2 id="ReadSlice"><a href="#ReadSlice" class="headerlink" title="ReadSlice"></a>ReadSlice</h2><p>函数返回在第一次出现传入字节前的字节:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadSlice</span><span class="params">(delim <span class="keyword">byte</span>)</span> <span class="params">(line []<span class="keyword">byte</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>示例:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := strings.NewReader(<span class="string">"abcdef|ghij"</span>)</span><br><span class="line">r := bufio.NewReader(s)</span><br><span class="line">token, err := r.ReadSlice(<span class="string">'|'</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Token: %q\n"</span>, token)</span><br><span class="line">Token: <span class="string">"abcdef|"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>重要：返回的切面指向内部缓冲区, 因此它可能在下一次读取操作期间被覆盖</p>
</blockquote>
<p>如果找不到分隔符，而且已经读到末尾(EOF)，将会返回 <code>io.EOF</code> error。 让我们将上面程序中的一行修改为如下代码:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := strings.NewReader(<span class="string">"abcdefghij"</span>)</span><br></pre></td></tr></table></figure>
<p>如果数据以 <code>panic: EOF</code> 结尾。 当分隔符找不到而且没有更多的数据可以放入缓冲区时函数将返回 <a href="https://golang.org/pkg/bufio/#pkg-variables" target="_blank" rel="noopener"><code>io.ErrBufferFull</code></a>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := strings.NewReader(strings.Repeat(<span class="string">"a"</span>, <span class="number">16</span>) + <span class="string">"|"</span>)</span><br><span class="line">r := bufio.NewReaderSize(s, <span class="number">16</span>)</span><br><span class="line">token, err := r.ReadSlice(<span class="string">'|'</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Token: %q\n"</span>, token)</span><br></pre></td></tr></table></figure>
<p>这一小段代码会出现错误:<code>panic: bufio: buffer full</code>。</p>
<h2 id="ReadBytes"><a href="#ReadBytes" class="headerlink" title="ReadBytes"></a>ReadBytes</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadBytes</span><span class="params">(delim <span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure>
<p>返回出现第一次分隔符前的所有数据组成的字节切片。 它和 <code>ReadSlice</code> 具有相同的签名，但是 <code>ReadSlice</code> 是一个低级别的函数，<code>ReadBytes</code> 的实现使用了 <code>ReadSlice</code>。 那么两者之间有什么不同呢? 在分隔符找不到的情况下，<code>ReadBytes</code> 可以多次调用 <code>ReadSlice</code>，而且可以累积返回的数据。 这意味着 <code>ReadBytes</code> 将不再受到 缓存大小的限制:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := strings.NewReader(strings.Repeat(<span class="string">"a"</span>, <span class="number">40</span>) + <span class="string">"|"</span>)</span><br><span class="line">r := bufio.NewReaderSize(s, <span class="number">16</span>)</span><br><span class="line">token, err := r.ReadBytes(<span class="string">'|'</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Token: %q\n"</span>, token)</span><br><span class="line">Token: <span class="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa|"</span></span><br></pre></td></tr></table></figure>
<p>另外该函数返回一个新的字节切片，所以没有数据会被将来的读取操作覆盖的风险。</p>
<h2 id="ReadString"><a href="#ReadString" class="headerlink" title="ReadString"></a>ReadString</h2><p>它是我们上面讨论的 <code>ReadBytes</code> 的简单封装:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadString</span><span class="params">(delim <span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    bytes, err := b.ReadBytes(delim)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(bytes), err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ReadLine"><a href="#ReadLine" class="headerlink" title="ReadLine"></a>ReadLine</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ReadLine() (line []<span class="keyword">byte</span>, isPrefix <span class="keyword">bool</span>, err error)</span><br></pre></td></tr></table></figure>
<p>内部使用 <code>ReadSlice</code> (<code>ReadSlice(&#39;\n&#39;)</code>)实现，同时从返回的切片中移除掉换行符(<code>\n</code> 或者 <code>\r\n</code>)。 此方法的签名不同于 <code>ReadBytes</code> 或者 <code>ReadSlice</code>，因为它包含 <code>isPrefix</code> 标志。 由于内部缓存无法存储更多的数据，当找不到分隔符时该标志为 true:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := strings.NewReader(strings.Repeat(<span class="string">"a"</span>, <span class="number">20</span>) + <span class="string">"\n"</span> + <span class="string">"b"</span>)</span><br><span class="line">r := bufio.NewReaderSize(s, <span class="number">16</span>)</span><br><span class="line">token, isPrefix, err := r.ReadLine()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Token: %q, prefix: %t\n"</span>, token, isPrefix)</span><br><span class="line">token, isPrefix, err = r.ReadLine()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Token: %q, prefix: %t\n"</span>, token, isPrefix)</span><br><span class="line">token, isPrefix, err = r.ReadLine()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Token: %q, prefix: %t\n"</span>, token, isPrefix)</span><br><span class="line">token, isPrefix, err = r.ReadLine()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">Token: <span class="string">"aaaaaaaaaaaaaaaa"</span>, prefix: <span class="literal">true</span></span><br><span class="line">Token: <span class="string">"aaaa"</span>, prefix: <span class="literal">false</span></span><br><span class="line">Token: <span class="string">"b"</span>, prefix: <span class="literal">false</span></span><br><span class="line"><span class="built_in">panic</span>: EOF</span><br></pre></td></tr></table></figure>
<p>如果最后一次返回的切片以换行符结尾，此方法将不会给出任何信息:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := strings.NewReader(<span class="string">"abc"</span>)</span><br><span class="line">r := bufio.NewReaderSize(s, <span class="number">16</span>)</span><br><span class="line">token, isPrefix, err := r.ReadLine()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Token: %q, prefix: %t\n"</span>, token, isPrefix)</span><br><span class="line">s = strings.NewReader(<span class="string">"abc\n"</span>)</span><br><span class="line">r.Reset(s)</span><br><span class="line">token, isPrefix, err = r.ReadLine()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Token: %q, prefix: %t\n"</span>, token, isPrefix)</span><br><span class="line">Token: <span class="string">"abc"</span>, prefix: <span class="literal">false</span></span><br><span class="line">Token: <span class="string">"abc"</span>, prefix: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="WriteTo"><a href="#WriteTo" class="headerlink" title="WriteTo"></a>WriteTo</h2><p><code>bufio.Reader</code> 实现了 <code>io.WriterTo</code> 接口:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> WriterTo <span class="keyword">interface</span> &#123;</span><br><span class="line">        WriteTo(w Writer) (n <span class="keyword">int64</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法允许我们传入一个实现了 <code>io.Writer</code> 的消费者。 从生产者读取的所有数据都将会被送到消费者。 下面通过练习来看看它是如何工作的:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> R <span class="keyword">struct</span> &#123;</span><br><span class="line">    n <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *R)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Read #%d\n"</span>, r.n)</span><br><span class="line">    <span class="keyword">if</span> r.n &gt;= <span class="number">10</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>, io.EOF</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">copy</span>(p, <span class="string">"abcd"</span>)</span><br><span class="line">    r.n += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := bufio.NewReaderSize(<span class="built_in">new</span>(R), <span class="number">16</span>)</span><br><span class="line">    n, err := r.WriteTo(ioutil.Discard)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Written bytes: %d\n"</span>, n)</span><br><span class="line">&#125;</span><br><span class="line">Read #<span class="number">0</span></span><br><span class="line">Read #<span class="number">1</span></span><br><span class="line">Read #<span class="number">2</span></span><br><span class="line">Read #<span class="number">3</span></span><br><span class="line">Read #<span class="number">4</span></span><br><span class="line">Read #<span class="number">5</span></span><br><span class="line">Read #<span class="number">6</span></span><br><span class="line">Read #<span class="number">7</span></span><br><span class="line">Read #<span class="number">8</span></span><br><span class="line">Read #<span class="number">9</span></span><br><span class="line">Read #<span class="number">10</span></span><br><span class="line">Written bytes: <span class="number">40</span></span><br></pre></td></tr></table></figure>
<h2 id="bufio-Scanner"><a href="#bufio-Scanner" class="headerlink" title="bufio.Scanner"></a>bufio.Scanner</h2><p><a href="https://medium.com/golangspec/in-depth-introduction-to-bufio-scanner-in-golang-55483bb689b4" target="_blank" rel="noopener">go语言中对bufio.Scanner的深层分析</a></p>
<h2 id="ReadBytes-‘-n’-ReadString-‘-n’-ReadLine-还是-Scanner"><a href="#ReadBytes-‘-n’-ReadString-‘-n’-ReadLine-还是-Scanner" class="headerlink" title="ReadBytes(‘\n’), ReadString(‘\n’), ReadLine 还是 Scanner?"></a>ReadBytes(‘\n’), ReadString(‘\n’), ReadLine 还是 Scanner?</h2><p>就像前面说的那样，<code>ReadString(&#39;\n&#39;)</code> 只是对于 <code>ReadBytes(</code>\n<code>)</code> 的简单封装。 所以让我们来讨论一下另外三者之间的不同之处吧。</p>
<ol>
<li><p>ReadBytes 不会自动处理 <code>\r\n</code> 序列:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := strings.NewReader(<span class="string">"a\r\nb"</span>)</span><br><span class="line">r := bufio.NewReader(s)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"> token, _, err := r.ReadLine()</span><br><span class="line"> <span class="keyword">if</span> <span class="built_in">len</span>(token) &gt; <span class="number">0</span> &#123;</span><br><span class="line">     fmt.Printf(<span class="string">"Token (ReadLine): %q\n"</span>, token)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">     <span class="keyword">break</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">s.Seek(<span class="number">0</span>, io.SeekStart)</span><br><span class="line">r.Reset(s)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"> token, err := r.ReadBytes(<span class="string">'\n'</span>)</span><br><span class="line"> fmt.Printf(<span class="string">"Token (ReadBytes): %q\n"</span>, token)</span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">     <span class="keyword">break</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">s.Seek(<span class="number">0</span>, io.SeekStart)</span><br><span class="line">scanner := bufio.NewScanner(s)</span><br><span class="line"><span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line"> fmt.Printf(<span class="string">"Token (Scanner): %q\n"</span>, scanner.Text())</span><br><span class="line">&#125;</span><br><span class="line">Token (ReadLine): <span class="string">"a"</span></span><br><span class="line">Token (ReadLine): <span class="string">"b"</span></span><br><span class="line">Token (ReadBytes): <span class="string">"a\r\n"</span></span><br><span class="line">Token (ReadBytes): <span class="string">"b"</span></span><br><span class="line">Token (Scanner): <span class="string">"a"</span></span><br><span class="line">Token (Scanner): <span class="string">"b"</span></span><br></pre></td></tr></table></figure>
<p><em>ReadBytes</em> 会将分隔符一起返回，所以需要额外的一些工作来重新处理数据(除非返回分隔符是有用的)。</p>
</li>
<li><p><em>ReadLine</em> 不会处理超出内部缓存的行:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := strings.NewReader(strings.Repeat(<span class="string">"a"</span>, <span class="number">20</span>) + <span class="string">"\n"</span>)</span><br><span class="line">r := bufio.NewReaderSize(s, <span class="number">16</span>)</span><br><span class="line">token, _, _ := r.ReadLine()</span><br><span class="line">fmt.Printf(<span class="string">"Token (ReadLine): \t%q\n"</span>, token)</span><br><span class="line">s.Seek(<span class="number">0</span>, io.SeekStart)</span><br><span class="line">r.Reset(s)</span><br><span class="line">token, _ = r.ReadBytes(<span class="string">'\n'</span>)</span><br><span class="line">fmt.Printf(<span class="string">"Token (ReadBytes): \t%q\n"</span>, token)</span><br><span class="line">s.Seek(<span class="number">0</span>, io.SeekStart)</span><br><span class="line">scanner := bufio.NewScanner(s)</span><br><span class="line">scanner.Scan()</span><br><span class="line">fmt.Printf(<span class="string">"Token (Scanner): \t%q\n"</span>, scanner.Text())</span><br><span class="line">Token (ReadLine):     <span class="string">"aaaaaaaaaaaaaaaa"</span></span><br><span class="line">Token (ReadBytes):     <span class="string">"aaaaaaaaaaaaaaaaaaaa\n"</span></span><br><span class="line">Token (Scanner):     <span class="string">"aaaaaaaaaaaaaaaaaaaa"</span></span><br></pre></td></tr></table></figure>
<p>为了取回流中剩余的数据，<em>ReadLine</em> 需要被调用两次。 被 Scanner 处理的最大 token 长度为 64<em>1024。 如果传入更长的 token，scanner 将无法工作。 当</em> ReadLine <em>被多次调用时可以处理任何长度的 token。 由于函数返回是否在缓存数据中找到分隔符的标志，但是这需要调用者进行处理。</em> ReadBytes* 则没有任何限制:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := strings.NewReader(strings.Repeat(<span class="string">"a"</span>, <span class="number">64</span>*<span class="number">1024</span>) + <span class="string">"\n"</span>)</span><br><span class="line">r := bufio.NewReader(s)</span><br><span class="line">token, _, err := r.ReadLine()</span><br><span class="line">fmt.Printf(<span class="string">"Token (ReadLine): %d\n"</span>, <span class="built_in">len</span>(token))</span><br><span class="line">fmt.Printf(<span class="string">"Error (ReadLine): %v\n"</span>, err)</span><br><span class="line">s.Seek(<span class="number">0</span>, io.SeekStart)</span><br><span class="line">r.Reset(s)</span><br><span class="line">token, err = r.ReadBytes(<span class="string">'\n'</span>)</span><br><span class="line">fmt.Printf(<span class="string">"Token (ReadBytes): %d\n"</span>, <span class="built_in">len</span>(token))</span><br><span class="line">fmt.Printf(<span class="string">"Error (ReadBytes): %v\n"</span>, err)</span><br><span class="line">s.Seek(<span class="number">0</span>, io.SeekStart)</span><br><span class="line">scanner := bufio.NewScanner(s)</span><br><span class="line">scanner.Scan()</span><br><span class="line">fmt.Printf(<span class="string">"Token (Scanner): %d\n"</span>, <span class="built_in">len</span>(scanner.Text()))</span><br><span class="line">fmt.Printf(<span class="string">"Error (Scanner): %v\n"</span>, scanner.Err())</span><br><span class="line">Token (ReadLine): <span class="number">4096</span></span><br><span class="line">Error (ReadLine): &lt;<span class="literal">nil</span>&gt;</span><br><span class="line">Token (ReadBytes): <span class="number">65537</span></span><br><span class="line">Error (ReadBytes): &lt;<span class="literal">nil</span>&gt;</span><br><span class="line">Token (Scanner): <span class="number">0</span></span><br><span class="line">Error (Scanner): bufio.Scanner: token too long</span><br></pre></td></tr></table></figure>
</li>
<li><p>就像上面那样，<em>Scanner</em> 具有非常简单的 API，对于普通的例子，它还提供了友好的抽象概念。</p>
</li>
</ol>
<h2 id="bufio-ReadWriter"><a href="#bufio-ReadWriter" class="headerlink" title="bufio.ReadWriter"></a>bufio.ReadWriter</h2><p>Go 的结构体中可以使用一种叫做内嵌的类型。 和常规的具有类型和名字的字段不同，我们可以仅仅使用类型(匿名字段)。 内嵌类型的方法或者字段如果不和其他的冲突的话，则可以使用一个简短的选择器来引用:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    t1 <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T1)</span> <span class="title">f1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"T1.f1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> T2 <span class="keyword">struct</span> &#123;</span><br><span class="line">    t2 <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T2)</span> <span class="title">f2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"T1.f2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> U <span class="keyword">struct</span> &#123;</span><br><span class="line">    *T1</span><br><span class="line">    *T2</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    u := U&#123;T1: &amp;T1&#123;<span class="string">"foo"</span>&#125;, T2: &amp;T2&#123;<span class="string">"bar"</span>&#125;&#125;</span><br><span class="line">    u.f1()</span><br><span class="line">    u.f2()</span><br><span class="line">    fmt.Println(u.t1)</span><br><span class="line">    fmt.Println(u.t2)</span><br><span class="line">&#125;</span><br><span class="line">T1.f1</span><br><span class="line">T1.f2</span><br><span class="line">foo</span><br><span class="line">bar</span><br></pre></td></tr></table></figure>
<p>我们可以简单的使用 <code>u.t1</code> 来代替 <code>u.T1.t1</code>。 包 <code>bufio</code> 使用内嵌的方式来定义 <em>ReadWriter</em>。 它由 <em>Reader</em> 和 <em>Writer</em> 构成:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">      *Reader</span><br><span class="line">      *Writer</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>让我们来看看它是如何使用的:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := strings.NewReader(<span class="string">"abcd"</span>)</span><br><span class="line">br := bufio.NewReader(s)</span><br><span class="line">w := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">bw := bufio.NewWriter(w)</span><br><span class="line">rw := bufio.NewReadWriter(br, bw)</span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">2</span>)</span><br><span class="line">_, err := rw.Read(buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%q\n"</span>, buf)</span><br><span class="line">buf = []<span class="keyword">byte</span>(<span class="string">"efgh"</span>)</span><br><span class="line">_, err = rw.Write(buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">err = rw.Flush()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(w.String())</span><br><span class="line"><span class="string">"ab"</span></span><br><span class="line">efgh</span><br></pre></td></tr></table></figure>
<p>由于 reader 和 writer 都具有方法 <em>Buffered</em>，所以若想获取缓存数据的量，<code>rw.Buffered()</code> 将无法工作，编译器会报错：<code>ambiguous selector rw.Buffered</code>。 但是类似 <code>rw.Reader.Buffered()</code> 的方式是可以的。</p>
<h2 id="bufio-standard-library"><a href="#bufio-standard-library" class="headerlink" title="bufio + standard library"></a>bufio + standard library</h2><p><em>bufio</em> 包被广泛使用在 I/O出现的标准库中，例如:</p>
<ul>
<li>archive/zip</li>
<li>compress/*</li>
<li>encoding/*</li>
<li>image/*</li>
<li>类似于 net/http 的TCP连接包装。 它还结合一些类似于 sync.Pool 的缓存框架来减少垃圾回收的压力</li>
</ul>
<p>原文链接：<a href="https://medium.com/golangspec/introduction-to-bufio-package-in-golang-ad7d1877f762" target="_blank" rel="noopener">https://medium.com/golangspec/introduction-to-bufio-package-in-golang-ad7d1877f762</a></p>
]]></content>
      <categories>
        <category>go</category>
        <category>bufio</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>bufio</tag>
      </tags>
  </entry>
  <entry>
    <title>go -- 标准库-- bytes.buffer</title>
    <url>/2018/03/02/go-%E6%A0%87%E5%87%86%E5%BA%93-bytes/</url>
    <content><![CDATA[<p>bytes.buffer是一个缓冲byte类型的缓冲器</p>
<p>1、使用bytes.NewBuffer创建：参数是[]byte的话，缓冲器里就是这个slice的内容；如果参数是nil的话，就是创建一个空的缓冲器。</p>
<p>2、bytes.NewBufferString创建</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   buf1 := bytes.NewBufferString(<span class="string">"hello"</span>)</span><br><span class="line">   buf2 := bytes.NewBuffer([]<span class="keyword">byte</span>(<span class="string">"hello"</span>))</span><br><span class="line">   buf3 := bytes.NewBuffer([]<span class="keyword">byte</span>&#123;<span class="string">'h'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>&#125;)</span><br><span class="line">   以上三者等效,输出<span class="comment">//hello</span></span><br><span class="line">   buf4 := bytes.NewBufferString(<span class="string">""</span>)</span><br><span class="line">   buf5 := bytes.NewBuffer([]<span class="keyword">byte</span>&#123;&#125;)</span><br><span class="line">   以上两者等效,输出<span class="comment">//""</span></span><br><span class="line">   fmt.Println(buf1.String(),buf2.String(),buf3.String(),buf4,buf5,<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="二、写入到缓冲器"><a href="#二、写入到缓冲器" class="headerlink" title="二、写入到缓冲器"></a>二、写入到缓冲器</h3><p>如果buffer在new的时候是空的，可以用Write在尾部写入</p>
<p>1、Write方法，将一个byte类型的slice放到缓冲器的尾部</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//func (b *Buffer) Write(p []byte) (n int,err error)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   s := []<span class="keyword">byte</span>(<span class="string">" world"</span>)</span><br><span class="line">   buf := bytes.NewBufferString(<span class="string">"hello"</span>) </span><br><span class="line">   fmt.Println(buf.String())    <span class="comment">//hello</span></span><br><span class="line">   buf.Write(s)                 <span class="comment">//将s这个slice添加到buf的尾部</span></span><br><span class="line">   fmt.Println(buf.String())   <span class="comment">//hello world</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、WriteString方法，把一个字符串放到缓冲器的尾部</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//func (b *Buffer) WriteString(s string)(n int,err error)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   s := <span class="string">" world"</span></span><br><span class="line">   buf := bytes.NewBufferString(<span class="string">"hello"</span>)</span><br><span class="line">   fmt.Println(buf.String())    <span class="comment">//hello</span></span><br><span class="line">   buf.WriteString(s)           <span class="comment">//将string写入到buf的尾部</span></span><br><span class="line">   fmt.Println(buf.String())    <span class="comment">//hello world</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、WriteByte方法，将一个byte类型的数据放到缓冲器的尾部</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//func (b *Buffer) WriteByte(c byte) error</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> s <span class="keyword">byte</span> = <span class="string">'?'</span></span><br><span class="line">   buf := bytes.NewBufferString(<span class="string">"hello"</span>) </span><br><span class="line">   fmt.Println(buf.String()) <span class="comment">//把buf的内容转换为string，hello</span></span><br><span class="line">   buf.WriteByte(s)         <span class="comment">//将s写到buf的尾部</span></span><br><span class="line">   fmt.Println(buf.String()) <span class="comment">//hello？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、WriteRune方法，将一个rune类型的数据放到缓冲器的尾部</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func (b *Buffer) WriteRune(r Rune) (n int,err error)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> s <span class="keyword">rune</span> = <span class="string">'好'</span></span><br><span class="line">   buf := bytes.NewBufferString(<span class="string">"hello"</span>)</span><br><span class="line">   fmt.Println(buf.String()) <span class="comment">//hello</span></span><br><span class="line">   buf.WriteRune(s)   </span><br><span class="line">   fmt.Println(buf.String()) <span class="comment">//hello好</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、从缓冲器写出"><a href="#三、从缓冲器写出" class="headerlink" title="三、从缓冲器写出"></a>三、从缓冲器写出</h3><p>WriteTo方法，将一个缓冲器的数据写到w里，w是实现io.Writer的，比如os.File</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   file,_ := os.Create(<span class="string">"text.txt"</span>)</span><br><span class="line">   buf := bytes.NewBufferString(<span class="string">"hello world"</span>)</span><br><span class="line">   buf.WriteTo(file)</span><br><span class="line">   <span class="comment">//或者使用写入，fmt.Fprintf(file,buf.String())</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、读出缓冲器"><a href="#四、读出缓冲器" class="headerlink" title="四、读出缓冲器"></a>四、读出缓冲器</h3><p>1、Read方法，给Read方法一个容器，读完后p就满了，缓冲器相应的减少。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func (b *Buffer) Read(p []byte)(n int,err error)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   s1 := []<span class="keyword">byte</span>(<span class="string">"hello"</span>)</span><br><span class="line">   buff := bytes.NewBuffer(s1)</span><br><span class="line">   s2 := []<span class="keyword">byte</span>(<span class="string">" world"</span>)</span><br><span class="line">   buff.Write(s2)</span><br><span class="line">   fmt.Println(buff.String()) <span class="comment">//hello world</span></span><br><span class="line">   </span><br><span class="line">   s3 := <span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">3</span>)</span><br><span class="line">   buff.Read(s3)     <span class="comment">//把buff的内容读入到s3，s3的容量为3，读了3个过来</span></span><br><span class="line">   fmt.Println(buff.String()) <span class="comment">//lo world</span></span><br><span class="line">   fmt.Println(<span class="keyword">string</span>(s3))   <span class="comment">//hel</span></span><br><span class="line">   buff.Read(s3) <span class="comment">//继续读入3个，原来的被覆盖</span></span><br><span class="line">   </span><br><span class="line">   fmt.Println(buff.String())     <span class="comment">//world</span></span><br><span class="line">   fmt.Println(<span class="keyword">string</span>(s3))    <span class="comment">//"lo "</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、ReadByte方法，返回缓冲器头部的第一个byte，缓冲器头部第一个byte取出</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//func (b *Buffer) ReadByte() (c byte,err error)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   buf := bytes.NewBufferString(<span class="string">"hello"</span>)</span><br><span class="line">   fmt.Println(buf.String())</span><br><span class="line">   b,_ := buf.ReadByte()   <span class="comment">//取出第一个byte，赋值给b</span></span><br><span class="line">   fmt.Println(buf.String()) <span class="comment">//ello</span></span><br><span class="line">   fmt.Println(<span class="keyword">string</span>(b))   <span class="comment">//h</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、ReadRune方法，返回缓冲器头部的第一个rune</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func (b *Buffer) ReadRune() (r rune,size int,err error)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   buf := bytes.NewBufferString(<span class="string">"你好smith"</span>)</span><br><span class="line">   fmt.Println(buf.String())</span><br><span class="line">   b,n,_ := buf.ReadRune()  <span class="comment">//取出第一个rune</span></span><br><span class="line">   fmt.Println(buf.String()) <span class="comment">//好smith</span></span><br><span class="line">   fmt.Println(<span class="keyword">string</span>(b))   <span class="comment">//你</span></span><br><span class="line">   fmt.Println(n)   <span class="comment">//3,"你“作为utf8存储占3个byte</span></span><br><span class="line"></span><br><span class="line">   b,n,_ = buf.ReadRune()  <span class="comment">//再取出一个rune</span></span><br><span class="line">   fmt.Println(buf.String()) <span class="comment">//smith</span></span><br><span class="line">   fmt.Println(<span class="keyword">string</span>(b))  <span class="comment">//好</span></span><br><span class="line">   fmt.Println(n)   <span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、ReadBytes方法，需要一个byte作为分隔符，读的时候从缓冲器里找出第一个出现的分隔符，缓冲器头部开始到分隔符之间的byte返回。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//func (b *Buffer) ReadBytes(delim byte) (line []byte,err error)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> d <span class="keyword">byte</span> = <span class="string">'e'</span>  <span class="comment">//分隔符</span></span><br><span class="line">   buf := bytes.NewBufferString(<span class="string">"你好esmieth"</span>)</span><br><span class="line">   fmt.Println(buf.String()) <span class="comment">//你好esmieth</span></span><br><span class="line">   b,_ := buf.ReadBytes(d)  <span class="comment">//读到分隔符，并返回给b</span></span><br><span class="line">   fmt.Println(buf.String())  <span class="comment">//smieth</span></span><br><span class="line">   fmt.Println(<span class="keyword">string</span>(b)) <span class="comment">//你好e</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、ReadString方法，和ReadBytes方法一样</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//func (b *Buffer) ReadString(delim byte) (line string,err error)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> d <span class="keyword">byte</span> = <span class="string">'e'</span></span><br><span class="line">   buf := bytes.NewBufferString(<span class="string">"你好esmieth"</span>)</span><br><span class="line">   fmt.Println(buf.String())  <span class="comment">//你好esmieth</span></span><br><span class="line">   b,_ := buf.ReadString(d)   <span class="comment">//读取到分隔符，并返回给b</span></span><br><span class="line">   fmt.Println(buf.String()) <span class="comment">//smieth</span></span><br><span class="line">   fmt.Println(<span class="keyword">string</span>(b)) <span class="comment">//你好e</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="五、读入缓冲器"><a href="#五、读入缓冲器" class="headerlink" title="五、读入缓冲器"></a>五、读入缓冲器</h3><p>ReadFrom方法，从一个实现io.Reader接口的r，把r的内容读到缓冲器里，n返回读的数量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//func (b *Buffer) ReadFrom(r io.Reader) (n int64,err error)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   file, _ := os.Open(<span class="string">"text.txt"</span>)</span><br><span class="line">   buf := bytes.NewBufferString(<span class="string">"bob "</span>)</span><br><span class="line">   buf.ReadFrom(file)</span><br><span class="line">   fmt.Println(buf.String()) <span class="comment">//bob hello world</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="六、从缓冲器取出"><a href="#六、从缓冲器取出" class="headerlink" title="六、从缓冲器取出"></a>六、从缓冲器取出</h3><p>Next方法，返回前n个byte（slice），原缓冲器变小</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//func (b *Buffer) Next(n int) []byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   buf := bytes.NewBufferString(<span class="string">"hello world"</span>)</span><br><span class="line">   fmt.Println(buf.String())</span><br><span class="line">   b := buf.Next(<span class="number">2</span>)  <span class="comment">//取前2个</span></span><br><span class="line">   fmt.Println(buf.String()) <span class="comment">//llo world</span></span><br><span class="line">   fmt.Println(<span class="keyword">string</span>(b)) <span class="comment">//he</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
        <category>bytes</category>
        <category>buffer</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>bytes</tag>
        <tag>buffer</tag>
      </tags>
  </entry>
  <entry>
    <title>new和make的区别</title>
    <url>/2018/07/21/go-new%E5%92%8Cmake%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h4 id="new函数"><a href="#new函数" class="headerlink" title="new函数"></a>new函数</h4><p>new函数的作用：</p>
<ul>
<li>分配内存</li>
<li>设置零值</li>
<li>返回指针<a id="more"></a>
例如：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Students <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// new 一个内建类型</span></span><br><span class="line">	num := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">	fmt.Println(*num) <span class="comment">// 打印零值：0</span></span><br><span class="line">	<span class="comment">// new 一个定义类型</span></span><br><span class="line">	stu := <span class="built_in">new</span>(Students)</span><br><span class="line">	stu.name = <span class="string">"TOM"</span></span><br><span class="line">	stu.age = <span class="number">19</span></span><br><span class="line">	fmt.Println(*stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="make-函数"><a href="#make-函数" class="headerlink" title="make 函数"></a>make 函数</h4><p>make函数：</p>
<ul>
<li>为slice，map，chan类型分配内存，初始化对象</li>
<li>返回类型的本身而不是指针，依赖于具体传入的类型，（slice，map，chan 本身就是引用类型，不必返回他们的指针）</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//切片</span></span><br><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">10</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 字典</span></span><br><span class="line">b := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通道</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>new</tag>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title>go -- 正则表达式</title>
    <url>/2019/11/12/go-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="正则的使用"><a href="#正则的使用" class="headerlink" title="正则的使用"></a>正则的使用</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断在 b（s、r）中能否找到 pattern 所匹配的字符串 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Match</span><span class="params">(pattern <span class="keyword">string</span>, b []<span class="keyword">byte</span>)</span> <span class="params">(matched <span class="keyword">bool</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MatchString</span><span class="params">(pattern <span class="keyword">string</span>, s <span class="keyword">string</span>)</span> <span class="params">(matched <span class="keyword">bool</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MatchReader</span><span class="params">(pattern <span class="keyword">string</span>, r io.RuneReader)</span> <span class="params">(matched <span class="keyword">bool</span>, err error)</span></span></span><br><span class="line"><span class="comment">// 将 s 中的正则表达式元字符转义成普通字符。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuoteMeta</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Regexp 代表一个编译好的正则表达式，我们这里称之为正则对象。正则对象可以</span></span><br><span class="line"><span class="comment">// 在文本中查找匹配的内容。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Regexp 可以安全的在多个例程中并行使用。</span></span><br><span class="line"><span class="keyword">type</span> Regexp <span class="keyword">struct</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.编译</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将正则表达式编译成一个正则对象（使用 PERL 语法）。</span></span><br><span class="line"><span class="comment">// 该正则对象会采用“leftmost-first”模式。选择第一个匹配结果。</span></span><br><span class="line"><span class="comment">// 如果正则表达式语法错误，则返回错误信息。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compile</span><span class="params">(expr <span class="keyword">string</span>)</span> <span class="params">(*Regexp, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将正则表达式编译成一个正则对象（正则语法限制在 POSIX ERE 范围内）。</span></span><br><span class="line"><span class="comment">// 该正则对象会采用“leftmost-longest”模式。选择最长的匹配结果。</span></span><br><span class="line"><span class="comment">// POSIX 语法不支持 Perl 的语法格式：\d、\D、\s、\S、\w、\W</span></span><br><span class="line"><span class="comment">// 如果正则表达式语法错误，则返回错误信息。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompilePOSIX</span><span class="params">(expr <span class="keyword">string</span>)</span> <span class="params">(*Regexp, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能同上，但会在解析失败时 panic</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MustCompile</span><span class="params">(str <span class="keyword">string</span>)</span> *<span class="title">Regexp</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MustCompilePOSIX</span><span class="params">(str <span class="keyword">string</span>)</span> *<span class="title">Regexp</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 让正则表达式在之后的搜索中都采用“leftmost-longest”模式。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">Longest</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回编译时使用的正则表达式字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回正则表达式中分组的数量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">NumSubexp</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回正则表达式中分组的名字</span></span><br><span class="line"><span class="comment">// 第 0 个元素表示整个正则表达式的名字，永远是空字符串。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">SubexpNames</span><span class="params">()</span> []<span class="title">string</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回正则表达式必须匹配到的字面前缀（不包含可变部分）。</span></span><br><span class="line"><span class="comment">// 如果整个正则表达式都是字面值，则 complete 返回 true。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">LiteralPrefix</span><span class="params">()</span> <span class="params">(prefix <span class="keyword">string</span>, complete <span class="keyword">bool</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.判断</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断在 b（s、r）中能否找到匹配的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">Match</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">MatchString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">MatchReader</span><span class="params">(r io.RuneReader)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.查找</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回第一个匹配到的结果（结果以 b 的切片形式返回）。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">Find</span><span class="params">(b []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回第一个匹配到的结果及其分组内容（结果以 b 的切片形式返回）。</span></span><br><span class="line"><span class="comment">// 返回值中的第 0 个元素是整个正则表达式的匹配结果，后续元素是各个分组的</span></span><br><span class="line"><span class="comment">// 匹配内容，分组顺序按照“(”的出现次序而定。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">FindSubmatch</span><span class="params">(b []<span class="keyword">byte</span>)</span> [][]<span class="title">byte</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能同 Find，只不过返回的是匹配结果的首尾下标，通过这些下标可以生成切片。</span></span><br><span class="line"><span class="comment">// loc[0] 是结果切片的起始下标，loc[1] 是结果切片的结束下标。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">FindIndex</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(loc []<span class="keyword">int</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能同 FindSubmatch，只不过返回的是匹配结果的首尾下标，通过这些下标可以生成切片。</span></span><br><span class="line"><span class="comment">// loc[0] 是结果切片的起始下标，loc[1] 是结果切片的结束下标。</span></span><br><span class="line"><span class="comment">// loc[2] 是分组1切片的起始下标，loc[3] 是分组1切片的结束下标。</span></span><br><span class="line"><span class="comment">// loc[4] 是分组2切片的起始下标，loc[5] 是分组2切片的结束下标。</span></span><br><span class="line"><span class="comment">// 以此类推</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">FindSubmatchIndex</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(loc []<span class="keyword">int</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能同上，只不过返回多个匹配的结果，而不只是第一个。</span></span><br><span class="line"><span class="comment">// n 是查找次数，负数表示不限次数。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">FindAll</span><span class="params">(b []<span class="keyword">byte</span>, n <span class="keyword">int</span>)</span> [][]<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">FindAllSubmatch</span><span class="params">(b []<span class="keyword">byte</span>, n <span class="keyword">int</span>)</span> [][][]<span class="title">byte</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">FindAllIndex</span><span class="params">(b []<span class="keyword">byte</span>, n <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">FindAllSubmatchIndex</span><span class="params">(b []<span class="keyword">byte</span>, n <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能同上，只不过在字符串中查找</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">FindString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">FindStringSubmatch</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">string</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">FindStringIndex</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(loc []<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">FindStringSubmatchIndex</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">FindAllString</span><span class="params">(s <span class="keyword">string</span>, n <span class="keyword">int</span>)</span> []<span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">FindAllStringSubmatch</span><span class="params">(s <span class="keyword">string</span>, n <span class="keyword">int</span>)</span> [][]<span class="title">string</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">FindAllStringIndex</span><span class="params">(s <span class="keyword">string</span>, n <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">FindAllStringSubmatchIndex</span><span class="params">(s <span class="keyword">string</span>, n <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能同上，只不过在 io.RuneReader 中查找。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">FindReaderIndex</span><span class="params">(r io.RuneReader)</span> <span class="params">(loc []<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">FindReaderSubmatchIndex</span><span class="params">(r io.RuneReader)</span> []<span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换（不会修改参数，结果是参数的副本）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 src 中匹配的内容替换为 repl（repl 中可以使用 $1 $name 等分组引用符）。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">ReplaceAll</span><span class="params">(src, repl []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 src 中匹配的内容经过 repl 函数处理后替换回去。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">ReplaceAllFunc</span><span class="params">(src []<span class="keyword">byte</span>, repl <span class="keyword">func</span>([]<span class="keyword">byte</span>)</span> []<span class="title">byte</span>) []<span class="title">byte</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 src 中匹配的内容替换为 repl（repl 为字面值，不解析其中的 $1 $name 等）。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">ReplaceAllLiteral</span><span class="params">(src, repl []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能同上，只不过在字符串中查找。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">ReplaceAllString</span><span class="params">(src, repl <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">ReplaceAllStringFunc</span><span class="params">(src <span class="keyword">string</span>, repl <span class="keyword">func</span>(<span class="keyword">string</span>)</span> <span class="title">string</span>) <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">ReplaceAllLiteralString</span><span class="params">(src, repl <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Expand 要配合 FindSubmatchIndex 一起使用。FindSubmatchIndex 在 src 中进行</span></span><br><span class="line"><span class="comment">// 查找，将结果存入 match 中。这样就可以通过 src 和 match 得到匹配的字符串。</span></span><br><span class="line"><span class="comment">// template 是替换内容，可以使用分组引用符 $1、$2、$name 等。Expane 将其中的分</span></span><br><span class="line"><span class="comment">// 组引用符替换为前面匹配到的字符串。然后追加到 dst 的尾部（dst 可以为空）。</span></span><br><span class="line"><span class="comment">// 说白了 Expand 就是一次替换过程，只不过需要 FindSubmatchIndex 的配合。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">Expand</span><span class="params">(dst []<span class="keyword">byte</span>, template []<span class="keyword">byte</span>, src []<span class="keyword">byte</span>, match []<span class="keyword">int</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能同上，参数为字符串。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">ExpandString</span><span class="params">(dst []<span class="keyword">byte</span>, template <span class="keyword">string</span>, src <span class="keyword">string</span>, match []<span class="keyword">int</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其它</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以 s 中的匹配结果作为分割符将 s 分割成字符串列表。</span></span><br><span class="line"><span class="comment">// n 是分割次数，负数表示不限次数。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">Split</span><span class="params">(s <span class="keyword">string</span>, n <span class="keyword">int</span>)</span> []<span class="title">string</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将当前正则对象复制一份。在多例程中使用同一正则对象时，给每个例程分配一个</span></span><br><span class="line"><span class="comment">// 正则对象的副本，可以避免多例程对单个正则对象的争夺锁定。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *Regexp)</span> <span class="title">Copy</span><span class="params">()</span> *<span class="title">Regexp</span></span></span><br></pre></td></tr></table></figure>
<p>示例代码：</p>
<blockquote>
<p>调用方法 match := re.FindString(text)<br>查找一个 match := re.FindAllString(text,-1) -1代表查找所有</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"regexp"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> text = <span class="string">"My email is helloworld123@163.com@haha.com"</span></span><br><span class="line">	<span class="comment">//re, err := regexp.Compile("helloworld123@163.com")</span></span><br><span class="line">	re := regexp.MustCompile(<span class="string">`[a-zA-Z0-9]+@[a-zA-Z0-9.]+\.[a-zA-Z0-9]+`</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//if err != nil &#123;</span></span><br><span class="line">	<span class="comment">//	fmt.Println(err)</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	match := re.FindString(text)</span><br><span class="line">	fmt.Println(match)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取所有满足正则表达式的文本<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"regexp"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> text = <span class="string">`</span></span><br><span class="line"><span class="string">My email is helloworld123@163.com@haha.com</span></span><br><span class="line"><span class="string">email is wangergou@sina.com</span></span><br><span class="line"><span class="string">email is kongyixueyuan@cldy.org.cn</span></span><br><span class="line"><span class="string">`</span>	<span class="comment">//re, err := regexp.Compile("helloworld123@163.com")</span></span><br><span class="line">	re := regexp.MustCompile(<span class="string">`[a-zA-Z0-9]+@[a-zA-Z0-9.]+\.[a-zA-Z0-9]+`</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//if err != nil &#123;</span></span><br><span class="line">	<span class="comment">//	fmt.Println(err)</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	match := re.FindAllString(text, <span class="number">-1</span>)</span><br><span class="line">	fmt.Println(match)</span><br><span class="line">&#125;</span><br><span class="line">注意：<span class="string">``</span>使用这种定义方式，\等可以不会转义。使用<span class="string">""</span>，会被<span class="keyword">go</span>语言转义。</span><br><span class="line"><span class="string">``</span>[a-zA-Z0<span class="number">-9</span>]+@[a-zA-Z0<span class="number">-9.</span>]+\.[a-zA-Z0<span class="number">-9</span>]+<span class="string">``</span></span><br><span class="line"><span class="string">"`[a-zA-Z0-9]+@[a-zA-Z0-9.]+\\.[a-zA-Z0-9]+`"</span></span><br></pre></td></tr></table></figure></p>
<h4 id="一般符号和特殊符号"><a href="#一般符号和特殊符号" class="headerlink" title="一般符号和特殊符号"></a>一般符号和特殊符号</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">正则的规则：</span><br><span class="line">一.一般的符号</span><br><span class="line">  1..点代表1个任意字符，除\n外</span><br><span class="line">  2.[],匹配[]中任意字符都可以</span><br><span class="line">  3.[abc],匹配a或b或c。1位</span><br><span class="line">  4.[a-z],匹配任意一位的小写字母</span><br><span class="line">  5.[^abc],除abc外的任意一位字符</span><br><span class="line"></span><br><span class="line">二、特殊的符号</span><br><span class="line">    1.\d,代表0-9数字，同[0-9]</span><br><span class="line">    2.\D,与\d相反，同[^0-9]</span><br><span class="line">    3.\w,匹配一个单词字符：a-zA-Z0-9_</span><br><span class="line">    4.\W,与\w相反，非[a-zA-Z0-9_]</span><br><span class="line">    5.\s,匹配空白字符。即空格，tab键,\n,\r等</span><br><span class="line">    6.\b,单词边界</span><br></pre></td></tr></table></figure>
<p>示例代码：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"regexp"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//符号：一般符号和特殊符号</span></span><br><span class="line">	<span class="comment">// 1..代表匹配任意字符</span></span><br><span class="line">	b1 := regexp.MustCompile(<span class="string">`123.`</span>).MatchString(<span class="string">`123*emeda`</span>)</span><br><span class="line">	fmt.Println(b1)</span><br><span class="line"></span><br><span class="line">	b2 := regexp.MustCompile(<span class="string">`123....`</span>).MatchString(<span class="string">`123memeda`</span>)</span><br><span class="line">	fmt.Println(b2)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.[],匹配[]里的任意一个</span></span><br><span class="line">	b3 := regexp.MustCompile(<span class="string">`[abc]`</span>).MatchString(<span class="string">`saaa`</span>) <span class="comment">// 或a或b或c开头即可。</span></span><br><span class="line">	fmt.Println(b3)</span><br><span class="line">	b4 := regexp.MustCompile(<span class="string">`a[abc]`</span>).MatchString(<span class="string">`as`</span>) <span class="comment">//第一个字母必须是a，第二个字符a,或b或c</span></span><br><span class="line">	fmt.Println(b4)</span><br><span class="line"></span><br><span class="line">	b5 := regexp.MustCompile(<span class="string">`[a-z]`</span>).MatchString(<span class="string">`A23abc`</span>) <span class="comment">//必须是小写字母开头</span></span><br><span class="line">	fmt.Println(b5)</span><br><span class="line"></span><br><span class="line">	b6 := regexp.MustCompile(<span class="string">`[a-zA-Z][a-z]c`</span>).MatchString(<span class="string">`Abcabc`</span>) <span class="comment">//字母</span></span><br><span class="line">	fmt.Println(b6)</span><br><span class="line"></span><br><span class="line">	b7 := regexp.MustCompile(<span class="string">`[0-9]`</span>).MatchString(<span class="string">`110abc`</span>) <span class="comment">//数字</span></span><br><span class="line">	fmt.Println(b7)</span><br><span class="line"></span><br><span class="line">	b8 := regexp.MustCompile(<span class="string">`[^abc]`</span>).MatchString(<span class="string">`*&amp;%ABC123abc`</span>) <span class="comment">// 非abc开头即可</span></span><br><span class="line">	fmt.Println(b8)</span><br><span class="line"></span><br><span class="line">	b9 := regexp.MustCompile(<span class="string">`[[^a-z]`</span>).MatchString(<span class="string">`memeda`</span>) <span class="comment">//</span></span><br><span class="line">	fmt.Println(b9)</span><br><span class="line"></span><br><span class="line">	b10 := regexp.MustCompile(<span class="string">`1[^2345]`</span>).MatchString(<span class="string">`1a6`</span>) <span class="comment">//</span></span><br><span class="line">	fmt.Println(b10)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3.特殊符号</span></span><br><span class="line">	b11 := regexp.MustCompile(<span class="string">`^\d`</span>).MatchString(<span class="string">`a123`</span>) <span class="comment">//[0-9]</span></span><br><span class="line">	<span class="comment">//如果是""，\需要转义，``不需要转义</span></span><br><span class="line">	fmt.Println(b11) <span class="comment">//此处为true，是因为只要匹配到一个0-9的数字就可以，如果想以数字开头，可以在正则表达式前加^：`^\d`</span></span><br><span class="line"></span><br><span class="line">	b12 := regexp.MustCompile(<span class="string">`\d\d`</span>).MatchString(<span class="string">`1a2bc`</span>) <span class="comment">//[0-9]</span></span><br><span class="line">	fmt.Println(b12)</span><br><span class="line"></span><br><span class="line">	b13 := regexp.MustCompile(<span class="string">`\D`</span>).MatchString(<span class="string">`*123abc`</span>) <span class="comment">//</span></span><br><span class="line">	fmt.Println(b13)</span><br><span class="line"></span><br><span class="line">	b14 := regexp.MustCompile(<span class="string">`^\w\w`</span>).MatchString(<span class="string">`+-memeda`</span>) <span class="comment">//\w：[a-zA-Z0-9_] ，以\w\w开头</span></span><br><span class="line">	fmt.Println(b14)</span><br><span class="line"></span><br><span class="line">	b15 := regexp.MustCompile(<span class="string">`\d\w..`</span>).MatchString(<span class="string">`123memeda`</span>) <span class="comment">//[0-9][a-zA-Z0-9_]任意字符任意字符</span></span><br><span class="line">	fmt.Println(b15)</span><br><span class="line"></span><br><span class="line">	b16 := regexp.MustCompile(<span class="string">`\W`</span>).MatchString(<span class="string">`\nmemeda`</span>) <span class="comment">//</span></span><br><span class="line">	fmt.Println(b16)</span><br><span class="line"></span><br><span class="line">	b17 := regexp.MustCompile(<span class="string">`\w\W`</span>).MatchString(<span class="string">`a*b = 20`</span>) <span class="comment">//</span></span><br><span class="line">	fmt.Println(b17)</span><br><span class="line"></span><br><span class="line">	b18 := regexp.MustCompile(<span class="string">`a[b-d]\w\d\W`</span>).MatchString(<span class="string">`abc1\tdefg`</span>) <span class="comment">//</span></span><br><span class="line">	fmt.Println(b18)</span><br><span class="line">	b19 := regexp.MustCompile(<span class="string">`a\s`</span>).MatchString(<span class="string">`a bc`</span>) <span class="comment">//匹配空白字符。即空格</span></span><br><span class="line">	fmt.Println(b19)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="三、数量词"><a href="#三、数量词" class="headerlink" title="三、数量词"></a>三、数量词</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.*，出现的次数是0次或多次</span><br><span class="line">2.+,出现的次数是1次或多次</span><br><span class="line">3.?,出现的次数是0次或1次</span><br><span class="line">4.&#123;M&#125;，出现的次数刚好是m次</span><br><span class="line">5.&#123;M,&#125;,至少M次</span><br><span class="line">6.&#123;M,N&#125;,至少m次，至多n次</span><br></pre></td></tr></table></figure>
<p>示例代码：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"regexp"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 数量词</span></span><br><span class="line"></span><br><span class="line">	b1 := regexp.MustCompile(<span class="string">`\d*`</span>).MatchString(<span class="string">`123`</span>)</span><br><span class="line">	fmt.Println(b1)</span><br><span class="line"></span><br><span class="line">	b2 := regexp.MustCompile(<span class="string">`\d*`</span>).MatchString(<span class="string">`abc123`</span>)</span><br><span class="line">	fmt.Println(b2)</span><br><span class="line"></span><br><span class="line">	b3 := regexp.MustCompile(<span class="string">`\d*`</span>).MatchString(<span class="string">``</span>)</span><br><span class="line">	fmt.Println(b3)</span><br><span class="line"></span><br><span class="line">	b4 := regexp.MustCompile(<span class="string">`a[b-f]*\d\d[xy]*`</span>).MatchString(<span class="string">`abbbb123x`</span>) <span class="comment">//至少0位，意味着可以没有</span></span><br><span class="line">	fmt.Println(b4)</span><br><span class="line"></span><br><span class="line">	b5 := regexp.MustCompile(<span class="string">`a[b-f]*\d\d[xy]*`</span>).MatchString(<span class="string">`a12xxyxx3x`</span>)</span><br><span class="line">	fmt.Println(b5)</span><br><span class="line"></span><br><span class="line">	b6 := regexp.MustCompile(<span class="string">`\d+abc`</span>).MatchString(<span class="string">`abcmemeda`</span>) <span class="comment">//+至少一位</span></span><br><span class="line">	fmt.Println(b6)</span><br><span class="line"></span><br><span class="line">	b7 := regexp.MustCompile(<span class="string">`\d+.*\w+`</span>).MatchString(<span class="string">`1234\ncd`</span>) <span class="comment">//</span></span><br><span class="line">	fmt.Println(b7)</span><br><span class="line"></span><br><span class="line">	b8 := regexp.MustCompile(<span class="string">`\d?[a-z]+`</span>).MatchString(<span class="string">`123abc`</span>) <span class="comment">//</span></span><br><span class="line">	fmt.Println(b8)</span><br><span class="line"></span><br><span class="line">	b9 := regexp.MustCompile(<span class="string">`\d?\w+`</span>).MatchString(<span class="string">`123abc`</span>) <span class="comment">//</span></span><br><span class="line">	fmt.Println(b9)</span><br><span class="line"></span><br><span class="line">	b10 := regexp.MustCompile(<span class="string">`\d&#123;4&#125;[a-z]+`</span>).MatchString(<span class="string">`1234abcd`</span>) <span class="comment">//\d刚好4次</span></span><br><span class="line">	fmt.Println(b10)</span><br><span class="line"></span><br><span class="line">	b11 := regexp.MustCompile(<span class="string">`\d&#123;4,&#125;[a-z]+`</span>).MatchString(<span class="string">`12345abcd`</span>) <span class="comment">//\d至少4次</span></span><br><span class="line">	fmt.Println(b11)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// +--&gt;1次或多次，至少1次&#123;1,&#125;</span></span><br><span class="line"></span><br><span class="line">	b12 := regexp.MustCompile(<span class="string">`\d&#123;4,6&#125;[a-z]+`</span>).MatchString(<span class="string">`1234567abcd`</span>) <span class="comment">//</span></span><br><span class="line">	fmt.Println(b12)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ?--&gt;0次或1次，&#123;0,1&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.匹配手机号码：</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	   13012345678, 131xxxxxxxx,132xxxxxxxx,133xxxxxxxx,134xxxxxxxx,135xxxxxxxx,136xxxxxxxx,137xxxxxxxx,138,139</span></span><br><span class="line"><span class="comment">	   # 第一位：1，第二位：34578，第三位：0-9   11位。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	b13 := regexp.MustCompile(<span class="string">`1[34578]\d&#123;9&#125;`</span>).MatchString(<span class="string">`13212344321`</span>)</span><br><span class="line">	fmt.Println(b13)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.验证QQ号：第一位非0，长度：5位-11位。</span></span><br><span class="line">	<span class="comment">//441883704</span></span><br><span class="line"></span><br><span class="line">	b14 := regexp.MustCompile(<span class="string">`[1-9]\d&#123;4,10&#125;`</span>).MatchString(<span class="string">`44188370445`</span>)</span><br><span class="line">	fmt.Println(b14)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	   练习1：日期：2017-11-29</span></span><br><span class="line"><span class="comment">	       年份是4位数字，月份是1-2位数字，日期1-2位数字</span></span><br><span class="line"><span class="comment">	   练习2：邮箱：163.com，qq.com?</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	b15 := regexp.MustCompile(<span class="string">`\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;`</span>).MatchString(<span class="string">`2018-12-25`</span>)</span><br><span class="line">	fmt.Println(b15)</span><br><span class="line"></span><br><span class="line">	b16 := regexp.MustCompile(<span class="string">`[1-9]\d&#123;17&#125;`</span>).MatchString(<span class="string">`231412198807123214`</span>)</span><br><span class="line">	fmt.Println(b16)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">四、转义：\</span><br><span class="line">    1.普通的字符--&gt;特殊含义的字符</span><br><span class="line">        n,r,t,b---&gt;\n,\r,\t,\b</span><br><span class="line">    2.特殊含义的字符--&gt;普通字符</span><br><span class="line">        &quot;,&#39;,\--&gt;\&quot;,\&#39;</span><br><span class="line"></span><br><span class="line">    &quot;\&quot;abc&quot;--&gt;&quot;abc</span><br><span class="line">    &quot;\\abc&quot;</span><br><span class="line">    \&quot;--&gt;&quot;</span><br><span class="line">    \\--&gt;\</span><br><span class="line">    \.--&gt;.</span><br><span class="line">    \w,\d,\s,\b....--&gt;正则中规定的字符</span><br></pre></td></tr></table></figure>
<p>示例代码：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"regexp"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//转义字符</span></span><br><span class="line">	b1 := regexp.MustCompile(<span class="string">`\n\w`</span>).MatchString(<span class="string">`\nabc`</span>)</span><br><span class="line">	fmt.Println(b1) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">	b2 := regexp.MustCompile(<span class="string">`\n\w`</span>).MatchString(<span class="string">`\\nabc`</span>)</span><br><span class="line">	fmt.Println(b2)<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">	b3 := regexp.MustCompile(<span class="string">`\\n\w`</span>).MatchString(<span class="string">`\\nabc`</span>)</span><br><span class="line">	fmt.Println(b3)<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">	b4 := regexp.MustCompile(<span class="string">`\\\\n\w`</span>).MatchString(<span class="string">`\\nabc`</span>)</span><br><span class="line">	fmt.Println(b4)<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">	b5 := regexp.MustCompile(<span class="string">`\\n\w`</span>).MatchString(<span class="string">`\\nabc`</span>)</span><br><span class="line">	fmt.Println(b5)<span class="comment">//true</span></span><br><span class="line">	b6 := regexp.MustCompile(<span class="string">`\.\w+`</span>).MatchString(<span class="string">`.abc`</span>)</span><br><span class="line">	fmt.Println(b6)<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="边界问题"><a href="#边界问题" class="headerlink" title="边界问题"></a>边界问题</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">五、边界问题</span><br><span class="line"><span class="number">1.</span>^,表示匹配的起始位置</span><br><span class="line"><span class="number">2.</span>$,表示结束的位置</span><br></pre></td></tr></table></figure>
<p>示例代码：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"regexp"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 边界问题</span></span><br><span class="line"></span><br><span class="line">	b1 := regexp.MustCompile(<span class="string">`1[34578]\d&#123;9&#125;`</span>).MatchString(<span class="string">`13278652345`</span>)</span><br><span class="line">	fmt.Println(b1) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">	b2 := regexp.MustCompile(<span class="string">`1[34578]\d&#123;9&#125;$`</span>).MatchString(<span class="string">`1327865234578484848955`</span>)</span><br><span class="line">	fmt.Println(b2) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">	b3 := regexp.MustCompile(<span class="string">`^1[34578]\d&#123;9&#125;$`</span>).MatchString(<span class="string">`13278652345`</span>) <span class="comment">//</span></span><br><span class="line">	fmt.Println(b3)                                                        <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">	b4 := regexp.MustCompile(<span class="string">`^[1-9]\d&#123;17&#125;$`</span>).MatchString(<span class="string">`12345619881023432132`</span>) <span class="comment">//</span></span><br><span class="line">	fmt.Println(b4)                                                               <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 单词边界 "today is good"   (空格/开头)单词(末尾空格/结束)</span></span><br><span class="line">	fmt.Println(regexp.MustCompile(<span class="string">`^\w+ve`</span>).FindString(<span class="string">`hover`</span>))          <span class="comment">//hove</span></span><br><span class="line">	fmt.Println(regexp.MustCompile(<span class="string">`\w+ve`</span>).FindString(<span class="string">`hoverhoverhover`</span>)) <span class="comment">// hoverhoverhove</span></span><br><span class="line">	fmt.Println(regexp.MustCompile(<span class="string">`^\w+ve$`</span>).FindString(<span class="string">`hover`</span>))         <span class="comment">// ""</span></span><br><span class="line">	fmt.Println(regexp.MustCompile(<span class="string">`^\w+ve`</span>).FindString(<span class="string">`hover hover`</span>))    <span class="comment">//hove</span></span><br><span class="line">	fmt.Println(regexp.MustCompile(<span class="string">`\w+ve\b`</span>).FindString(<span class="string">`hoverhover`</span>))    <span class="comment">//""</span></span><br><span class="line">	fmt.Println(regexp.MustCompile(<span class="string">`\w+ve\b`</span>).FindString(<span class="string">`hove r`</span>))        <span class="comment">//hove</span></span><br><span class="line">	fmt.Println(regexp.MustCompile(<span class="string">`^\w+\sve\b`</span>).FindString(<span class="string">`ho ve r`</span>))    <span class="comment">//ho ve</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">六、分组：</span><br><span class="line">    <span class="number">1.</span>|,或者的意思</span><br><span class="line">        a|b,a或者b</span><br><span class="line">    <span class="number">2.</span>(),代表了分组</span><br><span class="line">        (abc)--&gt;一组</span><br><span class="line">        正则表达式中使用了分组，组默认是有编号的：<span class="number">1</span>,<span class="number">2</span>,<span class="number">3.</span>。。</span><br><span class="line">    <span class="number">3.</span>\num,引用分组的内容</span><br><span class="line">        num是分组的编号</span><br><span class="line">    <span class="number">4.</span>(?P&lt;name&gt;),给分组起别名</span><br><span class="line">    <span class="number">5.</span>(?P=name),引用分组</span><br><span class="line">        P字母大写</span><br></pre></td></tr></table></figure>
<p>示例代码：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"regexp"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分组</span></span><br><span class="line"></span><br><span class="line">    b1 := regexp.MustCompile(<span class="string">`[0-9]|x`</span>).MatchString(<span class="string">`x`</span>)</span><br><span class="line">    fmt.Println(b1)</span><br><span class="line"></span><br><span class="line">    b2 := regexp.MustCompile(<span class="string">`[ab]`</span>).MatchString(<span class="string">`a`</span>)</span><br><span class="line">    fmt.Println(b2)</span><br><span class="line"></span><br><span class="line">    b3 := regexp.MustCompile(<span class="string">`abc|ddd`</span>).MatchString(<span class="string">`ddd`</span>)</span><br><span class="line">    fmt.Println(b3)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 身份证：  练习3：身份证号：18位。0不能开头第一位：非0,16位。最后一位：(数字|X)</span></span><br><span class="line">    fmt.Println(regexp.MustCompile(<span class="string">`[1-9]\d&#123;17&#125;|[1-9]\d&#123;16&#125;X`</span>).MatchString(<span class="string">`13141219880712321X`</span>))</span><br><span class="line">    fmt.Println(regexp.MustCompile(<span class="string">`^[1-9]\d&#123;16&#125;(\d|X)$`</span>).MatchString(<span class="string">`13141219880712321X`</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//练习2：邮箱：163.com，qq.com?</span></span><br><span class="line">    s1 := <span class="string">`wangergou@163.com`</span></span><br><span class="line">    s2 := <span class="string">`sanpang@qq.com`</span> <span class="comment">// 828384848@qq.com</span></span><br><span class="line">    s3 := <span class="string">`lixiaohua@sina.com`</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(regexp.MustCompile(<span class="string">`\w+@(163|qq)\.com`</span>).MatchString(s1))</span><br><span class="line">    fmt.Println(regexp.MustCompile(<span class="string">`\w+@(163|qq)\.com`</span>).MatchString(s2))</span><br><span class="line">    fmt.Println(regexp.MustCompile(<span class="string">`\w+@(163|qq)\.com`</span>).MatchString(s3))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 练习3：邮箱：163.com,sina.cn,yahoo,cn,qq.com</span></span><br><span class="line">    fmt.Println(regexp.MustCompile(<span class="string">`\w+@(163|sina|yahoo|qq)\.(com|cn)`</span>).MatchString(<span class="string">`sanpang@163.com`</span>))</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"----------------------"</span>)</span><br><span class="line"></span><br><span class="line">    s4 := <span class="string">`&lt;html&gt;&lt;h1&gt;helloworld&lt;/h1&gt;&lt;/html&gt;李小花李小花`</span></span><br><span class="line">    re1 := regexp.MustCompile(<span class="string">`&lt;(.+)&gt;&lt;.+&gt;(.+)&lt;/.+&gt;&lt;/.+&gt;`</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印分组的数量</span></span><br><span class="line">    fmt.Println(re1.NumSubexp()) <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">    res1 := re1.FindAllStringSubmatch(s4, <span class="number">-1</span>)</span><br><span class="line">    fmt.Println(res1)</span><br><span class="line">    fmt.Println(res1[<span class="number">0</span>])</span><br><span class="line">    fmt.Println(res1[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">    fmt.Println(res1[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">    fmt.Println(res1[<span class="number">0</span>][<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"-----------------------"</span>)</span><br><span class="line"></span><br><span class="line">    s5 := <span class="string">`&lt;html&gt;&lt;body&gt;&lt;h1&gt;hello&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;`</span></span><br><span class="line">    re2 := regexp.MustCompile(<span class="string">`&lt;(?P&lt;t1&gt;.+)&gt;&lt;(?P&lt;t2&gt;.+)&gt;&lt;(?P&lt;t3&gt;.+)&gt;(?P&lt;t4&gt;.+)&lt;/(.+)&gt;&lt;/(.+)&gt;&lt;/(.+)&gt;`</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取分组名称</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= re2.NumSubexp(); i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%d: %q\n"</span>, i, re2.SubexpNames()[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res2 := re2.FindAllStringSubmatch(s5, <span class="number">-1</span>)</span><br><span class="line">    fmt.Println(res2)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="贪婪和非贪婪"><a href="#贪婪和非贪婪" class="headerlink" title="贪婪和非贪婪"></a>贪婪和非贪婪</h4><ul>
<li>1.贪婪：在使用数量词的时候，默认的就是贪婪模式 贪婪模式：意思是说，匹配的时候，尽可能多匹配。，不行再少</li>
<li>2.也叫懒惰模式 非贪婪，尽可能少的匹配，不满足规则再增加</li>
<li>3.启动费贪婪：数量词后加？</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"regexp"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分组</span></span><br><span class="line"></span><br><span class="line">    b1 := regexp.MustCompile(<span class="string">`\d&#123;2,4&#125;`</span>).MatchString(<span class="string">`123c4abc`</span>)</span><br><span class="line">    fmt.Println(b1)</span><br><span class="line"></span><br><span class="line">    b2 := regexp.MustCompile(<span class="string">`\d+`</span>).MatchString(<span class="string">`13774kdf393`</span>)</span><br><span class="line">    fmt.Println(b2)</span><br><span class="line"></span><br><span class="line">    b3 := regexp.MustCompile(<span class="string">`\d&#123;2,4&#125;?`</span>).MatchString(<span class="string">`123c4abc`</span>) <span class="comment">//非贪婪模式，尽可能少匹配</span></span><br><span class="line">    fmt.Println(b3)</span><br><span class="line"></span><br><span class="line">    b4 := regexp.MustCompile(<span class="string">`\d+?`</span>).MatchString(<span class="string">`13774kdf393`</span>)</span><br><span class="line">    fmt.Println(b4)</span><br><span class="line"></span><br><span class="line">    s1 := <span class="string">"This is a number 234-245-236"</span></span><br><span class="line">    <span class="comment">//获取数字部分</span></span><br><span class="line">    b5 := regexp.MustCompile(<span class="string">`(.+)(\d+-\d+-\d+)`</span>).FindAllStringSubmatch(s1,<span class="number">-1</span>)</span><br><span class="line">    fmt.Println(b5)</span><br><span class="line">    fmt.Println(b5[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">    fmt.Println(b5[<span class="number">0</span>][<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非贪婪</span></span><br><span class="line">    b6 := regexp.MustCompile(<span class="string">`(.+?)(\d+-\d+-\d+)`</span>).FindAllStringSubmatch(s1,<span class="number">-1</span>)</span><br><span class="line">    fmt.Println(b6)</span><br><span class="line">    fmt.Println(b6[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">    fmt.Println(b6[<span class="number">0</span>][<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
        <category>regex</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>regex</tag>
      </tags>
  </entry>
  <entry>
    <title>go -- 发起GET -- 请求和POST请求</title>
    <url>/2018/03/12/go-%E5%8F%91%E8%B5%B7GET%E8%AF%B7%E6%B1%82%E5%92%8CPOST%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<h3 id="Golang-发起GET请求"><a href="#Golang-发起GET请求" class="headerlink" title="Golang 发起GET请求"></a>Golang 发起GET请求</h3><h4 id="基本的GET请求"><a href="#基本的GET请求" class="headerlink" title="基本的GET请求"></a>基本的GET请求</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"net/http/httputil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	resp, err := http.Get(<span class="string">"http://httpbin.org/get"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">	response, err := httputil.DumpResponse(resp, <span class="literal">true</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(response))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="带有参数的GET请求"><a href="#带有参数的GET请求" class="headerlink" title="带有参数的GET请求"></a>带有参数的GET请求</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	resp, err := http.Get(<span class="string">"http://httpbin.org/get?name=tom&amp;age=19"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">	respone, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(respone))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="动态传递GET请求参数"><a href="#动态传递GET请求参数" class="headerlink" title="动态传递GET请求参数"></a>动态传递GET请求参数</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"net/url"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	params := url.Values&#123;&#125;</span><br><span class="line">	Url, err := url.Parse(<span class="string">"http://httpbin.org/get"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	params.Set(<span class="string">"name"</span>,<span class="string">"xiaoming"</span>)</span><br><span class="line">	params.Set(<span class="string">"age"</span>,<span class="string">"19"</span>)</span><br><span class="line">	Url.RawQuery = params.Encode()  <span class="comment">//如果参数中有中文参数,这个方法会进行URLEncode</span></span><br><span class="line">	urlPath := Url.String()  <span class="comment">// http://httpbin.org/get?age=19&amp;name=xiaoming&#123;</span></span><br><span class="line">	resp,err := http.Get(urlPath)</span><br><span class="line">	<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">	body, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="GET请求json返回值"><a href="#GET请求json返回值" class="headerlink" title="GET请求json返回值"></a>GET请求json返回值</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">	Args <span class="keyword">string</span> <span class="string">`json:"args"`</span></span><br><span class="line">	Headers <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="string">`json:"headers"`</span></span><br><span class="line">	Origin <span class="keyword">string</span> <span class="string">`json:"origin"`</span></span><br><span class="line">	Url <span class="keyword">string</span> <span class="string">`json:"url"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	resp, err := http.Get(<span class="string">"http://httpbin.org/get"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">	body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(body))</span><br><span class="line">	<span class="keyword">var</span> res result</span><br><span class="line">	_ = json.Unmarshal(body, &amp;res)</span><br><span class="line">	fmt.Printf(<span class="string">"%#v"</span>, res)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="GET请求添加请求头"><a href="#GET请求添加请求头" class="headerlink" title="GET请求添加请求头"></a>GET请求添加请求头</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	client := &amp;http.Client&#123;&#125;</span><br><span class="line">	request, err := http.NewRequest(<span class="string">"GET"</span>, <span class="string">" http://httpbin.org/get"</span>, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">	request.Header.Add(<span class="string">"User-Agent"</span>, <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36"</span>)</span><br><span class="line">	request.Header.Add(<span class="string">"name"</span>, <span class="string">"xiaoming"</span>)</span><br><span class="line">	resp, _ := client.Do(request)</span><br><span class="line">	body, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Golang-发起POST请求"><a href="#Golang-发起POST请求" class="headerlink" title="Golang 发起POST请求"></a>Golang 发起POST请求</h3><h4 id="1-基本-POST-请求"><a href="#1-基本-POST-请求" class="headerlink" title="(1)基本 POST 请求"></a>(1)基本 POST 请求</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"net/url"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	values := url.Values&#123;&#125;</span><br><span class="line">	values.Add(<span class="string">"username"</span>, <span class="string">"xiaoming"</span>)</span><br><span class="line">	values.Add(<span class="string">"pwd"</span>, <span class="string">"pwd"</span>)</span><br><span class="line">	resp, _ := http.PostForm(<span class="string">"http://httpbin.org/post"</span>, values)</span><br><span class="line">	body, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-基本的post请求"><a href="#2-基本的post请求" class="headerlink" title="(2)基本的post请求"></a>(2)基本的post请求</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"net/url"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	values := url.Values&#123;</span><br><span class="line">		<span class="string">"word"</span>:&#123;<span class="string">"hello"</span>&#125;,</span><br><span class="line">		<span class="string">"gender"</span>:&#123;<span class="string">"male"</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	encode := values.Encode()</span><br><span class="line">	resp, err := http.Post(<span class="string">"http://httpbin.org/post"</span>, <span class="string">"text/html"</span>, strings.NewReader(encode))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-POST请求-发送json数据"><a href="#1-POST请求-发送json数据" class="headerlink" title="(1)POST请求 发送json数据"></a>(1)POST请求 发送json数据</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bytes"</span></span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	client := &amp;http.Client&#123;&#125;</span><br><span class="line">	data := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	data[<span class="string">"username"</span>] = <span class="string">"xiaoming"</span></span><br><span class="line">	data[<span class="string">"pwd"</span>] = <span class="string">"pwd"</span></span><br><span class="line">	reqData, _ := json.Marshal(data)</span><br><span class="line">	req, _ := http.NewRequest(<span class="string">"POST"</span>, <span class="string">"http://httpbin.org/post"</span>, bytes.NewReader(reqData))</span><br><span class="line">	resp, _ := client.Do(req)</span><br><span class="line">	all, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(all))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-POST请求-发送json数据"><a href="#2-POST请求-发送json数据" class="headerlink" title="(2)POST请求 发送json数据"></a>(2)POST请求 发送json数据</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bytes"</span></span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	data := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	data[<span class="string">"username"</span>] = <span class="string">"xiaoming"</span></span><br><span class="line">	data[<span class="string">"pwd"</span>] = <span class="string">"pwd"</span></span><br><span class="line">	reqData, _ := json.Marshal(data)</span><br><span class="line">	req, _ := http.Post(<span class="string">"http://httpbin.org/post"</span>,<span class="string">"application/json"</span>, bytes.NewReader(reqData))</span><br><span class="line">	all, err := ioutil.ReadAll(req.Body)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(all))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
        <category>Get</category>
        <category>Post</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>Get</tag>
        <tag>Post</tag>
      </tags>
  </entry>
  <entry>
    <title>go -- excelize-- 导出文件</title>
    <url>/2020/07/06/go%E4%BD%BF%E7%94%A8excelize%E5%AF%BC%E5%87%BA%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="360EntSecGroup-Skylar-excelize"><a href="#360EntSecGroup-Skylar-excelize" class="headerlink" title="360EntSecGroup-Skylar/excelize"></a>360EntSecGroup-Skylar/excelize</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go get github.com&#x2F;360EntSecGroup-Skylar&#x2F;excelize</span><br></pre></td></tr></table></figure>
<h4 id="Gin-中导出-Excel"><a href="#Gin-中导出-Excel" class="headerlink" title="Gin 中导出 Excel"></a>Gin 中导出 Excel</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ExportField <span class="keyword">struct</span> &#123;</span><br><span class="line">	phone_num sql.NullInt64 <span class="string">`json:"phone_num"`</span></span><br><span class="line">	intent_level sql.NullInt64</span><br><span class="line">	call_result sql.NullInt64</span><br><span class="line">	call_start_time sql.NullString</span><br><span class="line">	call_end_time sql.NullString</span><br><span class="line">	talk_duration sql.NullInt64</span><br><span class="line">	r_time  sql.NullString</span><br><span class="line">	calling_number  sql.NullString</span><br><span class="line">	hang_up_note  sql.NullString</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	engine := gin.Default()</span><br><span class="line">	engine.GET(<span class="string">"/export"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		head := []<span class="keyword">string</span>&#123;<span class="string">"序号"</span>,<span class="string">"预警意向"</span>, <span class="string">"号码"</span>, <span class="string">"完成状态"</span>, <span class="string">"开始时间"</span>, <span class="string">"结束时间"</span>, <span class="string">"通话时长"</span>, <span class="string">"通话状态"</span>, <span class="string">"主叫号码"</span>, <span class="string">"上传时间"</span>, <span class="string">"挂机短信"</span>&#125;</span><br><span class="line">		query_sql := <span class="string">`</span></span><br><span class="line"><span class="string">			SELECT</span></span><br><span class="line"><span class="string">				phone_num,</span></span><br><span class="line"><span class="string">				intent_level,</span></span><br><span class="line"><span class="string">				call_result,</span></span><br><span class="line"><span class="string">				to_char(</span></span><br><span class="line"><span class="string">					call_start_time,</span></span><br><span class="line"><span class="string">					'YYYY-MM-DD hh24:mi:ss'</span></span><br><span class="line"><span class="string">				) AS call_start_time,</span></span><br><span class="line"><span class="string">				to_char(</span></span><br><span class="line"><span class="string">					call_end_time,</span></span><br><span class="line"><span class="string">					'YYYY-MM-DD hh24:mi:ss'</span></span><br><span class="line"><span class="string">				) AS call_end_time,</span></span><br><span class="line"><span class="string">				talk_duration,</span></span><br><span class="line"><span class="string">				to_char(</span></span><br><span class="line"><span class="string">					r_time,</span></span><br><span class="line"><span class="string">					'YYYY-MM-DD hh24:mi:ss'</span></span><br><span class="line"><span class="string">				) AS r_time,</span></span><br><span class="line"><span class="string">			calling_number, hang_up_note</span></span><br><span class="line"><span class="string">			FROM</span></span><br><span class="line"><span class="string">				aicall.sbc_task_list`</span></span><br><span class="line">		rows, err := postgresql.DBConnPostGresql().Query(query_sql)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> alldata [][]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">		<span class="keyword">var</span> num <span class="keyword">int</span></span><br><span class="line">		<span class="keyword">for</span> rows.Next()&#123;</span><br><span class="line">			<span class="keyword">var</span> export ExportField</span><br><span class="line">			err := rows.Scan(&amp;export.phone_num, &amp;export.intent_level, &amp;export.call_result, &amp;export.call_start_time,</span><br><span class="line">				&amp;export.call_end_time, &amp;export.talk_duration, &amp;export.r_time, &amp;export.calling_number, &amp;export.hang_up_note)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				fmt.Println(err)</span><br><span class="line">			&#125;</span><br><span class="line">			data := []<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">				num,</span><br><span class="line">				export.intent_level.Int64,</span><br><span class="line">				export.phone_num.Int64,</span><br><span class="line">				export.call_result.Int64,</span><br><span class="line">				export.call_start_time.String,</span><br><span class="line">				export.call_end_time.String,</span><br><span class="line">				export.talk_duration.Int64,</span><br><span class="line">				export.call_result.Int64,</span><br><span class="line">				export.calling_number.String,</span><br><span class="line">				export.r_time.String,</span><br><span class="line">				export.hang_up_note.String,</span><br><span class="line">			&#125;</span><br><span class="line">			alldata = <span class="built_in">append</span>(alldata, data)</span><br><span class="line">		&#125;</span><br><span class="line">		filename := <span class="string">"task"</span> + <span class="string">"_"</span> + time.Now().Format(<span class="string">"20060102150405"</span>) + <span class="string">".xlsx"</span></span><br><span class="line">		Export(c, head, alldata, filename)</span><br><span class="line"></span><br><span class="line">	&#125;)</span><br><span class="line">	engine.Run(<span class="string">":9900"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Export</span><span class="params">(c *gin.Context, head []<span class="keyword">string</span>, body [][]<span class="keyword">interface</span>&#123;&#125;, filename <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	xlsx := excelize.NewFile()</span><br><span class="line">	xlsx.SetSheetRow(<span class="string">"Sheet1"</span>, <span class="string">"A1"</span>, &amp;head)</span><br><span class="line">	<span class="keyword">for</span> index, rowData :=  <span class="keyword">range</span> body&#123;</span><br><span class="line">		xlsx.SetSheetRow(<span class="string">"Sheet1"</span>, <span class="string">"A"</span> + strconv.Itoa(index + <span class="number">2</span>), &amp;rowData) <span class="comment">// SetSheetRow：设置一行数据 SetCellValue：设置一个数据</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.Header(<span class="string">"Content-Type"</span>, <span class="string">"application/octet-stream"</span>)</span><br><span class="line">	c.Header(<span class="string">"Content-Disposition"</span>, <span class="string">"attachment; filename="</span> + filename)</span><br><span class="line">	c.Header(<span class="string">"Content-Transfer-Encoding"</span>, <span class="string">"binary"</span>)</span><br><span class="line">	_ = xlsx.Write(c.Writer)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
        <category>excelize</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>excelize</tag>
      </tags>
  </entry>
  <entry>
    <title>go -- 返回值内存分配</title>
    <url>/2020/05/12/go-%E8%BF%94%E5%9B%9E%E5%80%BC%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    <content><![CDATA[<p>局部变量内存由所在的函数分配，但返回值内存却是由调用方（caller）提供，这种差别会导致某些行为上的差异</p>
<blockquote>
<p>defer 注册延迟调用，确保再函数结束前（ret）调用这些逻辑</p>
</blockquote>
<p>注意，return语句执行顺序是：</p>
<ul>
<li><ol>
<li>写返回值</li>
</ol>
</li>
<li><ol>
<li>调用defer</li>
</ol>
</li>
<li><ol>
<li>执行ret指令</li>
</ol>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	x := <span class="number">0</span>                 <span class="comment">// x 内存由 test 栈帧提供。</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; </span><br><span class="line">        x = <span class="number">100</span>            <span class="comment">// 闭包引用本地局部变量。</span></span><br><span class="line">    &#125;()   </span><br><span class="line"></span><br><span class="line">	x = <span class="number">200</span></span><br><span class="line">	<span class="keyword">return</span> x               <span class="comment">// 将 200 写入返回值内存，然后才会执行 defer、ret。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(test())        <span class="comment">// 200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行顺序</strong>：</p>
<ul>
<li><ol>
<li>local.x := 0</li>
</ol>
</li>
<li><ol>
<li>注册defer调用，构成对本地变量的闭包引用，但是匿名函数未执行。</li>
</ol>
</li>
<li><ol>
<li>local.x = 200</li>
</ol>
</li>
<li><ol>
<li>修改main.return_value = 200</li>
</ol>
</li>
<li><ol>
<li>调用defer.fn 修改local.x =100,不影响main.return_value</li>
</ol>
</li>
<li><ol>
<li>ret 指令结束test函数执行</li>
</ol>
</li>
</ul>
<p>当返回值是命令方式时，行为差异导致输出结果不同<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> <span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; </span><br><span class="line">        x = <span class="number">100</span> </span><br><span class="line">    &#125;()                      <span class="comment">// 引用返回值内存，修改有效。</span></span><br><span class="line">    </span><br><span class="line">	x = <span class="number">200</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(test())         <span class="comment">// 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>执行顺序：</p>
<ul>
<li><ol>
<li>注册defer调用，闭包引用x,注意命名返回值内存由调用方（main）提供</li>
</ol>
</li>
<li><ol>
<li>x= main.return_value =200 直接修改了返回值内存</li>
</ol>
</li>
<li><ol>
<li>return 未提供显示值，默认x</li>
</ol>
</li>
<li><ol>
<li>调用defer函数，直接修改 x= main.return_value =100</li>
</ol>
</li>
<li><ol>
<li>ret指令结束函数执行</li>
</ol>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> tool objdump -s <span class="string">"main\.test"</span> test</span><br><span class="line"><span class="comment">//用go tool objdump，可以看到任意函数的机器码、汇编指令、偏移</span></span><br><span class="line">TEXT main.test(SB)  </span><br><span class="line">  SUBQ $<span class="number">0x28</span>, SP                                +----------+---------</span><br><span class="line">  MOVQ BP, <span class="number">0x20</span>(SP)                             |          |  func1</span><br><span class="line">  LEAQ <span class="number">0x20</span>(SP), BP                             +----------+---------</span><br><span class="line">                                                | IP       |</span><br><span class="line">  MOVUPS X0, <span class="number">0x10</span>(SP)                       <span class="number">0x0</span> +----------+--------- test.SP</span><br><span class="line">  MOVB $<span class="number">0x0</span>, <span class="number">0xf</span>(SP)                            | 返回值地址 | </span><br><span class="line">  MOVQ $<span class="number">0x0</span>, <span class="number">0x30</span>(SP)      # 初始化返回值     <span class="number">0x8</span> +----------+       </span><br><span class="line">                                                |          |</span><br><span class="line">  LEAQ <span class="keyword">go</span><span class="function">.<span class="keyword">func</span>.*+72<span class="params">(SB)</span>, <span class="title">AX</span>                0<span class="title">x10</span> +----------+</span></span><br><span class="line">  MOVQ AX, <span class="number">0x18</span>(SP)                             | 返回值地址 |</span><br><span class="line">  LEAQ <span class="number">0x30</span>(SP), AX        # AX:返回值地址   <span class="number">0x18</span> +----------+  test</span><br><span class="line">  MOVQ AX, <span class="number">0x10</span>(SP)        # <span class="number">0x10</span>(SP):AX        |          |</span><br><span class="line">  MOVB $<span class="number">0x1</span>, <span class="number">0xf</span>(SP)                       <span class="number">0x20</span> +----------+</span><br><span class="line">  MOVQ $<span class="number">0xc8</span>, <span class="number">0x30</span>(SP)     # 返回值 = <span class="number">200</span>        | BP       |</span><br><span class="line">  MOVB $<span class="number">0x0</span>, <span class="number">0xf</span>(SP)                       <span class="number">0x28</span> +----------+----------</span><br><span class="line">  MOVQ <span class="number">0x10</span>(SP), AX        # AX:返回值地址        | IP       |</span><br><span class="line">  MOVQ AX, <span class="number">0</span>(SP)           # <span class="number">0</span>x(SP):AX     <span class="number">0x30</span> +----------+---------- </span><br><span class="line">  CALL main.test.func1(SB)                      | 返回值内存 |</span><br><span class="line">                                                +----------+  main</span><br><span class="line">  MOVQ <span class="number">0x20</span>(SP), BP                             |          |</span><br><span class="line">  ADDQ $<span class="number">0x28</span>, SP                                +----------+</span><br><span class="line">  RET                 </span><br><span class="line"></span><br><span class="line">TEXT main.test.func1(SB)  # <span class="keyword">defer</span> 注册的匿名函数。</span><br><span class="line">  MOVQ <span class="number">0x8</span>(SP), AX        # 获取返回值地址</span><br><span class="line">  MOVQ $<span class="number">0x64</span>, <span class="number">0</span>(AX)       # 返回值 = <span class="number">100</span></span><br><span class="line">  RET</span><br></pre></td></tr></table></figure>
<p>源地址：<a href="https://www.yuque.com/docs/share/5a0474df-5bed-4aca-a1a2-82b58a16fc77" target="_blank" rel="noopener">https://www.yuque.com/docs/share/5a0474df-5bed-4aca-a1a2-82b58a16fc77</a></p>
]]></content>
      <categories>
        <category>go</category>
        <category>defer</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>defer</tag>
      </tags>
  </entry>
  <entry>
    <title>go -- 语言Channel</title>
    <url>/2018/07/12/go%E8%AF%AD%E8%A8%80Channel/</url>
    <content><![CDATA[<h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>再使用goroutine的时候提到过多个goroutine会产生竞争关系。可以通过原子函数和互斥锁来解决竞争关系，更推荐使用channel</p>
<h4 id="定义channel"><a href="#定义channel" class="headerlink" title="定义channel"></a>定义channel</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无缓冲的整型通道</span></span><br><span class="line">unbuffered := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">//有缓冲的字符串通道</span></span><br><span class="line">buffered := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<h4 id="从channel里发送数据"><a href="#从channel里发送数据" class="headerlink" title="从channel里发送数据"></a>从channel里发送数据</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过通道发送一个字符串 </span></span><br><span class="line">buffered &lt;- <span class="number">1</span></span><br><span class="line"><span class="comment">//从通道接收一个字符串 </span></span><br><span class="line">value := &lt;- buffered</span><br></pre></td></tr></table></figure>
<p>示例1：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			n := &lt;- c</span><br><span class="line">			fmt.Println(n)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(c)</span><br><span class="line">	c &lt;- <span class="number">1</span></span><br><span class="line">	c &lt;- <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>示例2：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	chanDemo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// create channel slice</span></span><br><span class="line">	<span class="keyword">var</span> channels [<span class="number">10</span>]<span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="comment">//channels[i] = make(chan int)</span></span><br><span class="line">		<span class="comment">//go worker(i, channels[i])</span></span><br><span class="line">		channels[i] = Createworker(i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line"></span><br><span class="line">		channels[i] &lt;- <span class="string">'a'</span> + i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">		channels[i] &lt;- <span class="string">'A'</span> + i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span>  &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"Worker %d received %d\n"</span>,</span><br><span class="line">			id, &lt;-c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Createworker</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="title">chan</span> <span class="title">int</span></span>&#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span>  &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"worker %d received %c\n"</span>, id ,&lt;-c)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="有缓冲区的channel"><a href="#有缓冲区的channel" class="headerlink" title="有缓冲区的channel"></a>有缓冲区的channel</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">3</span>)</span><br><span class="line">	<span class="keyword">go</span> worker(c)</span><br><span class="line">	<span class="comment">//for i := 0; i &lt; 10; i++ &#123;</span></span><br><span class="line">	<span class="comment">//	c &lt;- 'a' +i</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	c &lt;- <span class="string">'a'</span></span><br><span class="line">	c &lt;- <span class="string">'b'</span></span><br><span class="line">	c &lt;- <span class="string">'c'</span></span><br><span class="line">	<span class="comment">// 设置缓冲区，不读取数据也不会报错</span></span><br><span class="line">	time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span>  &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"worker received %c\n"</span>, &lt;-c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>// close() 关闭缓冲区<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">3</span>)</span><br><span class="line">	<span class="comment">// 设置缓冲区，不读取数据也不会报错</span></span><br><span class="line">	<span class="keyword">go</span> worker(c)</span><br><span class="line">	<span class="comment">//for i := 0; i &lt; 10; i++ &#123;</span></span><br><span class="line">	<span class="comment">//	c &lt;- 'a' +i</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	c &lt;- <span class="string">'a'</span></span><br><span class="line">	c &lt;- <span class="string">'b'</span></span><br><span class="line">	c &lt;- <span class="string">'c'</span></span><br><span class="line">	c &lt;- <span class="string">'d'</span></span><br><span class="line">	<span class="built_in">close</span>(c) <span class="comment">// 关闭channel ,会继续发送该channel类型的零值数据</span></span><br><span class="line">	time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">//for  &#123;</span></span><br><span class="line">	<span class="comment">//	n, ok := &lt;- c</span></span><br><span class="line">	<span class="comment">//	if !ok&#123;</span></span><br><span class="line">	<span class="comment">//		break</span></span><br><span class="line">	<span class="comment">//	&#125;</span></span><br><span class="line">	<span class="comment">//	fmt.Printf("worker received %c\n", n)</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="comment">// 简单写法</span></span><br><span class="line">	<span class="keyword">for</span> n := <span class="keyword">range</span> c&#123;</span><br><span class="line">		fmt.Printf(<span class="string">"worker received %c\n"</span>, n)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="如何等待Goroutine"><a href="#如何等待Goroutine" class="headerlink" title="如何等待Goroutine"></a>如何等待Goroutine</h4><p>在之前的代码里面都有使用time.Sleep(time.Millisecond)来等待Channel的结束。但是这种方法的危险肉眼可见。所以我们需要修改一下。<br>修改点：</p>
<ul>
<li>在执行打印的时候，不仅接受一个Channel的int，同时在打印完成后，传出一个done</li>
<li>由于有一对chan，将这一对chan提出来做一个struct</li>
<li>在Createworker的时候用worker构造体传值</li>
<li>同时在创建10个worker的时候也用构造体创建构造体的slice</li>
<li>在向内部传值后，同时加入接受done的处理</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> worker <span class="keyword">struct</span> &#123;</span><br><span class="line">	in <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">	done <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"channel as first_class citizen"</span>)</span><br><span class="line">	chanDemo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> workers [<span class="number">10</span>]worker</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		workers[i] = createWorker(i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		workers[i].in &lt;- <span class="string">'a'</span> +i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//for i := 0; i &lt; 10; i++ &#123;</span></span><br><span class="line">	<span class="comment">//	&lt;- workers[i].done</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		workers[i].in &lt;- <span class="string">'A'</span> + i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		&lt;- workers[i].done</span><br><span class="line">		&lt;- workers[i].done</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createWorker</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">worker</span></span> &#123;</span><br><span class="line">	w := worker&#123;</span><br><span class="line">		in: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>),</span><br><span class="line">		done: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> doworker(i , w.in, w.done)</span><br><span class="line">	<span class="keyword">return</span> w</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doworker</span><span class="params">(i <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>, done <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> n := <span class="keyword">range</span> c &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"Worker %d received %c\n"</span>, i, n)</span><br><span class="line">		<span class="comment">//done &lt;- true</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			done &lt;- <span class="literal">true</span></span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用sync-WaitGroup-来管理goroutine结束"><a href="#使用sync-WaitGroup-来管理goroutine结束" class="headerlink" title="使用sync.WaitGroup 来管理goroutine结束"></a>使用sync.WaitGroup 来管理goroutine结束</h4><p>WaitGroup的用法：</p>
<ul>
<li>定义WaitGroup本身：var wg sync.WaitGroup</li>
<li>定义需要等待的goroutine数量：wg.Add(20)</li>
<li>等待：wg.Wait()</li>
<li>在goroutine执行完成后done：w.done()</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> worker <span class="keyword">struct</span> &#123;</span><br><span class="line">	in <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">	<span class="comment">//done chan bool</span></span><br><span class="line">	done <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"channel as first_class citizen"</span>)</span><br><span class="line">	chanDemo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">var</span> workers [<span class="number">10</span>]worker</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		workers[i] = createWorker(i, &amp;wg)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Add(<span class="number">20</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		workers[i].in &lt;- <span class="string">'a'</span> +i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//for i := 0; i &lt; 10; i++ &#123;</span></span><br><span class="line">	<span class="comment">//	&lt;- workers[i].done</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		workers[i].in &lt;- <span class="string">'A'</span> + i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//for i := 0; i &lt; 10; i++ &#123;</span></span><br><span class="line">	<span class="comment">//	&lt;- workers[i].done</span></span><br><span class="line">	<span class="comment">//	&lt;- workers[i].done</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createWorker</span><span class="params">(i <span class="keyword">int</span>, wg *sync.WaitGroup)</span> <span class="title">worker</span></span> &#123;</span><br><span class="line">	w := worker&#123;</span><br><span class="line">		in: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>),</span><br><span class="line">		<span class="comment">//done: make(chan bool),</span></span><br><span class="line">		done: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> doworker(i ,w)</span><br><span class="line">	<span class="keyword">return</span> w</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doworker</span><span class="params">(i <span class="keyword">int</span>, w worker)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> n := <span class="keyword">range</span> w.in &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"Worker %d received %c\n"</span>, i, n)</span><br><span class="line">		<span class="comment">//done &lt;- true</span></span><br><span class="line">		<span class="comment">//go func() &#123;</span></span><br><span class="line">		<span class="comment">//	done &lt;- true</span></span><br><span class="line">		<span class="comment">//&#125;()</span></span><br><span class="line">		w.done()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Don’t communicate by sharing memory, share memory by communicating.</p>
<h4 id="不要通过共享内存进行通信，要通过通信来共享内存"><a href="#不要通过共享内存进行通信，要通过通信来共享内存" class="headerlink" title="不要通过共享内存进行通信，要通过通信来共享内存"></a>不要通过共享内存进行通信，要通过通信来共享内存</h4><p>比如我们判断前后程序是否处理是否完成的时候经常设置一个flag变量，然后通过检测这个变量来进行判断，这就是所谓通过共享内存进行通信。但是go语言更提倡通过使用Channel，通过通信来共享内存。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简单示例</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c1, c2 = generator(), generator()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> n:= &lt;- c1:</span><br><span class="line">			fmt.Println(n)</span><br><span class="line">		<span class="keyword">case</span> n := &lt;- c2:</span><br><span class="line">			fmt.Println(n)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generator</span><span class="params">()</span> <span class="title">chan</span> <span class="title">int</span></span>&#123;</span><br><span class="line">	out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		i := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span>  &#123;</span><br><span class="line">			time.Sleep(time.Duration(rand.Intn(<span class="number">1500</span>))*time.Millisecond)</span><br><span class="line">			out &lt;- i</span><br><span class="line">			i ++</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generator</span><span class="params">()</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		i := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			time.Sleep(</span><br><span class="line">				time.Duration(rand.Intn(<span class="number">1500</span>)) *</span><br><span class="line">					time.Millisecond)</span><br><span class="line">			out &lt;- i</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> n := <span class="keyword">range</span> c &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"Worker %d received %c\n"</span>,</span><br><span class="line">			id, n)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createWorker</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="title">chan</span>&lt;- <span class="title">int</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> worker(id, c)</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	worker := createWorker(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">var</span> c1, c2 = generator(), generator()</span><br><span class="line">	n := <span class="number">0</span></span><br><span class="line">	hasValue := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// nil chan永远不会被select到</span></span><br><span class="line">		<span class="keyword">var</span> activeworker <span class="keyword">chan</span>&lt;- <span class="keyword">int</span> </span><br><span class="line">		<span class="keyword">if</span> hasValue &#123;</span><br><span class="line">			activeworker = worker</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> n = &lt;-c1:</span><br><span class="line">			fmt.Println(<span class="string">"Received from c1: "</span>, n)</span><br><span class="line">			hasValue = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">case</span> n = &lt;-c2:</span><br><span class="line">			fmt.Println(<span class="string">"Received from c2: "</span>, n)</span><br><span class="line">			hasValue = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">case</span> activeworker &lt;- n:</span><br><span class="line">			hasValue = <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
        <category>Channel</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>Channel</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo themes/next主题文件无法提交github</title>
    <url>/2016/07/09/hexo_theme_next_github/</url>
    <content><![CDATA[<h4 id="hexo-themes-next主题文件存在无法提交github"><a href="#hexo-themes-next主题文件存在无法提交github" class="headerlink" title="hexo themes/next主题文件存在无法提交github"></a>hexo themes/next主题文件存在无法提交github</h4><h6 id="从暂存区删除该文件夹"><a href="#从暂存区删除该文件夹" class="headerlink" title="从暂存区删除该文件夹"></a>从暂存区删除该文件夹</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rm --cache themes/next</span><br></pre></td></tr></table></figure>
<h5 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add themes/next/</span><br><span class="line">git commit -m <span class="string">"your description"</span></span><br><span class="line">git push origin <span class="built_in">source</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>themes/next</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>go -- script</title>
    <url>/2020/07/12/go%E8%AF%AD%E8%A8%80_make_data_script/</url>
    <content><![CDATA[<h4 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"net"</span></span><br><span class="line">	<span class="string">"smartphone/db/postg"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	instr := <span class="string">`insert into aicall.t_rebot_dir (rebot_name,rebot_sign,rebot_state,card_slot,</span></span><br><span class="line"><span class="string">available_line,normal_line,except_line,device_ip,device_mac) values ($1,$2,$3,$4,$5,$6,$7,$8,$9); `</span></span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">var</span> (</span><br><span class="line">			rebot_state      <span class="keyword">int</span></span><br><span class="line">			rebot_name_alias <span class="keyword">string</span></span><br><span class="line">		)</span><br><span class="line">		<span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">			rebot_state = <span class="number">1</span></span><br><span class="line">			rebot_name_alias = <span class="string">"外呼中心"</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			rebot_name_alias = <span class="string">"GOIP"</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		card_slot := rand.Intn(<span class="number">30</span>) + <span class="number">10</span></span><br><span class="line">		fmt.Println(card_slot)</span><br><span class="line">		except_line := rand.Intn(<span class="number">10</span>)</span><br><span class="line">		fmt.Println(except_line)</span><br><span class="line">		normal_line := card_slot - except_line</span><br><span class="line">		fmt.Println(normal_line)</span><br><span class="line">		rebot_name := fmt.Sprintf(<span class="string">"设备%d(%s)"</span>, i, rebot_name_alias)</span><br><span class="line">		fmt.Println(rebot_name)</span><br><span class="line">		ip := fmt.Sprintf(<span class="string">"%d.%d.%d.%d"</span>, rand.Intn(<span class="number">255</span>), rand.Intn(<span class="number">255</span>), rand.Intn(<span class="number">255</span>), rand.Intn(<span class="number">255</span>))</span><br><span class="line">		fmt.Println(ip)</span><br><span class="line">		<span class="comment">// 随机mac</span></span><br><span class="line">		mac := GenerateMac().String()</span><br><span class="line">		<span class="comment">// rebot_sign</span></span><br><span class="line">		rebot_sign := fmt.Sprintf(<span class="string">"22948475%d"</span>, i)</span><br><span class="line"></span><br><span class="line">		fmt.Println(mac)</span><br><span class="line">		ret, err := postg.DBConnPostGresql().Exec(instr,</span><br><span class="line">			rebot_name, rebot_sign, rebot_state, card_slot, card_slot, normal_line, except_line, ip, mac)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"inster error:%v\n"</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		rf, _ := ret.RowsAffected()</span><br><span class="line">		fmt.Println(rf)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateMac</span><span class="params">()</span> <span class="title">net</span>.<span class="title">HardwareAddr</span></span> &#123;</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">6</span>)</span><br><span class="line">	<span class="keyword">var</span> mac net.HardwareAddr</span><br><span class="line"></span><br><span class="line">	_, err := rand.Read(buf)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set the local bit</span></span><br><span class="line">	<span class="comment">//buf[0] = buf[0] | 2 做按位与运算</span></span><br><span class="line">	buf[<span class="number">0</span>] |= <span class="number">2</span></span><br><span class="line"></span><br><span class="line">	mac = <span class="built_in">append</span>(mac, buf[<span class="number">0</span>], buf[<span class="number">1</span>], buf[<span class="number">2</span>], buf[<span class="number">3</span>], buf[<span class="number">4</span>], buf[<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mac</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"smartphone/db/postg"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	instr := <span class="string">`insert into aicall.t_rebot_dir_detail (rebot_id,line_name,line_state,except_cause) values ($1,$2,$3,$4); `</span></span><br><span class="line">	query_sql := <span class="string">`</span></span><br><span class="line"><span class="string">	select id from aicall.t_rebot_dir</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	rows, err := postg.DBConnPostGresql().Query(query_sql)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//var allid []int</span></span><br><span class="line">	<span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">		<span class="keyword">var</span> id <span class="keyword">int</span></span><br><span class="line">		rows.Scan(&amp;id)</span><br><span class="line">		<span class="comment">//allid = append(allid, id)</span></span><br><span class="line">		scope := rand.Intn(<span class="number">11</span>) + <span class="number">2</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; scope; i++ &#123;</span><br><span class="line">			line_name := fmt.Sprintf(<span class="string">"线路%d"</span>, i)</span><br><span class="line">			<span class="keyword">var</span> line_state <span class="keyword">int</span></span><br><span class="line">			<span class="keyword">var</span> except_cause <span class="keyword">string</span></span><br><span class="line">			<span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">				line_state = <span class="number">1</span></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> i == <span class="number">7</span> &#123;</span><br><span class="line">				except_cause = <span class="string">"其他故障"</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				except_cause = <span class="string">"欠费"</span></span><br><span class="line">			&#125;</span><br><span class="line">			ret, err := postg.DBConnPostGresql().Exec(instr, id, line_name, line_state, except_cause)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				fmt.Println(err)</span><br><span class="line">			&#125;</span><br><span class="line">			rf, _ := ret.RowsAffected()</span><br><span class="line">			fmt.Println(rf)</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//fmt.Println(allid)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
        <category>make-data</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go_script</tag>
      </tags>
  </entry>
  <entry>
    <title>java-- Arrays类</title>
    <url>/2018/10/13/java-Arrays/</url>
    <content><![CDATA[<h5 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h5><ul>
<li><code>java.util.Arrays</code> 此类包含用来操作数组的各种方法，比如排序和搜索等，所有方法均为静态方法</li>
</ul>
<h5 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h5><ul>
<li><code>public static String toString(int[] a)</code> ：返回指定数组内容的字符串表示形式。 </li>
<li><code>public static void sort(int[] a)</code>：对指定的 int 型数组按数字升序进行排序。 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demotestArrays</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] intArrays = &#123;<span class="number">10</span>, <span class="number">50</span>, <span class="number">30</span> ,<span class="number">20</span>&#125;;</span><br><span class="line">        <span class="comment">// int[] 转换为str</span></span><br><span class="line">        String intstr = Arrays.toString(intArrays);</span><br><span class="line">        System.out.println(intstr);</span><br><span class="line">        <span class="comment">// sort 排序</span></span><br><span class="line">        <span class="keyword">int</span>[] array1 = &#123;<span class="number">9</span>,<span class="number">20</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        Arrays.sort(array1);</span><br><span class="line">        System.out.println(Arrays.toString(array1));</span><br><span class="line">        <span class="comment">// sort 字符串排序</span></span><br><span class="line">        String[] array2 = &#123;<span class="string">"bb"</span>, <span class="string">"ccc"</span>,<span class="string">"aaa"</span>,<span class="string">"sgfagf"</span>&#125;;</span><br><span class="line">        Arrays.sort(array2);</span><br><span class="line">        System.out.println(Arrays.toString(array2));</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo02convert</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将一个随机字符串中的所有字符升序排列，并倒序打印</span></span><br><span class="line">        String str1 = <span class="string">"sdsa34snsth92o3afahuoh4qd"</span>;</span><br><span class="line">        <span class="keyword">char</span>[] charstr1 = str1.toCharArray();</span><br><span class="line">        System.out.println(charstr1);</span><br><span class="line">        Arrays.sort(charstr1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = charstr1.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.println(charstr1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
        <category>Arrays类</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>java-- ArrayList</title>
    <url>/2018/10/11/java-ArrayList/</url>
    <content><![CDATA[<h4 id="1-什么要用ArrayList"><a href="#1-什么要用ArrayList" class="headerlink" title="1.什么要用ArrayList"></a>1.什么要用ArrayList</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zmjaction.demo01;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">数组有一个缺点：一旦创建，程序运行期间长度不可以发生改变。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Students</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Students</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Students</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先创建一个长度为3的数组，里面用来存放Students类型的对象</span></span><br><span class="line">        Students[] array = <span class="keyword">new</span> Students[<span class="number">3</span>];</span><br><span class="line">        Students s1 = <span class="keyword">new</span> Students(<span class="string">"小明"</span>, <span class="number">10</span>);</span><br><span class="line">        Students s2 = <span class="keyword">new</span> Students(<span class="string">"小李"</span>, <span class="number">20</span>);</span><br><span class="line">        Students s3 = <span class="keyword">new</span> Students(<span class="string">"Tom"</span>, <span class="number">30</span>);</span><br><span class="line">        array[<span class="number">0</span>] = s1;</span><br><span class="line">        array[<span class="number">1</span>] = s2;</span><br><span class="line">        array[<span class="number">2</span>] = s3;</span><br><span class="line">        System.out.println(array[<span class="number">0</span>].getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-ArrayList使用步骤"><a href="#2-ArrayList使用步骤" class="headerlink" title="2.ArrayList使用步骤"></a>2.ArrayList使用步骤</h4><h5 id="查看类"><a href="#查看类" class="headerlink" title="查看类"></a>查看类</h5><ul>
<li><code>java.util.ArrayList&lt;E&gt;</code>:该类需要 import导入使后使用</li>
</ul>
<p><E> ，表示一种指定的数据类型，叫做泛型。 E ，取自Element（元素）的首字母。在出现 E 的地方，我们使 </p>
<p>用一种引用数据类型将其替换即可，表示我们将存储哪种引用类型的元素。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt;，ArrayList&lt;Student&gt;</span><br></pre></td></tr></table></figure>
<h5 id="查看构造方法"><a href="#查看构造方法" class="headerlink" title="查看构造方法"></a>查看构造方法</h5><ul>
<li><code>public ArrayList()</code> ：构造一个内容为空的集合</li>
</ul>
<p>基本格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure>
<p>在JDK 7后,右侧泛型的尖括号之内可以留空，但是&lt;&gt;仍然要写。简化格式： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h4 id="4-常用的方法和遍历"><a href="#4-常用的方法和遍历" class="headerlink" title="4.常用的方法和遍历"></a>4.常用的方法和遍历</h4><p>对于元素的操作基本体现在-增，删，查</p>
<ul>
<li><code>public boolean add(E e)</code> ：将指定的元素添加到此集合的尾部。 </li>
<li><code>public E remove(int index)</code> ：移除此集合中指定位置上的元素。返回被删除的元素。 </li>
<li><code>public E get(int index)</code> ：返回此集合中指定位置上的元素。返回获取的元素。 </li>
<li><code>public int size()</code> ：返回此集合中的元素数。遍历集合时，可以控制索引范围，防止越界。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zmjaction.demo01.d1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">数组的长度不可以改变</span></span><br><span class="line"><span class="comment">但是ArrayList的长度是可以随意改变的</span></span><br><span class="line"><span class="comment">对于ArrayList来说，有一个尖括号&lt;E&gt;表示泛型</span></span><br><span class="line"><span class="comment">泛型：装在集合中的元素，统一是什么类型</span></span><br><span class="line"><span class="comment">注意：泛型只能是引用类型，不能是基本类型</span></span><br><span class="line"><span class="comment">引用类型：</span></span><br><span class="line"><span class="comment">基本类型：</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">对于ArrayList集合来说，直接打印得到的不是地址值，而是内容。</span></span><br><span class="line"><span class="comment">如果内容是空，得到的是空的中括号：[]</span></span><br><span class="line"><span class="comment">===============================================</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建了一个ArrayList集合，集合名称是list，里边的元素是String类型的数据</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 想集合中添加一些元素</span></span><br><span class="line">        list.add(<span class="string">"xiaoming"</span>);</span><br><span class="line">        list.add(<span class="string">"xiaohong"</span>);</span><br><span class="line">        list.add(<span class="string">"xiaofeng"</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">// 从集合中获取到元素：get 索引从0开始</span></span><br><span class="line">        String name = list.get(<span class="number">2</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="comment">// 从集合中删除元素，remove 索引值从0开始</span></span><br><span class="line">        String rename = list.remove(<span class="number">2</span>);</span><br><span class="line">        System.out.println(rename);</span><br><span class="line">        <span class="comment">// 获取集合的长度，也就是元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> size = list.size();</span><br><span class="line">        System.out.println(size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="如何存基本数据类型数据"><a href="#如何存基本数据类型数据" class="headerlink" title="如何存基本数据类型数据"></a>如何存基本数据类型数据</h4><div class="table-container">
<table>
<thead>
<tr>
<th>数据类型</th>
<th>大小（bit)</th>
<th>范围</th>
<th>默认值</th>
<th>包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte(字节)</td>
<td>8</td>
<td>-128 - 127</td>
<td>0</td>
<td>Byte</td>
</tr>
<tr>
<td>short(短整型)</td>
<td>16</td>
<td>-32768~32767</td>
<td>0</td>
<td>Short</td>
</tr>
<tr>
<td>int(整型)</td>
<td>32</td>
<td>-2^31 ~ 2^31 -1</td>
<td>0</td>
<td>Integer</td>
</tr>
<tr>
<td>long(长整型)</td>
<td>64</td>
<td>-2^63 ~ 2^63 -1</td>
<td>0L</td>
<td>Long</td>
</tr>
<tr>
<td>float(浮点型)</td>
<td>32</td>
<td>1.4013E-45~3.4028E+38</td>
<td>0.0f</td>
<td>Float</td>
</tr>
<tr>
<td>double(双精度)</td>
<td>64</td>
<td>4.9E-324~1.7977E+308</td>
<td>0.0d</td>
<td>Double</td>
</tr>
<tr>
<td>char(字符型)</td>
<td>16</td>
<td>0-65535 / <code>\u0000~ \uffff</code></td>
<td>‘u0000’</td>
<td>Character</td>
</tr>
<tr>
<td>boolean(布尔型)</td>
<td>1</td>
<td>true/false</td>
<td>false</td>
<td>Boolean</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zmjaction.demo01.d1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = r.nextInt(<span class="number">30</span>) + <span class="number">1</span>;</span><br><span class="line">            list.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//便利集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
        <category>ArrayList</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>java-- Random</title>
    <url>/2018/10/10/java-Random/</url>
    <content><![CDATA[<h4 id="1-什么是Random类"><a href="#1-什么是Random类" class="headerlink" title="1.什么是Random类"></a>1.什么是Random类</h4><p>此类的实例用于生成伪随机数。 </p>
<p>例如，以下代码使用户能够得到一个随机数： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Random r &#x3D; new Random(); </span><br><span class="line">int i &#x3D; r.nextInt();</span><br></pre></td></tr></table></figure>
<h4 id="2-Random使用步骤"><a href="#2-Random使用步骤" class="headerlink" title="2.Random使用步骤"></a>2.Random使用步骤</h4><h5 id="查看类"><a href="#查看类" class="headerlink" title="查看类"></a>查看类</h5><ul>
<li><code>java.util.Random</code> ：该类需要 import导入使后使用。</li>
</ul>
<h5 id="查看构造方法"><a href="#查看构造方法" class="headerlink" title="查看构造方法"></a>查看构造方法</h5><ul>
<li><code>public Random()</code> ：创建一个新的随机数生成器。</li>
</ul>
<h5 id="查看成员方法"><a href="#查看成员方法" class="headerlink" title="查看成员方法"></a>查看成员方法</h5><ul>
<li><p><code>public int nextInt(int n)</code>：返回一个伪随机数，范围在 0 （包括）和 指定值 n （不包括）之间的 </p>
<p>int 值。 </p>
</li>
</ul>
<h5 id="示例-1-生成随机数"><a href="#示例-1-生成随机数" class="headerlink" title="示例 1.生成随机数"></a>示例 1.生成随机数</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zmjaction.demo01;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Random类用来生成随机数字。使用起来也是三个步骤：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 导包</span></span><br><span class="line"><span class="comment">import java.util.Random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 创建</span></span><br><span class="line"><span class="comment">Random r = new Random(); // 小括号当中留空即可</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. 使用</span></span><br><span class="line"><span class="comment">获取一个随机的int数字（范围是int所有范围，有正负两种）：int num = r.nextInt()</span></span><br><span class="line"><span class="comment">获取一个随机的int数字（参数代表了范围，左闭右开区间）：int num = r.nextInt(3)</span></span><br><span class="line"><span class="comment">实际上代表的含义是：[0,3)，也就是0~2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Random</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> num = r.nextInt(<span class="number">10</span>);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zmjaction.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目要求：</span></span><br><span class="line"><span class="comment">根据int变量n的值，来获取随机数字，范围是[1,n]，可以取到1也可以取到n。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1. 定义一个int变量n，随意赋值</span></span><br><span class="line"><span class="comment">2. 要使用Random：三个步骤，导包、创建、使用</span></span><br><span class="line"><span class="comment">3. 如果写10，那么就是0~9，然而想要的是1~10，可以发现：整体+1即可。</span></span><br><span class="line"><span class="comment">4. 打印随机数字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Random</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 本来范围是[0,n)，整体+1之后变成了[1,n+1)，也就是[1,n]</span></span><br><span class="line">            <span class="keyword">int</span> result = r.nextInt(n) + <span class="number">1</span>;</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zmjaction.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目：</span></span><br><span class="line"><span class="comment">用代码模拟猜数字的小游戏。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1. 首先需要产生一个随机数字，并且一旦产生不再变化。用Random的nextInt方法</span></span><br><span class="line"><span class="comment">2. 需要键盘输入，所以用到了Scanner</span></span><br><span class="line"><span class="comment">3. 获取键盘输入的数字，用Scanner当中的nextInt方法</span></span><br><span class="line"><span class="comment">4. 已经得到了两个数字，判断（if）一下：</span></span><br><span class="line"><span class="comment">    如果太大了，提示太大，并且重试；</span></span><br><span class="line"><span class="comment">    如果太小了，提示太小，并且重试；</span></span><br><span class="line"><span class="comment">    如果猜中了，游戏结束。</span></span><br><span class="line"><span class="comment">5. 重试就是再来一次，循环次数不确定，用while(true)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03RandomGame</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> randomNum = r.nextInt(<span class="number">100</span>) + <span class="number">1</span>; <span class="comment">// [1,100]</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"请输入你猜测的数字："</span>);</span><br><span class="line">            <span class="keyword">int</span> guessNum = sc.nextInt(); <span class="comment">// 键盘输入猜测的数字</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (guessNum &gt; randomNum) &#123;</span><br><span class="line">                System.out.println(<span class="string">"太大了，请重试。"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (guessNum &lt; randomNum) &#123;</span><br><span class="line">                System.out.println(<span class="string">"太小了，请重试。"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"恭喜你，猜中啦！"</span>);</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 如果猜中，不再重试</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"游戏结束。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
        <category>Random</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Random</tag>
      </tags>
  </entry>
  <entry>
    <title>java-- 继承-- 抽象类</title>
    <url>/2018/10/14/java-%E7%BB%A7%E6%89%BF-%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
    <content><![CDATA[<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><blockquote>
<p>Java只支持单继承，不支持多继承。</p>
<p>顶层父类是Object类。所有的类默认继承Object，作为父类。</p>
<p>继承：就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接 </p>
<p>访问父类中的非私有的属性和行为</p>
<p>好处：</p>
<ol>
<li>提高代码的复用性。 </li>
</ol>
<ol>
<li>类与类之间产生了关系，是多态的前提。</li>
</ol>
</blockquote>
<h5 id="通过-extends-关键字，可以声明一个子类继承另外一个父类"><a href="#通过-extends-关键字，可以声明一个子类继承另外一个父类" class="headerlink" title="通过 extends 关键字，可以声明一个子类继承另外一个父类"></a>通过 <code>extends</code> 关键字，可以声明一个子类继承另外一个父类</h5><p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"去工作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public void work()&#123;</span></span><br><span class="line"><span class="comment">//        System.out.println("老师去工作");</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Teacher th = <span class="keyword">new</span> Teacher();</span><br><span class="line">        th.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="继承之后-成员变量重名、不重名"><a href="#继承之后-成员变量重名、不重名" class="headerlink" title="继承之后-成员变量重名、不重名"></a>继承之后-成员变量重名、不重名</h4><blockquote>
<p>子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用 <code>super</code>关键字，修饰 父类成员变量，类似于<code>this</code> ;</p>
<p>super.父类成员变量名 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"去工作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"老师去工作"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 子类中访问父类得同名变量</span></span><br><span class="line">        System.out.println(<span class="keyword">super</span>.num);</span><br><span class="line">        <span class="comment">// 子类中访问自己得变量</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">直接通过子类对象访问成员变量：</span></span><br><span class="line"><span class="comment">    等号左边是谁，就优先用谁，没有则向上找。</span></span><br><span class="line"><span class="comment">间接通过成员方法访问成员变量：</span></span><br><span class="line"><span class="comment">    该方法属于谁，就优先用谁，没有则向上找。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Teacher th = <span class="keyword">new</span> Teacher();</span><br><span class="line">        th.work();</span><br><span class="line">        <span class="comment">// 优先子类得</span></span><br><span class="line">        System.out.println(th.num);</span><br><span class="line">        <span class="comment">// 子类中没有查找父类得</span></span><br><span class="line">        System.out.println(th.num1);</span><br><span class="line">        th.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="继承之后-方法重名、不重名"><a href="#继承之后-方法重名、不重名" class="headerlink" title="继承之后-方法重名、不重名"></a>继承之后-方法重名、不重名</h4><blockquote>
<p>重写（Override）<br>概念：在继承关系当中，方法的名称一样，参数列表也一样。</p>
<p>重写（Override）：方法的名称一样，参数列表【也一样】。覆盖、覆写。</p>
<p>重载（Overload）：方法的名称一样，参数列表【不一样】</p>
<p>注意：</p>
<p>子类方法的权限必须【大于等于】父类方法的权限修饰符</p>
<p>public &gt; protected &gt; (default) &gt; private</p>
<p>不是关键字default，而是什么都不写，留空</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃东西"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃骨头"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"汪汪叫"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog dg = <span class="keyword">new</span> Dog();</span><br><span class="line">        <span class="comment">// 不同名得方法直接调用即可</span></span><br><span class="line">        dg.Eat();</span><br><span class="line">        dg.Call();</span><br><span class="line">        <span class="comment">// 覆盖父类中得同名方法</span></span><br><span class="line">        dg.Eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="继承之后-构造方法"><a href="#继承之后-构造方法" class="headerlink" title="继承之后-构造方法"></a>继承之后-构造方法</h4><blockquote>
<p>子类必须调用父类构造方法，不写默认调用super()；写了则用写的指定的super调用，super只能有一个，还必须是第一个。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"父类的无参数构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">Animal</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"父类中的有参构造方法"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//        super();</span></span><br><span class="line">        <span class="keyword">super</span>(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">"子类中构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子类中的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demomain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog dg = <span class="keyword">new</span> Dog();</span><br><span class="line">        dg.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><blockquote>
<p>抽象方法 ： 没有方法体的方法。 </p>
<p>抽象类：包含抽象方法的类。 </p>
<ol>
<li><p>抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。</p>
</li>
<li><p>抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。</p>
</li>
<li><p>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类</p>
</li>
<li><p>抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象 </p>
<p>类</p>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"猫吃鱼"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Cat ct = <span class="keyword">new</span> Cat();</span><br><span class="line">        ct.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
        <category>继承</category>
        <category>抽象类</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java继承</tag>
        <tag>java抽象类</tag>
      </tags>
  </entry>
  <entry>
    <title>java-- Math类</title>
    <url>/2018/10/13/java-Math/</url>
    <content><![CDATA[<h5 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h5><p><code>java.lang.Math</code> 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具 </p>
<p>类，其所有方法均为静态方法，并且不会创建对象</p>
<h5 id="运算方法"><a href="#运算方法" class="headerlink" title="运算方法"></a>运算方法</h5><ul>
<li><code>public static double abs(double a)</code> ：返回 double 值的绝对值。</li>
<li><code>public static double ceil(double a)</code> ：返回大于等于参数的最小的整数。 </li>
<li><code>public static double floor(double a)</code> ：返回小于等于参数最大的整数。 </li>
<li><code>public static long round(double a)</code> ：返回最接近参数的 long。(相当于四舍五入方法) </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demoMath</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取绝对值</span></span><br><span class="line">        System.out.println(Math.abs(<span class="number">3.14</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向上取整</span></span><br><span class="line">        System.out.println(Math.ceil(<span class="number">3.9</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向下取整</span></span><br><span class="line">        System.out.println(Math.floor(<span class="number">3.9</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 四舍五入</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">3.5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
        <category>Math</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>java-- 基本数据类型</title>
    <url>/2018/10/10/java-basic-data-type/</url>
    <content><![CDATA[<h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><div class="table-container">
<table>
<thead>
<tr>
<th>数据类型</th>
<th>大小（bit)</th>
<th>范围</th>
<th>默认值</th>
<th>包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte(字节)</td>
<td>8</td>
<td>-128 - 127</td>
<td>0</td>
<td>Byte</td>
</tr>
<tr>
<td>short(短整型)</td>
<td>16</td>
<td>-32768~32767</td>
<td>0</td>
<td>Short</td>
</tr>
<tr>
<td>int(整型)</td>
<td>32</td>
<td>-2^31 ~ 2^31 -1</td>
<td>0</td>
<td>Integer</td>
</tr>
<tr>
<td>long(长整型)</td>
<td>64</td>
<td>-2^63 ~ 2^63 -1</td>
<td>0L</td>
<td>Long</td>
</tr>
<tr>
<td>float(浮点型)</td>
<td>32</td>
<td>1.4013E-45~3.4028E+38</td>
<td>0.0f</td>
<td>Float</td>
</tr>
<tr>
<td>double(双精度)</td>
<td>64</td>
<td>4.9E-324~1.7977E+308</td>
<td>0.0d</td>
<td>Double</td>
</tr>
<tr>
<td>char(字符型)</td>
<td>16</td>
<td>0-65535 / <code>\u0000~ \uffff</code></td>
<td>‘u0000’</td>
<td>Character</td>
</tr>
<tr>
<td>boolean(布尔型)</td>
<td>1</td>
<td>true/false</td>
<td>false</td>
<td>Boolean</td>
</tr>
</tbody>
</table>
</div>
<h4 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h4><p>范围小的类型向范围大的类型提升，<code>byte、short、char</code> 运算时直接提升为 <code>int</code>。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">byte、short、char‐‐&gt;int‐‐&gt;long‐‐&gt;float‐‐&gt;double</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://www.runoob.com/java/java-basic-datatypes.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-basic-datatypes.html</a></p>
]]></content>
      <categories>
        <category>java</category>
        <category>基本数据类型</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基本数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka-LEO-HW</title>
    <url>/2020/06/08/kafka-LEO-HW/</url>
    <content><![CDATA[<p>LEO(log end offset) 和HW(Hight watemark)概念 简单解释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个分区有3个副本，一个leader，2个follower。producer向leader写了10条消息，follower1从leader处拷贝了5条消息，follower2从leader处拷贝了3条消息，那么leader副本的LEO就是10，HW&#x3D;3；follower1副本的LEO是5</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Kafka -- 集群参数</title>
    <url>/2019/07/19/kafka-cluster-param-%E9%9B%86%E7%BE%A4%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h2 id="Broker参数"><a href="#Broker参数" class="headerlink" title="Broker参数"></a>Broker参数</h2><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><ol>
<li>log.dir：表示<strong>单个</strong>路径</li>
<li>log.dirs：表示<strong>多个</strong>路径，<strong>推荐使用</strong><ul>
<li><code>/home/kafka1,/home/kafka2,/home/kafka3</code></li>
<li>线上生产环境中一定要为log.dirs配置多个路径，格式为<strong>CSV</strong>，<strong>逗号分隔</strong></li>
<li>建议把不同的路径<strong>挂载</strong>到不同的<strong>物理磁盘</strong>上<ul>
<li><strong>提升读写性能</strong>，比起单块硬盘，多块物理磁盘同时读写数据有<strong>更高的吞吐量</strong></li>
<li>能够实现<strong>故障转移</strong>（Failover），从Kafka 1.1引入，坏掉的磁盘上的数据会自动地转移到其他正常的磁盘上</li>
</ul>
</li>
</ul>
</li>
</ol>
<a id="more"></a>
<h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><ol>
<li>Zookeeper是一个<strong>分布式协调框架</strong>，负责协调管理并保存<strong>Kafka集群的所有元数据信息</strong><ul>
<li>集群有哪些Broker在运行，创建了哪些Topic，每个Topic有多少分区、分区的Leader副本在哪些机器上</li>
</ul>
</li>
<li>zookeeper.connect，CSV格式，<code>zk1:2181,zk2:2181,zk3:2181</code></li>
<li>Zookeeper地chroot，只需写<strong>一次</strong>，<code>zk1:2181,zk2:2181,zk3:2181/kafka1</code>和<code>zk1:2181,zk2:2181,zk3:2181/kafka2</code></li>
</ol>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><ol>
<li><code>listeners</code><ul>
<li>监听器，告知外部连接者通过什么协议来访问指定主机名和端口开放的Kafka服务</li>
<li>逗号分隔的三元组，格式：<code>&lt;协议名称，主机名，端口号&gt;</code><ul>
<li>协议名称可能是标准的名字，如PLAINTEXT表示明文传输，SSL表示使用SSL或者TLS加密传输</li>
<li>协议名称也可能是自定义的，如<code>CONTROLLER://localhost:9092</code><ul>
<li>如果使用自定义的协议名称，需要通过<code>listener.security.protocol.map</code>来说明底层使用的<strong>安全协议</strong></li>
<li>listener.security.protocol.map=CONTROLLER:PLAINTEXT</li>
</ul>
</li>
<li><strong>主机名推荐使用域名，而非IP</strong></li>
</ul>
</li>
</ul>
</li>
<li><code>advertised.listeners</code><ul>
<li>对外发布的监听器</li>
</ul>
</li>
<li><code>host.name/port</code><ul>
<li>已过期参数，无需设置</li>
</ul>
</li>
</ol>
<h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><ol>
<li><code>auto.create.topics.enable</code><ul>
<li>是否允许自动创建Topic，建议设置为<strong>false</strong></li>
<li>在线上环境，每个部门被分配的Topic应该由运维部门严格把控</li>
</ul>
</li>
<li><code>unclean.leader.election.enable</code><ul>
<li>是否允许Unclean Leader选举，建议设置为<strong>false</strong></li>
<li>Kafka的分区有多个副本，这些副本中只能有一个副本对外提供服务，即<strong>Leader副本</strong></li>
<li>并不是所有副本都有资格竞选Leader，<em><strong>只有保存数据比较多的副本才有资格竞选Leader</strong></em></li>
<li>如果保存数据比较多的副本挂了，该参数发挥作用<ul>
<li>设置为false，坚决不让落后太多的副本竞选Leader，后果就是这个<strong>分区不可用</strong>了，因为没有Leader</li>
<li>设置为true，允许从落后太多的副本中选举出一个Leader，后果就是<strong>数据有可能丢失</strong></li>
</ul>
</li>
</ul>
</li>
<li><code>auto.leader.rebalance.enable</code><ul>
<li>是否允许<strong>定期</strong>进行Leader选举，建议设置为<strong>false</strong></li>
<li>与上一参数最大的不同是，它不是选Leader，而是<em><strong>换Leader</strong></em></li>
<li>换Leader的<strong>代价很高</strong>，并且本质上<strong>没有任何性能收益</strong><ul>
<li>原本向A发送请求的所有客户端都要切换成向B发送请求</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="数据留存"><a href="#数据留存" class="headerlink" title="数据留存"></a>数据留存</h3><ol>
<li><code>log.retention.{hours|minutes|ms}</code><ul>
<li>控制<strong>一条消息</strong>可以被保存多长时间，优先级：ms &gt; minutes &gt; hours，推荐使用<strong>hours</strong></li>
</ul>
</li>
<li><code>log.retention.bytes</code><ul>
<li>指定Broker为消息保存的<strong>总磁盘容量大小</strong>，默认值为<strong>-1</strong>，表示<strong>不限制</strong></li>
<li>应用场景：在云上构建多租户的Kafka集群，每个租户只能使用100GB的磁盘空间，避免租户恶意使用过多的磁盘空间</li>
</ul>
</li>
<li><code>message.max.bytes</code><ul>
<li>控制Broker能够接收的<strong>最大消息大小</strong></li>
<li>默认值为1000012，小于1MB，实际场景中，消息突破1MB的场景很常见，所以线上环境一般会设置一个比较大的值</li>
</ul>
</li>
</ol>
<h2 id="Topic参数"><a href="#Topic参数" class="headerlink" title="Topic参数"></a>Topic参数</h2><p>如果同时设置了Topic级别参数和全局Broker参数，Topic级别参数会<strong>覆盖</strong>全局Broker参数的值</p>
<h3 id="数据留存-1"><a href="#数据留存-1" class="headerlink" title="数据留存"></a>数据留存</h3><p><code>retention.ms、retention.bytes、message.max.bytes</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建Topic时进行设置，保存最近半年的交易数据，单个消息很大，但也不会超过5MB</span></span><br><span class="line">$ bin/kafka-configs.sh --bootstrap-server localhost:9092 --create --topic transaction --partitions 1 --replication-factor 1 --config retention.ms=15552000000 --config max.message.bytes=5242880</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改Topic级别参数，将消息的最大大小修改为10MB</span></span><br><span class="line"><span class="comment"># 推荐使用kafka-configs，社区未来很有可能统一使用kafka-configs来调整Topic级别参数</span></span><br><span class="line">$ bin/kafka-configs.sh --zookeeper localhost:2181 --entity-type topics --entity-name transaction --alter --add-config max.message.bytes=10485760</span><br></pre></td></tr></table></figure>
<h2 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h2><ol>
<li>Kafka服务端代码是用<strong>Scala</strong>语言编写的，最终要编译成<strong>Class文件</strong>在<strong>JVM</strong>上运行</li>
<li>不推荐将Kafka运行在Java 6或Java 7的环境上，Kafka从<strong>2.0.0</strong>开始，正式摒弃<strong>对Java 7的支持</strong></li>
<li>将JVM的堆大小设置为<strong>6GB</strong>，这是业界比较公认的合理值，默认的1GB太小<ul>
<li>Kafka Broker在与客户端交互时，会在JVM堆上创建大量的<strong>ByteBuffer</strong>实例</li>
</ul>
</li>
<li>垃圾收集器<ul>
<li>Java 7<ul>
<li>如果Broker所在机器的<strong>CPU资源非常充裕</strong>，建议使用<strong>CMS收集器</strong>，-XX:+UseCurrentMarkSweepGC</li>
<li>否则使用<strong>吞吐量收集器</strong>，-XX:+UseParallelGC</li>
</ul>
</li>
<li>Java 8<ul>
<li>使用<strong>G1收集器</strong>，在没有任何调优的情况下，<strong>G1的表现要优于CMS</strong></li>
<li>主要体现在<strong>更少的Full GC</strong>，<strong>更少的调整参数</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> KAFKA_HEAP_OPTS=--Xms6g  --Xmx6g</span><br><span class="line">$ <span class="built_in">export</span> KAFKA_JVM_PERFORMANCE_OPTS= -server -XX:+UseG1GC -XX:MaxGCPauseMillis=20 -XX:InitiatingHeapOccupancyPercent=35 -XX:+ExplicitGCInvokesConcurrent -Djava.awt.headless=<span class="literal">true</span></span><br><span class="line">$ kafka-server-start config/server.properties</span><br></pre></td></tr></table></figure>
<h2 id="OS参数"><a href="#OS参数" class="headerlink" title="OS参数"></a>OS参数</h2><ol>
<li>文件描述符限制<ul>
<li><code>ulimit -n</code>，文件描述符系统资源<strong>并没有很昂贵</strong>，设置成一个很大的值也是合理的</li>
</ul>
</li>
<li>文件系统类型<ul>
<li><strong>日志型文件系统</strong>：ext3、ext4、XFS，<strong>XFS的性能强于ext4</strong>，所以生产环境最好使用<strong>XFS</strong></li>
</ul>
</li>
<li>Swappiness<ul>
<li>不建议将Swap空间设置为0<ul>
<li>因为一旦设置为0，当物理内存耗尽时，操作系统会触发<strong>OOM Killer</strong></li>
<li>OOM Killer会<strong>随机</strong>挑选一个进程然后kill掉，<strong>不会给出任何预警</strong></li>
</ul>
</li>
<li>可以将Swap空间设置为很小的值，例如1<ul>
<li>当开始使用Swap空间时，至少能够观测到Broker<strong>性能急剧下降</strong>，留有<strong>调优</strong>和<strong>诊断</strong>问题的时间</li>
</ul>
</li>
</ul>
</li>
<li>Flush落盘时间<ul>
<li>向Kafka发送数据并不需要等到数据被写入磁盘才会认为成功，只需被写入到操作系统的<strong>页缓存</strong>（Page Cache）即可</li>
<li>随后操作系统根据<strong>LRU算法</strong>会<strong>定期</strong>将页缓存上的<strong>脏数据</strong>落盘到物理磁盘上</li>
<li>Flush落盘时间默认是<strong>5秒</strong>，如果页缓存中的数据在写入到磁盘之前，机器宕机了，会造成<strong>数据丢失</strong></li>
<li>但Kafka在<strong>软件层面</strong>已经提供了<strong>多副本的冗余机制</strong>，因此<strong>适当地调大</strong>Flush落盘时间是个合理的做法</li>
</ul>
</li>
</ol>
<p>转载：<a href="http://zhongmingmao.me/2019/07/19/kafka-cluster-param/" target="_blank" rel="noopener">http://zhongmingmao.me/2019/07/19/kafka-cluster-param/</a></p>
]]></content>
      <categories>
        <category>Middleware</category>
        <category>MQ</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Middleware</tag>
        <tag>MQ</tag>
        <tag>Kafka</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka -- KafkaAdminClient</title>
    <url>/2019/09/28/kafka-admin-client/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ol>
<li>命令行脚本只能运行在控制台上，在应用程序、运维框架或者监控平台中集成它们，会非常困难</li>
<li>很多命令行脚本都是通过连接<strong>ZK</strong>来提供服务的，这会存在潜在的问题，即绕过Kafka的安全设置</li>
<li>运行这些命令行脚本需要使用Kafka内部的类实现，也就是Kafka<strong>服务端</strong>的代码<ul>
<li>社区是希望用户使用Kafka<strong>客户端</strong>代码，通过<strong>现有的请求机制</strong>来运维管理集群</li>
</ul>
</li>
<li>基于上述原因，社区于<strong>0.11</strong>版本正式推出<strong>Java客户端版的KafkaAdminClient</strong></li>
</ol>
<a id="more"></a>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ol>
<li><strong>主题管理</strong><ul>
<li>主题的创建、删除、查询</li>
</ul>
</li>
<li><strong>权限管理</strong><ul>
<li>具体权限的配置和删除</li>
</ul>
</li>
<li><strong>配置参数管理</strong><ul>
<li>Kafka各种资源（Broker、主题、用户、Client-Id等）的参数设置、查询</li>
</ul>
</li>
<li><strong>副本日志管理</strong><ul>
<li>副本底层日志路径的变更和详情查询</li>
</ul>
</li>
<li><strong>分区管理</strong><ul>
<li>创建额外的主题分区</li>
</ul>
</li>
<li><strong>消息删除</strong><ul>
<li>删除指定位移之前的分区消息</li>
</ul>
</li>
<li><strong>Delegation Token管理</strong><ul>
<li>Delegation Token的创建、更新、过期、查询</li>
</ul>
</li>
<li><strong>消费者组管理</strong><ul>
<li>消费者组的查询、位移查询和删除</li>
</ul>
</li>
<li><strong>Preferred领导者选举</strong><ul>
<li>推选指定主题分区的Preferred Broker为领导者</li>
</ul>
</li>
</ol>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-admin-client.png" width=1000/></p>
<ol>
<li>KafkaAdminClient是<strong>双线程</strong>设计<ul>
<li><strong>前端主线程</strong><ul>
<li>负责将用户要执行的<strong>操作</strong>转换成对应的<strong>请求</strong>，然后将请求发送到后端IO线程的队列中</li>
</ul>
</li>
<li><strong>后端IO线程</strong><ul>
<li>从队列中读取相应的请求，再发送到对应的Broker节点上，之后把执行结果保存起来，等待前端线程的获取</li>
</ul>
</li>
</ul>
</li>
<li>KafkaAdminClient在内部大量使用<strong>生产者-消费者</strong>模式将请求生成和处理解耦</li>
<li>前端主线程会创建名为<strong>Call</strong>的请求对象实例，该实例有两个主要任务<ul>
<li><strong>构建对应的请求对象</strong><ul>
<li>创建主题：CreateTopicsRequest</li>
<li>查询消费者组位移：OffsetFetchRequest</li>
</ul>
</li>
<li><strong>指定响应的回调逻辑</strong><ul>
<li>比如从Broker端接收到CreateTopicsResponse之后要执行的动作</li>
</ul>
</li>
</ul>
</li>
<li>后端IO线程使用了3个队列来承载不同时期的请求对象，分别为<strong>新请求队列</strong>、<strong>待发送请求队列</strong>和<strong>处理中请求队列</strong><ul>
<li>原因：<strong>新请求队列的线程安全</strong>是由Java的<strong>Monitor锁</strong>来保证的<ul>
<li>为了保证前端线程不会因为Monitor锁被<strong>阻塞</strong>，后端IO线程会<strong>定期</strong>地将<strong>新请求队列</strong>中的<strong>所有Call实例</strong>全部搬移到<strong>待发送请求队列</strong>中进行处理</li>
</ul>
</li>
<li><strong>待发送请求队列</strong>和<strong>处理中请求队列</strong>只由<strong>后端IO线程</strong>处理，因为<strong>无需任何锁机制来保证线程安全</strong></li>
<li>当后端IO线程在处理某个请求时，会<strong>显式</strong>地将请求保存在<strong>处理中请求队列</strong><ul>
<li>一旦<strong>处理完毕</strong>，后端IO线程会自动调用Call对象中的<strong>回调逻辑</strong>完成最后的处理</li>
</ul>
</li>
<li>最后，后端IO线程会通知前端主线程说结果已经准备完毕，这样前端主线程就能够及时获取到执行操作的结果<ul>
<li>KafkaAdminClient是使用了Object的<strong>wait</strong>和<strong>notify</strong>来实现<strong>通知</strong>机制</li>
</ul>
</li>
<li>KafkaAdminClient并没有使用Java已有的队列去实现请求队列<ul>
<li>而是使用<strong>ArrayList</strong>和<strong>HashMap</strong>等简单容器，再配合<strong>Monitor锁</strong>来保证线程安全</li>
</ul>
</li>
<li>后端线程名称：<strong><code>kafka-admin-client-thread</code></strong>，可以用<strong><code>jstack</code></strong>去确认程序是否正常工作<ul>
<li>后端IO线程可能由于<strong>未捕获某些异常</strong>而意外挂掉</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="创建主题"><a href="#创建主题" class="headerlink" title="创建主题"></a>创建主题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">"localhost:9092"</span>);</span><br><span class="line">props.put(<span class="string">"request.timeout.ms"</span>, <span class="number">600000</span>);</span><br><span class="line">String newTopicName = <span class="string">"test-topic"</span>;</span><br><span class="line"><span class="keyword">try</span> (AdminClient client = AdminClient.create(props)) &#123;</span><br><span class="line">    NewTopic newTopic = <span class="keyword">new</span> NewTopic(newTopicName, <span class="number">10</span>, (<span class="keyword">short</span>) <span class="number">1</span>);</span><br><span class="line">    CreateTopicsResult result = client.createTopics(Collections.singletonList(newTopic));</span><br><span class="line">    result.all().get(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询消费者组位移"><a href="#查询消费者组位移" class="headerlink" title="查询消费者组位移"></a>查询消费者组位移</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String groupId = <span class="string">"zhongmingmao"</span>;</span><br><span class="line"><span class="keyword">try</span> (AdminClient client = AdminClient.create(props)) &#123;</span><br><span class="line">    ListConsumerGroupOffsetsResult result = client.listConsumerGroupOffsets(groupId);</span><br><span class="line">    Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets = result.partitionsToOffsetAndMetadata().get(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    System.out.println(offsets);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取Broker磁盘占用"><a href="#获取Broker磁盘占用" class="headerlink" title="获取Broker磁盘占用"></a>获取Broker磁盘占用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (AdminClient client = AdminClient.create(props)) &#123;</span><br><span class="line">    <span class="comment">// 获取指定Broker上所有分区主题的日志路径信息</span></span><br><span class="line">    DescribeLogDirsResult ret = client.describeLogDirs(Collections.singletonList(<span class="number">0</span>)); <span class="comment">// 指定Broker id</span></span><br><span class="line">    <span class="keyword">long</span> size = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map&lt;String, DescribeLogDirsResponse.LogDirInfo&gt; logDirInfoMap : ret.all().get().values()) &#123;</span><br><span class="line">        size += logDirInfoMap.values().stream().map(logDirInfo -&gt; logDirInfo.replicaInfos).flatMap(</span><br><span class="line">                topicPartitionReplicaInfoMap -&gt;</span><br><span class="line">                        topicPartitionReplicaInfoMap.values().stream().map(replicaInfo -&gt; replicaInfo.size))</span><br><span class="line">                .mapToLong(Long::longValue).sum();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(size); <span class="comment">// 264599218</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考：<a href="http://zhongmingmao.me" target="_blank" rel="noopener">http://zhongmingmao.me</a></p>
]]></content>
      <categories>
        <category>Middleware</category>
        <category>MQ</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Middleware</tag>
        <tag>MQ</tag>
        <tag>Kafka</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka -- 避免重平衡</title>
    <url>/2019/09/01/kafka-avoid-rebalance/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol>
<li>Rebalance是让Consumer Group下所有的Consumer实例<strong>就如何消费订阅主题的所有分区达成共识</strong>的过程</li>
<li>在Rebalance过程中，<strong>所有Consumer实例共同参与</strong>，在<strong>协调者</strong>组件的帮助下，完成<strong>订阅主题分区的分配</strong></li>
<li>整个Rebalance过程中，所有Consumer实例都<strong>不能消费任何消息</strong>，因此对Consumer的<strong>TPS</strong>影响很大</li>
</ol>
<a id="more"></a>
<h2 id="协调者"><a href="#协调者" class="headerlink" title="协调者"></a>协调者</h2><ol>
<li>协调者，即<strong>Coordinator</strong>，负责为Consumer Group执行<strong>Rebalance</strong>以及提供<strong>位移管理</strong>和<strong>组成员管理</strong>等</li>
<li>Consumer端应用程序在提交位移时，其实是向<strong>Coordinator所在的Broker提交位移</strong></li>
<li>Consumer应用启动时，也是向Coordinator所在的Broker发送各种请求<ul>
<li>然后由Coordinator负责执行<strong>消费组的注册</strong>、<strong>成员管理记录</strong>等<strong>元数据管理</strong>操作</li>
</ul>
</li>
<li>所有Broker在启动时，都会创建和开启相应的Coordinator组件，<strong>所有Broker都有各自的Coordinator组件</strong></li>
<li>内部位移主题<code>__consumer_offsets</code>记录了<strong>为Consumer Group服务的Coordinator在哪一台Broker上</strong></li>
<li>为某个Consumer Group确定Coordinator所在的Broker，有两个步骤<ul>
<li>确定由<strong>位移主题的哪个分区</strong>来保存该Consumer Group数据<ul>
<li><code>partitionId = Math.abs(groupId.hashCode() % offsetsTopicPartitionCount</code></li>
<li>offsetsTopicPartitionCount默认为<strong>50</strong></li>
</ul>
</li>
<li>找出该分区<strong>Leader</strong>副本所在的Broker，该Broker即为对应的Coordinator</li>
</ul>
</li>
</ol>
<h2 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h2><ol>
<li>Rebalance<strong>影响Consumer端TPS</strong></li>
<li>Rebalance<strong>很慢</strong></li>
<li>Rebalance<strong>效率不高</strong><ul>
<li>每次Rebalance，Consumer Group下<strong>所有成员</strong>都需要参与，而且<strong>不考虑局部性原理</strong>，<em><strong>之前的分配方案都不会被保留</strong></em></li>
<li>为了解决这个问题，社区于0.11.0.0版本推出<strong>StickyAssignor</strong>，即<strong>粘性</strong>的分区分配策略<ul>
<li>粘性指的是每次Rebalance，都<strong>尽可能地保留之前的分配方案</strong>，尽量实现分区分配的<strong>最小改动</strong></li>
<li>但该策略存在一些<strong>Bug</strong>，而且需要升级到0.11.0.0才能使用，实际生产环境中<strong>用得不多</strong></li>
</ul>
</li>
</ul>
</li>
<li>影响Consumer端TPS + 慢属于<strong>无解</strong>，因此尽量<em><strong>减少不必要的Rebalance</strong></em></li>
</ol>
<h2 id="发生时机"><a href="#发生时机" class="headerlink" title="发生时机"></a>发生时机</h2><ol>
<li><strong>组成员数量</strong>发生变化 — 最常见<ul>
<li>Consumer实例增加：一般是基于<strong>增加TPS</strong>或者<strong>提高伸缩性</strong>的需要，属于<strong>计划内</strong>的操作，<strong>不属于不必要的Rebalance</strong></li>
<li>Consumer实例<strong>减少</strong>：在某些情况下Consumer实例会被Coordinator<strong>错误</strong>地认为已停止而被踢出Consumer Group</li>
</ul>
</li>
<li><strong>订阅主题数量</strong>发生变化<ul>
<li>一般是<strong>运维主动操作</strong>，很难避免</li>
</ul>
</li>
<li><strong>订阅主题的分区数量</strong>发生变化<ul>
<li>一般是<strong>运维主动操作</strong>，很难避免</li>
</ul>
</li>
</ol>
<h2 id="实例减少"><a href="#实例减少" class="headerlink" title="实例减少"></a>实例减少</h2><h3 id="Consumer端参数"><a href="#Consumer端参数" class="headerlink" title="Consumer端参数"></a>Consumer端参数</h3><ol>
<li>当Consumer Group完成Rebalance后，每个Consumer实例都会<strong>定期</strong>地向<strong>Coordinator</strong>发送<strong>心跳</strong></li>
<li>如果某个Consumer实例不能及时地发送心跳<ul>
<li>Coordinator会认为该Consumer已死，并将其从Consumer Group中移除，开启新一轮的Rebalance</li>
</ul>
</li>
<li>Consumer端有一个参数<code>session.timeout.ms</code>，默认值为<strong>10秒</strong><ul>
<li>如果Coordinator在10秒内没有收到Consumer Group下某个Consumer实例的心跳，就会认为该Consumer已死</li>
</ul>
</li>
<li>Consumer端还有另一个参数<code>heartbeat.interval.ms</code>，默认值为<strong>3秒</strong><ul>
<li>设置得越小，Consumer实例发送心跳的频率就会越高，会额外消耗<strong>带宽资源</strong>，但能更快地知道是否开启Rebalance</li>
<li>Coordinator通过将<strong>REBALANCE_NEEDED标志</strong>封装进<strong>心跳响应</strong>中，来通知Consumer实例开启Rebalance</li>
</ul>
</li>
<li>Consumer端还有另一个参数<code>max.poll.interval.ms</code>，默认值为<strong>5分钟</strong><ul>
<li>该参数用于控制Consumer<strong>实际消费能力</strong>对Rebalance的影响，限定了Consumer端两次调用<strong>poll</strong>方法的最大时间间隔</li>
<li>Consumer如果在5分钟内<strong>无法消费完</strong>poll方法返回的消息，就会<strong>主动发起离开组的请求</strong>，开启新一轮的Rebalance</li>
</ul>
</li>
</ol>
<h3 id="非必要的Rebalance"><a href="#非必要的Rebalance" class="headerlink" title="非必要的Rebalance"></a>非必要的Rebalance</h3><ol>
<li>Consumer<strong>未及时发送心跳</strong>，导致被踢出Consumer Group而引发的Rebalance<ul>
<li>生产配置：<code>session.timeout.ms=6000</code> + <code>heartbeat.interval.ms=2000</code><ul>
<li><code>session.timeout.ms=6000</code>：为了让Coordinator能够更快地定位已经挂掉的Consumer</li>
</ul>
</li>
<li><code>session.timeout.ms &gt; 3 * heartbeat.interval.ms</code></li>
</ul>
</li>
<li>Consumer<strong>消费时间过长</strong>，主动发起离开组的请求而引发的Rebalance<ul>
<li>如果消费逻辑很重（如DB操作），可以将<code>max.poll.interval.ms</code>设置得大一点</li>
</ul>
</li>
<li>关注Consumer端的<strong>GC</strong>表现，频繁的<strong>Full GC</strong>会引起<strong>非预期的Rebalance</strong></li>
</ol>
<p>参考:<a href="http://zhongmingmao.me/2019/09/01/kafka-avoid-rebalance/" target="_blank" rel="noopener">http://zhongmingmao.me/2019/09/01/kafka-avoid-rebalance/</a></p>
]]></content>
      <categories>
        <category>Middleware</category>
        <category>MQ</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Middleware</tag>
        <tag>MQ</tag>
        <tag>Kafka</tag>
        <tag>Stream</tag>
        <tag>Rebalance</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka -- CommitFailedException</title>
    <url>/2019/09/06/kafka-commit-failed-exception/</url>
    <content><![CDATA[<h2 id="CommitFailedException"><a href="#CommitFailedException" class="headerlink" title="CommitFailedException"></a>CommitFailedException</h2><ol>
<li>CommitFailedException是Consumer客户端在<strong>提交位移</strong>时出现的<strong>不可恢复</strong>的严重异常</li>
<li>如果异常是<strong>可恢复的瞬时错误</strong>，提交位移的API方法是支持<strong>自动错误重试</strong>的，如<strong>commitSync</strong>方法</li>
</ol>
<a id="more"></a>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><blockquote>
<p>Commit cannot be completed since the <strong>group has already rebalanced and assigned the partitions to another member</strong>. This means that the time between subsequent calls to poll() was longer than the configured max.poll.interval.ms, which typically implies that the poll loop is spending too much time message processing. You can address this either by <strong>increasing</strong> the <strong>max.poll.interval.ms</strong> or by <strong>reducing</strong> the maximum size of batches returned in poll() with <strong>max.poll.records</strong>.</p>
</blockquote>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><h3 id="场景1"><a href="#场景1" class="headerlink" title="场景1"></a>场景1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.put(<span class="string">"max.poll.interval.ms"</span>, <span class="number">5000</span>);</span><br><span class="line">consumer.subscribe(Arrays.asList(<span class="string">"test-topic"</span>));</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">    Thread.sleep(<span class="number">6000L</span>);</span><br><span class="line">    consumer.commitSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>消息处理的总时间超过预设的<code>max.poll.interval.ms</code></strong>时，Consumer端会抛出CommitFailedException</li>
<li>解决方案<ul>
<li><strong>缩短单条消息处理的时间</strong></li>
<li><strong>增加<code>max.poll.interval.ms</code></strong><ul>
<li>使用<strong>0.10.1.0</strong>之前的客户端API，需要使用<code>session.timeout.ms</code>参数</li>
<li><code>session.timeout.ms</code>还有其他含义，<code>max.poll.interval.ms</code>是从<code>session.timeout.ms</code>剥离出来的参数</li>
</ul>
</li>
<li><strong>减少<code>max.poll.records</code></strong></li>
<li><strong>使用多线程来加速消费</strong><ul>
<li>多线程如何<strong>提交位移</strong>是很容易出错的</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="场景2"><a href="#场景2" class="headerlink" title="场景2"></a>场景2</h3><ol>
<li>Kafka Java Consumer端提供了一个名为<strong>Standalone Consumer</strong>的独立消费者<ul>
<li>它<strong>没有消费者组的概念</strong>，每个独立消费者实例都<strong>独立工作</strong>，彼此之间毫无联系</li>
</ul>
</li>
<li>独立消费者的<strong>位移提交机制</strong>和消费者组是<strong>一样</strong>的，也<strong>必须指定group.id</strong>才能提交位移</li>
<li>如果同时出现了设置<strong>相同group.id</strong>的<strong>消费者组</strong>程序和<strong>独立消费者</strong>程序<ul>
<li>当<strong>独立消费者</strong>程序<strong>手动提交位移</strong>时，会抛出CommitFailedException，表明它不是消费者组内<strong>合法</strong>的成员</li>
</ul>
</li>
</ol>
<p>参考：<a href="http://zhongmingmao.me/2019/09/06/kafka-commit-failed-exception/" target="_blank" rel="noopener">http://zhongmingmao.me/2019/09/06/kafka-commit-failed-exception/</a></p>
]]></content>
      <categories>
        <category>Middleware</category>
        <category>MQ</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Middleware</tag>
        <tag>MQ</tag>
        <tag>Kafka</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka -- 提交位移</title>
    <url>/2019/09/03/kafka-commit-offset/</url>
    <content><![CDATA[<h2 id="消费位移"><a href="#消费位移" class="headerlink" title="消费位移"></a>消费位移</h2><ol>
<li>Consumer的<strong>消费位移</strong>，记录了Consumer要消费的<strong>下一条消息</strong>的位移</li>
<li>假设一个分区中有10条消息，位移分别为0到9<ul>
<li>某个Consumer消费了5条消息，实际消费了位移0到4的5条消息，此时Consumer的位移为5，指向下一条消息的位移</li>
</ul>
</li>
<li>Consumer需要向Kafka汇报自己的位移数据，这个汇报过程就是<strong>提交位移</strong><ul>
<li>Consumer能够<strong>同时消费多个分区</strong>的数据，所以位移的提交实际上是在<strong>分区粒度</strong>上进行的</li>
<li><em><strong>Consumer需要为分配给它的每个分区提交各自的位移数据</strong></em></li>
</ul>
</li>
<li>提交位移主要是为了<strong>表征Consumer的消费进度</strong><ul>
<li>当Consumer发生故障重启后，能够从Kafka中读取之前提交的位移值，然后从相应的位移处<strong>继续消费</strong></li>
</ul>
</li>
<li>位移提交的<strong>语义</strong><ul>
<li>如果提交了位移X，那么Kafka会认为位移值<strong>小于</strong>X的消息都已经被<strong>成功消费</strong>了</li>
</ul>
</li>
</ol>
<a id="more"></a>
<h2 id="灵活"><a href="#灵活" class="headerlink" title="灵活"></a>灵活</h2><ol>
<li>位移提交非常灵活，可以提交<strong>任何位移值</strong>，但要承担相应的后果</li>
<li>假设Consumer消费了位移为0~9的10条消息<ul>
<li>如果提交的位移为20，位移位于10~19的消息可能会<strong>丢失</strong></li>
<li>如果提交的位移为5，位移位于5~9的消息可能会被<strong>重复消费</strong></li>
</ul>
</li>
<li>位移提交的语义保障由应用程序保证，Kafka只会<strong>无脑</strong>地接受</li>
<li>位移提交的方式<ul>
<li>从<strong>用户角度</strong>来看，分为<strong>自动提交</strong>和<strong>手动提交</strong></li>
<li>从<strong>Consumer端</strong>来看，分为<strong>同步提交</strong>和<strong>异步提交</strong></li>
</ul>
</li>
</ol>
<h2 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h2><ol>
<li>自动提交：Kafka Consumer在后台默默地提交位移</li>
<li>参数<code>enable.auto.commit</code>，默认值为<strong>true</strong>，启用自动提交</li>
<li>参数<code>auto.commit.interval.ms</code>，默认值为<strong>5秒</strong>，Kafka每5秒会自动提交一次位移</li>
<li>Kafka会保证在开始调用poll方法时，提交<strong>上次</strong>poll返回的所有消息<ul>
<li>poll方法的逻辑：先提交上一批消息的位移，再处理下一批消息，因此能够保证<em><strong>消息不丢失</strong></em></li>
</ul>
</li>
<li>自动提交可能会出现<em><strong>重复消费</strong></em><ul>
<li>Consumer每5秒提交一次位移，若提交位移后3秒发生<strong>Rebalance</strong>，所有Consumer从上次提交的位移处继续消费</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line">props.put(<span class="string">"group.id"</span>, <span class="string">"test"</span>);</span><br><span class="line">props.put(<span class="string">"enable.auto.commit"</span>, <span class="string">"true"</span>);</span><br><span class="line">props.put(<span class="string">"auto.commit.interval.ms"</span>, <span class="string">"2000"</span>);</span><br><span class="line">props.put(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">props.put(<span class="string">"value.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">consumer.subscribe(Arrays.asList(<span class="string">"foo"</span>, <span class="string">"bar"</span>));</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records)</span><br><span class="line">        System.out.printf(<span class="string">"offset = %d, key = %s, value = %s%n"</span>, record.offset(), record.key(), record.value());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="手动提交"><a href="#手动提交" class="headerlink" title="手动提交"></a>手动提交</h2><ol>
<li><code>enable.auto.commit=false</code></li>
<li><code>KafkaConsumer#commitSync()</code><ul>
<li>提交<code>KafkaConsumer#poll()</code>返回的最新位移</li>
<li><strong>同步</strong>操作，一直等待，直到位移被成功提交才会返回</li>
<li>需要处理完poll方法返回的<strong>所有消息</strong>后，才提交位移，否则会出现<strong>消息丢失</strong></li>
<li>Consumer处于<strong>阻塞</strong>状态，直到远端的Broker返回提交结果，才会结束</li>
<li>因为应用程序而非资源限制而导致的阻塞都可能是<strong>系统的瓶颈</strong>，会影响整个应用程序的<strong>TPS</strong></li>
</ul>
</li>
<li><code>KafkaConsumer#commitAsync()</code><ul>
<li><strong>异步</strong>操作，立即返回，不会阻塞，不会影响Consumer应用的TPS，Kafka也提供了<strong>回调</strong>函数</li>
<li><strong><code>commitAsync</code>不能代替<code>commitSync</code></strong>，因为<code>commitAsync</code><em><strong>不会自动重试</strong></em><ul>
<li>如果异步提交后再重试，提交的位移值很可能已经<strong>过期</strong>，因此异步提交的重试是<strong>没有意义</strong>的</li>
</ul>
</li>
</ul>
</li>
<li>手动提交需要组合<code>commitSync</code>和<code>commitAsync</code>，达到最优效果<ul>
<li>利用<code>commitSync</code>的<strong>自动重试</strong>来规避<strong>瞬时</strong>错误，如网络瞬时抖动、Broker端的GC等</li>
<li>利用<code>commitAsync</code>的<strong>非阻塞性</strong>，保证Consumer应用的<strong>TPS</strong></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步提交</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">    process(records); <span class="comment">// 处理消息</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        consumer.commitSync();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CommitFailedException e) &#123;</span><br><span class="line">        handle(e); <span class="comment">// 处理提交失败异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步提交</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">    process(records); <span class="comment">// 处理消息</span></span><br><span class="line">    consumer.commitAsync((offsets, exception) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception != <span class="keyword">null</span>)</span><br><span class="line">            handle(exception);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步提交 + 异步提交</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">        process(records); <span class="comment">// 处理消息</span></span><br><span class="line">        commitAysnc(); <span class="comment">// 使用异步提交规避阻塞</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    handle(e); <span class="comment">// 处理异常</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        consumer.commitSync(); <span class="comment">// 最后一次（异常/应用关闭）提交使用同步阻塞式提交</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        consumer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="精细化提交"><a href="#精细化提交" class="headerlink" title="精细化提交"></a>精细化提交</h2><ol>
<li>上面的位移提交方式，都是提交<strong>poll</strong>方法返回的<strong>所有消息的位移</strong>，即提交<strong>最新一条消息</strong>的位移</li>
<li>精细化提交<ul>
<li><code>commitSync(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets)</code></li>
<li><code>commitAsync(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, OffsetCommitCallback callback)</code></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        process(record);  <span class="comment">// 处理消息</span></span><br><span class="line">        <span class="comment">// 消费位移是下一条消息的位移，所以+1</span></span><br><span class="line">        offsets.put(<span class="keyword">new</span> TopicPartition(record.topic(), record.partition()),</span><br><span class="line">                <span class="keyword">new</span> OffsetAndMetadata(record.offset() + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (count % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 精细化提交</span></span><br><span class="line">            consumer.commitAsync(offsets, <span class="keyword">null</span>); <span class="comment">// 回调处理逻辑是 null</span></span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考：<a href="http://zhongmingmao.me/2019/09/03/kafka-commit-offset/" target="_blank" rel="noopener">http://zhongmingmao.me/2019/09/03/kafka-commit-offset/</a></p>
]]></content>
      <categories>
        <category>Middleware</category>
        <category>MQ</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Middleware</tag>
        <tag>MQ</tag>
        <tag>Kafka</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka -- 消费者组</title>
    <url>/2019/08/22/kafka-consumer-group/</url>
    <content><![CDATA[<h2 id="消费者组"><a href="#消费者组" class="headerlink" title="消费者组"></a>消费者组</h2><ol>
<li>消费者组（Consumer Group）是Kafka提供的<strong>可扩展</strong>且具有<strong>容错性</strong>的<strong>消费者机制</strong></li>
<li>一个消费者组内可以有多个消费者或消费者实例（进程/线程），它们共享一个<strong>Group ID</strong>（字符串）<ul>
<li>组内的<strong>所有消费者</strong>协调在一起来消费订阅主题的<strong>所有分区</strong></li>
<li>每个分区只能由同一个消费者组内的一个Consumer实例来消费，Consumer实例对分区有<strong>所有权</strong></li>
</ul>
</li>
</ol>
<a id="more"></a>
<h2 id="消息引擎模型"><a href="#消息引擎模型" class="headerlink" title="消息引擎模型"></a>消息引擎模型</h2><ol>
<li>两种模型：<strong>点对点模型</strong>（消息队列）、<strong>发布订阅模型</strong><ul>
<li>点对点模型（传统的消息队列模型）<ul>
<li>缺陷/特性：消息一旦被消费、就会从队列中被删除，而且只能被下游的一个Consumer消费</li>
<li><strong>伸缩性很差</strong>，下游的多个Consumer需要<strong>抢占</strong>共享消息队列中的消息</li>
</ul>
</li>
<li>发布订阅模型<ul>
<li>缺陷：<strong>伸缩性不高</strong>，每个订阅者都必须订阅主题的所有分区（<strong>全量订阅</strong>）</li>
</ul>
</li>
</ul>
</li>
<li><strong>Consumer Group</strong><ul>
<li>当Consumer Group订阅了多个主题之后</li>
<li>组内的每个Consumer实例不要求一定要订阅主题的所有分区，只会消费<strong>部分分区</strong>的消息</li>
<li>Consumer Group之间<strong>彼此独立</strong>，互不影响，它们能够订阅相同主题而互不干涉</li>
<li>Kafka使用Consumer Group机制实现了传统消息引擎系统的两种模型<ul>
<li>如果所有Consumer实例都属于<strong>同一个</strong>Consumer Group，实现的是<strong>点对点</strong>模型</li>
<li>如果所有Consumer实例都属于<strong>不同</strong>的Consumer Group，实现的是<strong>发布订阅</strong>模型</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Consumer实例数量"><a href="#Consumer实例数量" class="headerlink" title="Consumer实例数量"></a>Consumer实例数量</h2><ol>
<li>理想情况下，<em><strong>Consumer实例的数量 == 该Consumer Group订阅主题的分区总数</strong></em></li>
<li>假设一个Consumer Group订阅了3个主题，分别为A（1分区）、B（2分区）、C（3分区），应该设置6个Consumer实例<ul>
<li>如果只有3个实例，每个实例大约消费2个分区</li>
<li>如果有8个实例，有两个实例<strong>不会被分配到任何分区</strong>，永远处于<strong>空闲状态</strong>，<strong>浪费资源</strong></li>
</ul>
</li>
</ol>
<h2 id="位移管理"><a href="#位移管理" class="headerlink" title="位移管理"></a>位移管理</h2><ol>
<li>位移可类比为<code>Map&lt;TopicPartition, Long&gt;</code>，TopicPartition代表一个分区，Long代表位移的类型</li>
<li>老版本的Consumer Group把<strong>位移</strong>保存在<strong>Zookeeper</strong>中<ul>
<li>Apache Zookeeper是一个<strong>分布式的协调服务框架</strong>，Kafka<strong>重度依赖</strong>ZK实现各种各样的协调管理</li>
<li>好处：减少Kafka Broker端的状态保存开销，<strong>节点无状态</strong>，可以自由扩缩容，实现<strong>超强的伸缩性</strong></li>
<li>但ZK这类框架并<strong>不适合进行频繁的写更新</strong>，而Consumer Group的位移更新却是一个非常频繁的操作<ul>
<li><em><strong>大吞吐量的写操作会极大地拖慢ZK集群的性能</strong></em></li>
</ul>
</li>
<li>因此，将Consumer位移保存在ZK中是不合适的做法</li>
</ul>
</li>
<li>在新版本的Consumer Group中，重新设计了Consumer Group的<strong>位移管理方式</strong>（内部主题：<strong><code>__consumer_offsets</code></strong>）</li>
</ol>
<h2 id="重平衡"><a href="#重平衡" class="headerlink" title="重平衡"></a>重平衡</h2><ol>
<li>Rebalance本质上是一种<strong>协议</strong>，规定了一个Consumer Group下所有的Consumer如何达成一致来<strong>分配分区</strong></li>
<li>Rebalance的触发条件<ul>
<li>组内<strong>消费者数</strong>发生变更</li>
<li>订阅<strong>主题数</strong>发生变更<ul>
<li>Consumer Group可以使用<strong>正则表达式</strong>的方式订阅主题</li>
</ul>
</li>
<li>订阅主题的<strong>分区数</strong>发生变更<ul>
<li>Kafka当前<strong>只允许增加</strong>一个主题的分区数</li>
</ul>
</li>
</ul>
</li>
<li>Rebalance发生时，Group下<strong>所有的Consumer实例</strong>都会协调在一起共同参与<ul>
<li>Kafka尽量保证提供<strong>最公平</strong>的分配策略，即每个Consumer实例能够得到较为平均的分区数</li>
</ul>
</li>
<li>缺陷<ul>
<li>Rebalance过程<strong>对Consumer Group消费过程有极大的影响</strong><ul>
<li>在Rebalance过程中，所有Consumer实例都会<strong>停止消费</strong>，等待Rebalance完成</li>
</ul>
</li>
<li><strong>所有Consumer实例共同参与，全部重新分配所有分区</strong><ul>
<li>更高效的分配方案：<strong>尽量少改动</strong>，这样可以<strong>复用</strong>已经建立的<strong>TCP连接</strong></li>
</ul>
</li>
<li>Rebalance的过程可能会<strong>持续很久</strong></li>
</ul>
</li>
</ol>
<p>转载： <a href="http://zhongmingmao.me/2019/08/22/kafka-consumer-group/" target="_blank" rel="noopener">http://zhongmingmao.me/2019/08/22/kafka-consumer-group/</a></p>
]]></content>
      <categories>
        <category>Middleware</category>
        <category>MQ</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Middleware</tag>
        <tag>MQ</tag>
        <tag>Kafka</tag>
        <tag>Stream</tag>
        <tag>Rebalance</tag>
        <tag>Consumer Group</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka -- 压缩</title>
    <url>/2019/08/02/kafka-compression/</url>
    <content><![CDATA[<h2 id="压缩的目的"><a href="#压缩的目的" class="headerlink" title="压缩的目的"></a>压缩的目的</h2><p>时间换空间，用<strong>CPU时间</strong>去换<strong>磁盘空间</strong>或<strong>网络IO传输量</strong></p>
<h2 id="消息层次"><a href="#消息层次" class="headerlink" title="消息层次"></a>消息层次</h2><ol>
<li><strong>消息集合</strong>（Message Set）和<strong>消息</strong></li>
<li>一个消息集合中包含若干条<strong>日志项</strong>（Record Item），而日志项用于封装消息</li>
<li>Kafka底层的消息日志由一系列消息集合日志项组成</li>
<li>Kafka不会直接操作具体的消息，而是在<strong>消息集合</strong>这个层面上进行写入操作</li>
</ol>
<a id="more"></a>
<h2 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h2><ol>
<li>目前Kafka共有两大类消息格式，社区分别称之为<strong>V1</strong>版本和<strong>V2</strong>版本（在0.11.0.0引入）</li>
<li>V2版本主要针对V1版本的一些弊端进行了优化</li>
<li>优化1：把消息的公共部分<strong>抽取</strong>到外层消息集合里面<ul>
<li>在V1版本中，每条消息都需要执行CRC校验，但在某些情况下，消息的CRC值会发生变化<ul>
<li>Broker端可能对消息的<strong>时间戳</strong>字段进行更新，重新计算后的CRC值也会相应更新</li>
<li>Broker端在执行<strong>消息格式转换</strong>时（兼容老版本客户端），也会带来CRC值的变化</li>
</ul>
</li>
<li>因此没必要对每条消息都执行CRC校验，浪费<strong>空间</strong>和<strong>时间</strong></li>
<li>在V2版本中，消息的CRC校验被移到了消息集合这一层</li>
</ul>
</li>
<li>优化2：对<strong>整个消息集合</strong>进行压缩<ul>
<li>在V1版本中，对<strong>多条消息</strong>进行压缩，然后保存到<strong>外层消息的消息体字段</strong>中</li>
</ul>
</li>
</ol>
<p><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-compression-v1-v2.png" width=1000/></p>
<h2 id="压缩的时机"><a href="#压缩的时机" class="headerlink" title="压缩的时机"></a>压缩的时机</h2><p>在Kafka中，压缩可能发生在两个地方：<strong>生产者</strong>、<strong>Broker</strong></p>
<h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line">props.put(<span class="string">"acks"</span>, <span class="string">"all"</span>);</span><br><span class="line">props.put(<span class="string">"key.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">props.put(<span class="string">"value.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line"><span class="comment">// 开启GZIP压缩</span></span><br><span class="line"><span class="comment">// Producer启动后，生产的每个消息集合都会经过GZIP压缩，能够很好地节省网络传输带宽和Kafka Broker端的磁盘占用</span></span><br><span class="line">props.put(<span class="string">"compression.type"</span>, <span class="string">"gzip"</span>);</span><br><span class="line"></span><br><span class="line">Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br></pre></td></tr></table></figure>
<h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><p>大部分情况下，Broker从Producer接收到消息后，仅仅只是<strong>原封不动</strong>地保存，而不会对其进行任何修改，但存在例外情况</p>
<h4 id="不同的压缩算法"><a href="#不同的压缩算法" class="headerlink" title="不同的压缩算法"></a>不同的压缩算法</h4><ol>
<li>Producer采用GZIP压缩算法，Broker采用Snappy压缩算法</li>
<li>Broker接收到GZIP压缩消息后，只能解压后使用Snappy压缩算法<strong>重新压缩</strong>一遍</li>
<li>Broker端也有<code>compression.type</code>参数，默认值是<strong>producer</strong>，表示Broker端会<strong>尊重</strong>Producer端使用的压缩算法<ul>
<li>一旦Broker端设置了不同的<code>compression.type</code>，可能会发生预料之外的压缩/解压缩操作，导致<strong>CPU使用率飙升</strong></li>
</ul>
</li>
</ol>
<h4 id="消息格式转换"><a href="#消息格式转换" class="headerlink" title="消息格式转换"></a>消息格式转换</h4><ol>
<li>消息格式转换主要是为了兼容<strong>老版本的消费者程序</strong>，在一个Kafka集群中通常同时保存<strong>多种版本的消息格式</strong>（V1/V2）<ul>
<li>Broker端会对新版本消息执行向老版本格式的转换，该过程中会涉及消息的<strong>解压缩</strong>和<strong>重新压缩</strong></li>
</ul>
</li>
<li>消息格式转换对性能的影响很大，除了增加额外的压缩和解压缩操作之外，还会让Kafka丧失引以为傲的<strong>Zero Copy</strong>特性<ul>
<li>Zero Copy：数据在<strong>磁盘</strong>和<strong>网络</strong>进行传输时，<strong>避免昂贵的内核态数据拷贝</strong>，从而实现快速的数据传输</li>
</ul>
</li>
<li>因此，<strong>尽量保证消息格式的统一</strong></li>
</ol>
<h2 id="解压缩的时机"><a href="#解压缩的时机" class="headerlink" title="解压缩的时机"></a>解压缩的时机</h2><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><ol>
<li>通常来说<strong>解压缩</strong>发生在<strong>消费者</strong></li>
<li><em><strong>Producer压缩，Broker保持、Consumer解压缩</strong></em></li>
<li>Kafka会将启用的压缩算法封装进<strong>消息集合</strong>中，当Consumer读取到消息集合时，会知道这些消息使用了哪一种压缩算法</li>
</ol>
<h3 id="Broker-1"><a href="#Broker-1" class="headerlink" title="Broker"></a>Broker</h3><ol>
<li>与消息格式转换时发生的解压缩是不同的场景（主要为了兼容老版本的消费者）</li>
<li>每个压缩过的消息集合<strong>在Broker端写入时</strong>都要发生解压缩操作，目的是为了对消息执行<strong>各种验证</strong>（主要影响CPU使用率）</li>
</ol>
<h2 id="压缩算法对比"><a href="#压缩算法对比" class="headerlink" title="压缩算法对比"></a>压缩算法对比</h2><ol>
<li>Kafka 2.1.0之前，Kafka支持三种压缩算法：<strong>GZIP</strong>、<strong>Snappy</strong>、<strong>LZ4</strong>，从2.1.0开始正式支持<strong>zstd</strong>算法<ul>
<li>zstd是Facebook开源的压缩算法，能够提供<strong>超高的压缩比</strong></li>
</ul>
</li>
<li>评估一个压缩算法的优劣，主要有两个指标：<strong>压缩比</strong>、<strong>压缩/解压缩吞吐量</strong></li>
<li>从下面的Benchmarks可以看出<ul>
<li><em><strong>zstd具有最高的压缩比</strong>，<strong>LZ4具有最高的吞吐量</strong></em></li>
</ul>
</li>
<li>在Kafka的实际使用中<ul>
<li>吞吐量：<em><strong>LZ4</strong></em> &gt; Snappy &gt; <em><strong>zstd</strong></em> &gt; GZIP</li>
<li>压缩比：<em><strong>zstd</strong></em> &gt; <em><strong>LZ4</strong></em> &gt; GZIP &gt; Snappy</li>
</ul>
</li>
<li>物理资源<ul>
<li>带宽：由于Snappy的压缩比最低，因此占用的网络带宽最大</li>
<li>CPU：各个压缩算法差不多，在<strong>压缩</strong>时<strong>Snappy</strong>使用更多的CPU，在<strong>解压缩</strong>时<strong>GZIP</strong>使用更多的CPU</li>
</ul>
</li>
<li><strong>带宽资源比CPU资源和磁盘资源更吃紧</strong>（千兆网络是标配），<em><strong>首先排除Snappy，其次排除GZIP，剩下在LZ4和zstd中选择</strong></em><ul>
<li>如果客户端的CPU资源充足，强烈建议开启<strong>zstd</strong>压缩，可以<strong>极大地节省网络带宽</strong></li>
</ul>
</li>
</ol>
<p><a href="https://github.com/facebook/zstd" target="_blank" rel="noopener">Benchmarks</a></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Compressor name</th>
<th>Ratio</th>
<th>Compression</th>
<th>Decompress</th>
</tr>
</thead>
<tbody>
<tr>
<td><em><strong>zstd</strong></em> 1.4.0 -1</td>
<td><em><strong>2.884</strong></em></td>
<td>530 MB/s</td>
<td>1360 MB/s</td>
</tr>
<tr>
<td>zlib 1.2.11 -1</td>
<td>2.743</td>
<td>110 MB/s</td>
<td>440 MB/s</td>
</tr>
<tr>
<td>brotli 1.0.7 -0</td>
<td>2.701</td>
<td>430 MB/s</td>
<td>470 MB/s</td>
</tr>
<tr>
<td>quicklz 1.5.0 -1</td>
<td>2.238</td>
<td>600 MB/s</td>
<td>800 MB/s</td>
</tr>
<tr>
<td>lzo1x 2.09 -1</td>
<td>2.106</td>
<td>680 MB/s</td>
<td>950 MB/s</td>
</tr>
<tr>
<td><em><strong>lz4</strong></em> 1.8.3</td>
<td>2.101</td>
<td><em><strong>800 MB/s</strong></em></td>
<td><em><strong>4220 MB/s</strong></em></td>
</tr>
<tr>
<td>snappy 1.1.4</td>
<td>2.073</td>
<td>580 MB/s</td>
<td>2020 MB/s</td>
</tr>
<tr>
<td>lzf 3.6 -1</td>
<td>2.077</td>
<td>440 MB/s</td>
<td>930 MB/s</td>
</tr>
</tbody>
</table>
</div>
<h4 id="转载：http-zhongmingmao-me-2019-08-02-kafka-compression"><a href="#转载：http-zhongmingmao-me-2019-08-02-kafka-compression" class="headerlink" title="转载：http://zhongmingmao.me/2019/08/02/kafka-compression/"></a>转载：<a href="http://zhongmingmao.me/2019/08/02/kafka-compression/" target="_blank" rel="noopener">http://zhongmingmao.me/2019/08/02/kafka-compression/</a></h4>]]></content>
      <categories>
        <category>Middleware</category>
        <category>MQ</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Middleware</tag>
        <tag>MQ</tag>
        <tag>Kafka</tag>
        <tag>Stream</tag>
        <tag>Compression</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka -- Java消费者管理TCP连接</title>
    <url>/2019/09/10/kafka-consumer-manage-tcp-connection/</url>
    <content><![CDATA[<h2 id="创建TCP连接"><a href="#创建TCP连接" class="headerlink" title="创建TCP连接"></a>创建TCP连接</h2><ol>
<li>消费者端的主要程序入口是KafkaConsumer，但<strong>构建KafkaConsumer实例不会创建任何TCP连接</strong><ul>
<li>构建<strong>KafkaProducer</strong>实例时，会在后台默默地启动一个<strong>Sender</strong>线程，Sender线程负责<strong>Socket</strong>连接的创建</li>
<li>在Java构造函数中启动线程，会造成<strong>this指针逃逸</strong>，是一个<strong>隐患</strong></li>
</ul>
</li>
<li>消费者的TCP连接是在调用<strong><code>KafkaConsumer.poll</code></strong>方法时被创建的，poll方法内部有3个时机可以创建TCP连接</li>
</ol>
<a id="more"></a>
<h3 id="发起FindCoordinator请求时"><a href="#发起FindCoordinator请求时" class="headerlink" title="发起FindCoordinator请求时"></a>发起FindCoordinator请求时</h3><ol>
<li>消费者组有个组件叫作<strong>协调者</strong>（Coordinator）<ul>
<li>驻留在<strong>Broker</strong>端的内存中，负责消费者组的<strong>组成员管理</strong>和各个消费者的<strong>位移提交管理</strong></li>
</ul>
</li>
<li>当消费者程序<strong>首次</strong>启动调用poll方法时，需要向<strong>Kafka集群</strong>（集群中的<strong>任意</strong>Broker）发送FindCoordinator请求<ul>
<li>社区优化：消费者程序会向集群中<strong>当前负载最小</strong>的那台Broker发送请求</li>
<li><strong>单向</strong>负载评估（<strong>非最优解</strong>）：消费者连接的所有Broker中，谁的<strong>待发送</strong>请求最少，谁的负载就越小</li>
</ul>
</li>
</ol>
<h3 id="连接Coordinator时"><a href="#连接Coordinator时" class="headerlink" title="连接Coordinator时"></a>连接Coordinator时</h3><ol>
<li>Broker处理完FindCoordinator请求后，会返回对应的响应结果，显式地告诉消费者哪个Broker是<strong>真正的Coordinator</strong></li>
<li>消费者向真正的Coordinator所在的Broker发起Socket连接</li>
<li>成功接入Coordinator后，Coordinator开启<strong>组协调</strong>操作（加入组、等待组分配、心跳请求处理、位移获取和提交）</li>
</ol>
<h3 id="消费数据时"><a href="#消费数据时" class="headerlink" title="消费数据时"></a>消费数据时</h3><ol>
<li>消费者会为每个要消费的分区创建与该分区<strong>领导者副本</strong>所在Broker的Socket连接</li>
<li>假设消费者要消费5个分区的数据，这5个分区各自的领导者副本分布在4台Broker上<ul>
<li>那么消费者在消费时会创建与这4台Broker的Socket连接</li>
</ul>
</li>
</ol>
<h2 id="TCP连接数"><a href="#TCP连接数" class="headerlink" title="TCP连接数"></a>TCP连接数</h2><h3 id="日志详解"><a href="#日志详解" class="headerlink" title="日志详解"></a>日志详解</h3><blockquote>
<p>[2019-05-27 10:00:54,142] DEBUG [Consumer clientId=consumer-1, groupId=test] <strong>Initiating connection to node localhost:9092</strong> (<strong>id: -1</strong> rack: null) using address localhost/127.0.0.1 (org.apache.kafka.clients.NetworkClient:944)</p>
</blockquote>
<p>消费者程序创建的<strong>第一个TCP连接</strong>，该Socket用于发送<strong>FindCoordinator</strong>请求<br>此时消费者对要连接的Kafka集群<strong>一无所知</strong>，因此它连接的Broker节点的ID为<strong>-1</strong>，表示不知道要连接的Broker的任何信息</p>
<hr>
<blockquote>
<p>[2019-05-27 10:00:54,188] DEBUG [Consumer clientId=consumer-1, groupId=test] <strong>Sending metadata request</strong> MetadataRequestData(topics=[MetadataRequestTopic(name=’t4’)], allowAutoTopicCreation=true, includeClusterAuthorizedOperations=false, includeTopicAuthorizedOperations=false) to node localhost:9092 (id: -1 rack: null) (org.apache.kafka.clients.NetworkClient:1097)</p>
</blockquote>
<p>消费者<strong>复用</strong>刚刚创建的Socket连接，向Kafka集群发送<strong>元数据请求</strong>以获取<strong>整个集群的信息</strong></p>
<hr>
<blockquote>
<p>[2019-05-27 10:00:54,188] TRACE [Consumer clientId=consumer-1, groupId=test] <strong>Sending FIND_COORDINATOR</strong> {key=test,key_type=0} with correlation id 0 to <strong>node -1</strong> (org.apache.kafka.clients.NetworkClient:496)</p>
</blockquote>
<p>消费者程序开始发送<strong>FindCoordinator</strong>请求给第一步中连接的Broker，即<strong>localhost:9092</strong>（nodeId为<strong>-1</strong>）</p>
<hr>
<blockquote>
<p>[2019-05-27 10:00:54,203] TRACE [Consumer clientId=consumer-1, groupId=test] <strong>Completed receive from node -1 for FIND_COORDINATOR</strong> with correlation id 0, received {throttle_time_ms=0,error_code=0,error_message=null, <strong>node_id=2,host=localhost,port=9094</strong>} (org.apache.kafka.clients.NetworkClient:837)</p>
</blockquote>
<p>十几毫秒后，消费者程序成功地获悉<strong>Coordinator所在的Broker</strong>，即<strong>node_id=2,host=localhost,port=9094</strong></p>
<hr>
<blockquote>
<p>[2019-05-27 10:00:54,204] DEBUG [Consumer clientId=consumer-1, groupId=test] <strong>Initiating connection to node localhost:9094</strong> (<strong>id: 2147483645</strong> rack: null) using address localhost/127.0.0.1 (org.apache.kafka.clients.NetworkClient:944)</p>
</blockquote>
<p>消费者此时已经知道<strong>协调者Broker的连接信息</strong>了，发起第二个Socket连接，创建连向<strong>localhost:9094</strong>的TCP连接<br>只有连接了Coordinator，消费者才能正常地开启<strong>消费组的各种功能</strong>以及<strong>后续的消息消费</strong><br>此时的id是由<code>Integer.MAX_VALUE</code>减去<strong>Coordinator所在的Broker的Id</strong>计算出来的，即<code>2147483647 - 2 = 2147483645</code><br>这种节点ID的标记方式是Kafka社区<strong>特意为之</strong>，目的是要让<strong>组协调请求</strong>和<strong>真正的数据获取请求</strong>使用<em><strong>不同的Socket连接</strong></em></p>
<hr>
<blockquote>
<p>[2019-05-27 10:00:54,237] DEBUG [Consumer clientId=consumer-1, groupId=test] <strong>Initiating connection to node localhost:9094</strong> (<strong>id: 2</strong> rack: null) using address localhost/127.0.0.1 (org.apache.kafka.clients.NetworkClient:944)</p>
<p>[2019-05-27 10:00:54,237] DEBUG [Consumer clientId=consumer-1, groupId=test] <strong>Initiating connection to node localhost:9092</strong> (<strong>id: 0</strong> rack: null) using address localhost/127.0.0.1 (org.apache.kafka.clients.NetworkClient:944)</p>
<p>[2019-05-27 10:00:54,238] DEBUG [Consumer clientId=consumer-1, groupId=test] <strong>Initiating connection to node localhost:9093</strong> (<strong>id: 1</strong> rack: null) using address localhost/127.0.0.1 (org.apache.kafka.clients.NetworkClient:944)</p>
</blockquote>
<p>消费者又分别创建了<strong>新的TCP连接</strong>，主要用于<strong>实际的消息获取</strong></p>
<h3 id="3类TCP连接"><a href="#3类TCP连接" class="headerlink" title="3类TCP连接"></a>3类TCP连接</h3><ol>
<li><strong>确定协调者</strong>和<strong>获取集群元数据</strong></li>
<li><strong>连接协调者</strong>，令其执行组成员管理操作</li>
<li>执行<strong>实际的消息获取</strong></li>
</ol>
<h2 id="关闭TCP连接"><a href="#关闭TCP连接" class="headerlink" title="关闭TCP连接"></a>关闭TCP连接</h2><ol>
<li>与生产者类似，消费者关闭Socket分为<strong>主动关闭</strong>和<strong>Kafka自动关闭</strong><ul>
<li><strong>主动关闭</strong><ul>
<li>手动调用<strong>KafkaConsumer.close</strong>或者执行<strong>kill</strong>（-2/-9）命令</li>
</ul>
</li>
<li><strong>自动关闭</strong><ul>
<li>消费端参数<strong><code>connection.max.idle.ms</code></strong>，默认是<strong>9分钟</strong></li>
<li>如果使用<strong>循环</strong>的方式来调用<strong>poll</strong>方法来消费消息，上面的<strong>所有请求</strong>都会<strong>定期</strong>发送到Broker，达到<strong>长连接</strong>的效果</li>
</ul>
</li>
</ul>
</li>
<li>当<strong>第三类TCP连接成功创建</strong>后，消费者程序就会<strong>废弃第一类TCP连接</strong>，之后<strong>定期请求元数据</strong>，会改用第三类TCP连接<ul>
<li>第一类TCP连接会在后台被默默关闭，运行一段时间的消费者只会有后面两类TCP连接存在</li>
</ul>
</li>
</ol>
<p>参考：<a href="http://zhongmingmao.me/2019/09/10/kafka-consumer-manage-tcp-connection/" target="_blank" rel="noopener">http://zhongmingmao.me/2019/09/10/kafka-consumer-manage-tcp-connection/</a></p>
]]></content>
      <categories>
        <category>Middleware</category>
        <category>MQ</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Middleware</tag>
        <tag>MQ</tag>
        <tag>Kafka</tag>
        <tag>Stream</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka -- 高水位 + Leader Epoch</title>
    <url>/2019/09/20/kafka-high-watermark-leader-epoch/</url>
    <content><![CDATA[<h2 id="高水位"><a href="#高水位" class="headerlink" title="高水位"></a>高水位</h2><h3 id="水位的定义"><a href="#水位的定义" class="headerlink" title="水位的定义"></a>水位的定义</h3><p><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-watermark.png" width=1000/></p>
<a id="more"></a>
<ol>
<li>经典教科书<ul>
<li>在时刻T，任意创建时间（<strong>Event Time</strong>）为<code>T&#39;</code>，且<code>T&#39;&lt;=T</code>的所有事件都已经到达，那么T就被定义为水位</li>
</ul>
</li>
<li>《Streaming System》<ul>
<li>水位是一个<strong>单调增加</strong>且表征<strong>最早未完成工作的时间戳</strong></li>
</ul>
</li>
<li>上图中标注为<code>Completed</code>的蓝色部分代表<strong>已经完成</strong>的工作，标注为<code>In-Flight</code>的红色部分代表<strong>正在进行中</strong>的工作<ul>
<li>两者的<strong>边界</strong>就是水位线</li>
</ul>
</li>
<li>在<strong>Kafka</strong>中，水位不是时间戳，而是与位置信息绑定的，即用<strong>消息位移</strong>来表征水位<ul>
<li>Kafka中也有<strong>低水位</strong>（Low Watermark），是与Kafka<strong>删除消息</strong>相关联的概念</li>
</ul>
</li>
</ol>
<h3 id="高水位的作用"><a href="#高水位的作用" class="headerlink" title="高水位的作用"></a>高水位的作用</h3><p><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-high-watermark.png" width=800/></p>
<ol>
<li>两个作用<ul>
<li>定义<strong>消息可见性</strong>，即用来标识分区下的哪些消息可以被消费者消费的</li>
<li>帮助Kafka完成<strong>副本同步</strong></li>
</ul>
</li>
<li>上图是某个分区<strong>Leader副本</strong>的高水位图，在<strong>分区高水位以下</strong>的消息被认为是<strong>已提交消息</strong>，反之为未提交消息<ul>
<li><strong>消费者只能消费已提交消息</strong>，即位移小于8的所有消息</li>
<li>暂不讨论Kafka事务，Kafka的<strong>事务</strong>机制会影响消费者所能看到的消息的范围，不只是简单依赖高水位来判断<ul>
<li>而是依靠<strong>LSO</strong>（Log <strong>Stable</strong> Offset）的位移值来判断事务型消费者的可见性</li>
</ul>
</li>
<li><strong>位移值等于高水位的消息也属于未提交消息</strong>，即高水位上的消息是不能被消费者消费的</li>
<li>图中还有一个<strong>日志末端位移</strong>（Log <strong>End</strong> Offset，<strong>LEO</strong>）的概念，表示<strong>副本写入下一条消息的位移值</strong><ul>
<li>LEO为15，方框是虚线，表示当前副本只有15条消息，位移从0到14，下一条新消息的位移为15</li>
</ul>
</li>
<li><code>[高水位,LEO)</code>的消息属于<strong>未提交消息</strong>，在同一个副本对象，<strong>高水位值不会大于LEO值</strong></li>
<li><strong>高水位</strong>和<strong>LEO</strong>是副本对象的两个重要属性<ul>
<li>Kafka<strong>所有副本对象</strong>都有对应的高水位和LEO，而Kafka使用<strong>Leader副本的高水位</strong>来定义<strong>所在分区的高水位</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="高水位的更新机制"><a href="#高水位的更新机制" class="headerlink" title="高水位的更新机制"></a>高水位的更新机制</h3><h4 id="远程副本"><a href="#远程副本" class="headerlink" title="远程副本"></a>远程副本</h4><p><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-high-watermark-update.png" width=600/></p>
<ol>
<li>每个副本对象都保存了一组高水位和LEO值，<strong>Leader副本所在的Broker</strong>还保存了<em><strong>其它Follower副本的LEO值</strong></em></li>
<li>Kafka把Broker 0上保存的Follower副本又称为<strong>远程副本</strong>（<strong>Remote</strong> Replica）</li>
<li>Kafka<strong>副本机制</strong>在运行过程中<ul>
<li>会更新<ul>
<li>Broker 1上Follower副本的高水位和LEO值</li>
<li>Broker 0上Leader副本的高水位和LEO以及<strong>所有远程副本的LEO</strong></li>
</ul>
</li>
<li>不会更新<ul>
<li>Broker 0<strong>所有远程副本的高水位值</strong>，即图中标记为<strong>灰色</strong>的部分</li>
</ul>
</li>
</ul>
</li>
<li>Broker 0保存远程副本的作用<ul>
<li><strong>帮助</strong>Leader副本<strong>确定</strong>其<strong>高水位</strong>，即<strong>分区高水位</strong></li>
</ul>
</li>
</ol>
<h4 id="更新时机"><a href="#更新时机" class="headerlink" title="更新时机"></a>更新时机</h4><div class="table-container">
<table>
<thead>
<tr>
<th>更新对象</th>
<th>更新时机</th>
</tr>
</thead>
<tbody>
<tr>
<td>Broker 0上Leader副本的LEO</td>
<td>Leader副本<strong>接收</strong>到生产者发送的消息，<strong>写入到本地磁盘</strong>后，会更新其LEO值</td>
</tr>
<tr>
<td>Broker 1上Follower副本的LEO</td>
<td>Follower副本从Leader副本<strong>拉取</strong>消息，<strong>写入本地磁盘</strong>后，会更新其LEO值</td>
</tr>
<tr>
<td>Broker 0上远程副本的LEO</td>
<td>Follower副本从Leader副本<strong>拉取</strong>消息时，会告诉Leader副本<strong>从哪个位移开始拉取</strong>，<br/>Leader副本会使用这个位移值来更新远程副本的LEO</td>
</tr>
<tr>
<td>Broker 0上Leader副本的高水位</td>
<td>两个更新时机：一个是Leader副本更新其LEO之后，一个是更新完远程副本LEO之后<br/>具体算法：取Leader副本和所有与Leader<strong>同步</strong>的远程副本LEO中的<strong>最小值</strong></td>
</tr>
<tr>
<td>Broker 1上Follower副本的高水位</td>
<td>Follower副本成功更新完LEO后，会比较其LEO与<strong>Leader副本发来的高水位值</strong>，<br/>并用两者的<strong>较小值</strong>去更新自己的高水位</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>与Leader副本保持同步，需要满足两个条件<ul>
<li>该远程Follower副本在<strong>ISR</strong>中</li>
<li>该远程Follower副本LEO值<strong>落后</strong>Leader副本LEO值的时间<strong>不超过</strong>参数<code>replica.lag.time.max.ms</code>（<strong>10秒</strong>）</li>
</ul>
</li>
<li>某个副本能否进入ISR是由第二个条件判断的<ul>
<li>2个条件判断是为了应对意外情况：<strong>Follower副本已经追上Leader，却不在ISR中</strong></li>
<li>假设Kafka只判断第1个条件，副本F刚刚重启，并且已经具备进入ISR的资格，但此时尚未进入到ISR<ul>
<li>由于缺少了副本F的判断，<strong>分区高水位有可能超过真正ISR中的副本LEO</strong>，而<strong>高水位&gt;LEO</strong>是<strong>不允许</strong>的</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="Leader副本"><a href="#Leader副本" class="headerlink" title="Leader副本"></a>Leader副本</h4><ol>
<li><strong>处理生产者请求</strong><ul>
<li>写入消息到本地磁盘，更新<strong>LEO</strong></li>
<li>更新<strong>分区高水位</strong>值<ul>
<li>获取Leader副本所在Broker端保存的所有远程副本LEO值<code>{LEO-1, LEO-2,... LEO-n}</code></li>
<li>获取Leader副本的LEO值：<code>currentLEO</code></li>
<li>更新<strong><code>currentHW = min(currentLEO, LEO-1, LEO-2,... LEO-n)</code></strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>处理Follower副本拉取消息</strong><ul>
<li>读取<strong>磁盘</strong>（或<strong>页缓存</strong>）中的消息数据</li>
<li>使用Follower副本发送请求中的位移值来更新远程副本的<strong>LEO</strong>值</li>
<li>更新<strong>分区高水位</strong>值（与上面一致）</li>
</ul>
</li>
</ol>
<h4 id="Follower副本"><a href="#Follower副本" class="headerlink" title="Follower副本"></a>Follower副本</h4><ol>
<li><strong>从Leader拉取消息</strong><ul>
<li>写入消息到本地磁盘</li>
<li>更新<strong>LEO</strong></li>
<li>更新<strong>高水位</strong>值<ul>
<li>获取<strong>Leader发送</strong>的高水位值：<code>currentHW</code></li>
<li>获取步骤2中更新的LEO值：<code>currentLEO</code></li>
<li>更新高水位<strong><code>min(currentHW, currentLEO)</code></strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="副本同步样例"><a href="#副本同步样例" class="headerlink" title="副本同步样例"></a>副本同步样例</h3><p>主题是<strong>单分区两副本</strong>，首先是初始状态，所有值都是0<br><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-high-watermark-example-1.png" width=1000/></p>
<p>当生产者向主题分区发送一条消息后，状态变更为<br><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-high-watermark-example-2.png" width=1000/></p>
<p>此时，Leader副本成功将消息写入到<strong>本地磁盘</strong>，将<strong>LEO</strong>值更新为1（更新高水位值为0，并把结果发送给Follower副本）<br>Follower再次尝试从Leader拉取消息，此时有消息可以拉取，Follower副本也成功更新<strong>LEO</strong>为1（并将高水位更新为0）<br>此时，Leader副本和Follower副本的<strong>LEO</strong>都是1，但各自的<strong>高水位依然是0</strong>，需要等到<strong>下一轮</strong>的拉取中被更新<br><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-high-watermark-example-3.png" width=1000/></p>
<p>在新一轮的拉取请求中，由于位移值为0的消息已经拉取成功，因此Follower副本这次拉取请求的位移值为<strong>1</strong><br>Leader副本接收到此请求后，更新<strong>远程副本LEO</strong>为<strong>1</strong>，然后更新<strong>Leader高水位</strong>值为<strong>1</strong><br>最后，<strong>Leader副本</strong>会将<strong>当前更新过的高水位</strong>值1发送给<strong>Follower副本</strong>，Follower副本接收到后，也会将自己的高水位值更新为<strong>1</strong><br><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-high-watermark-example-4.png" width=1000/></p>
<h2 id="Leader-Epoch"><a href="#Leader-Epoch" class="headerlink" title="Leader Epoch"></a>Leader Epoch</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol>
<li>上面的副本同步过程中，Follower副本的<strong>高水位更新</strong>需要<strong>一轮额外的拉取请求</strong>才能实现<ul>
<li>如果扩展到<strong>多个Follower副本</strong>，可能需要<strong>多轮拉取请求</strong></li>
<li>即<strong>Leader副本高水位更新</strong>和<strong>Follower副本高水位更新</strong>在<strong>时间</strong>上存在<strong>错配</strong><ul>
<li>这种错配是很多<strong>数据丢失</strong>或<strong>数据不一致</strong>问题的根源</li>
<li>因此，社区在<strong>0.11</strong>版本正式引入了<code>Leader Epoch</code>概念，来规避<strong>高水位更新错配</strong>导致的各种<strong>不一致</strong>问题</li>
</ul>
</li>
</ul>
</li>
<li>Leader Epoch可以大致认为是<strong>Leader版本</strong>，由两部分数据组成<ul>
<li><strong>Epoch</strong><ul>
<li>一个<strong>单调递增</strong>的版本号</li>
<li>每当<strong>副本领导权发生变更</strong>时，都会增加该版本号</li>
<li>小版本号的Leader被认为是<strong>过期Leader</strong>，不能再行使Leader权利</li>
</ul>
</li>
<li><strong>起始位移</strong>（Start Offset）<ul>
<li><strong>Leader副本</strong>在该Epoch值上写入的<strong>首条消息</strong>的位移</li>
</ul>
</li>
</ul>
</li>
<li>两个Leader Epoch，<code>&lt;0,0&gt;</code>和<code>&lt;1,120&gt;</code><ul>
<li><code>&lt;0,0&gt;</code>表示版本号为0，该版本的Leader从位移0开始保存消息，一共保存了120条消息</li>
<li>之后Leader发生了<strong>变更</strong>，版本号增加到1，新版本的起始位移是120</li>
</ul>
</li>
<li>Broker在<strong>内存</strong>中为每个<strong>分区</strong>都缓存<code>Leader Epoch</code>数据，同时还会<strong>定期</strong>地将这些数据<strong>持久化</strong>到一个<code>checkpoint</code>文件中<ul>
<li>当<strong>Leader副本写入消息到磁盘</strong>时，Broker会尝试更新这部分缓存</li>
<li>如果Leader是<strong>首次</strong>写入消息，那么Broker会向缓存中<strong>增加Leader Epoch条目</strong>，否则不做更新</li>
<li>这样每次有Leader变更时，新的Leader副本会查询这部分缓存，取出对应的Leader Epoch的起始位移<ul>
<li>然后进行相关的逻辑判断，避免<strong>数据丢失</strong>和<strong>数据不一致</strong>的情况</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="数据丢失"><a href="#数据丢失" class="headerlink" title="数据丢失"></a>数据丢失</h3><p><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-leader-epoch-example-1.png" width=1000/></p>
<ol>
<li>开始时，副本A和副本B都处于正常状态，A是Leader副本</li>
<li>某个的生产者（<strong>默认acks设置</strong>）向A发送了两条消息，A全部写入成功，Kafka会通知生产者说两条消息全部发送成功</li>
<li>假设Leader和Follower都写入了这两条消息，而且Leader副本的高水位也更新了，但<em><strong>Follower副本的高水位还未更新</strong></em></li>
<li>此时副本B所在的Broker<strong>宕机</strong>，当它<strong>重启</strong>回来后，副本B会执行<em><strong>日志截断!!</strong></em><ul>
<li><strong>将LEO值调整为之前的高水位值!!</strong>，也就是1</li>
<li>位移值为1的那条消息被副本B<strong>从磁盘中删除</strong>，此时副本B的<strong>底层磁盘文件</strong>中只保留1条消息，即位移为0的消息</li>
</ul>
</li>
<li>副本B执行完日志截断操作后，开始从A拉取消息，此时恰好副本A所在的Broker也宕机了，副本B自然成为新的Leader<ul>
<li>当A回来后，需要执行相同的<strong>日志截断</strong>操作，但<strong>不能超过新Leader</strong>，即<strong>将高水位调整与B相同的值</strong>，也就是1</li>
<li>操作完成后，位移值为1的那条消息就从两个副本中被<strong>永远抹掉</strong>，造成了<strong>数据丢失</strong></li>
</ul>
</li>
</ol>
<h3 id="Leader-Epoch规避数据丢失"><a href="#Leader-Epoch规避数据丢失" class="headerlink" title="Leader Epoch规避数据丢失"></a>Leader Epoch规避数据丢失</h3><p><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-leader-epoch-example-2.png" width=1000/></p>
<ol>
<li>Follower副本B重启后，需要向A发送一个特殊的请求去获取<strong>Leader的LEO值</strong>，该值为2</li>
<li>当获知Leader LEO后，B发现该LEO值<strong>大于等于</strong>自己的LEO，而且缓存中也<strong>没有保存任何起始位移值&gt;2的Epoch条目</strong><ul>
<li><strong>B无需执行任何日志截断操作</strong></li>
<li>明显改进：<em><strong>副本是否执行日志截断不再依赖于高水位进行判断</strong></em></li>
</ul>
</li>
<li>A宕机，B成为Leader，当A重启回来后，执行与B相同的逻辑判断，发现同样<strong>不需要执行日志截断</strong><ul>
<li>至此位移值为1的那条消息在两个副本中<strong>均得到保留</strong></li>
<li>后面生产者向B<strong>写入新消息</strong>后，副本B所在的Broker缓存中会生成新的Leader Epoch条目：<strong><code>[Epoch=1, Offset=2]</code></strong></li>
</ul>
</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li><strong>高水位</strong>在界定<strong>Kafka消息对外可见性</strong>以及实现<strong>副本机制</strong>方面起到非常重要的作用<ul>
<li>但设计上的缺陷给Kafka留下了很多<strong>数据丢失</strong>或<strong>数据不一致</strong>的潜在风险</li>
</ul>
</li>
<li>为此，社区引入了<strong><code>Leader Epoch</code></strong>机制，尝试规避这类风险，并且效果不错</li>
</ol>
<p>参考：<a href="http://zhongmingmao.me" target="_blank" rel="noopener">http://zhongmingmao.me</a></p>
]]></content>
      <categories>
        <category>Middleware</category>
        <category>MQ</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Middleware</tag>
        <tag>MQ</tag>
        <tag>Kafka</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka --  控制器</title>
    <url>/2019/09/18/kafka-controller/</url>
    <content><![CDATA[<h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><ol>
<li><strong>控制器</strong>（Controller）是Kafka的<strong>核心组件</strong>，主要作用是在<strong>ZK</strong>的帮助下<strong>管理和协调整个Kafka集群</strong></li>
<li>集群中<strong>任一</strong>Broker都能充当控制器的角色，但在运行过程中，<strong>只能有一个Broker成为控制器</strong>，行使管理和协调的职责</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 1] get &#x2F;controller</span><br><span class="line">&#123;&quot;version&quot;:1,&quot;brokerid&quot;:0,&quot;timestamp&quot;:&quot;1571311742367&quot;&#125;</span><br><span class="line">cZxid &#x3D; 0xd68</span><br><span class="line">ctime &#x3D; Thu Oct 17 19:29:02 CST 2019</span><br><span class="line">mZxid &#x3D; 0xd68</span><br><span class="line">mtime &#x3D; Thu Oct 17 19:29:02 CST 2019</span><br><span class="line">pZxid &#x3D; 0xd68</span><br><span class="line">cversion &#x3D; 0</span><br><span class="line">dataVersion &#x3D; 0</span><br><span class="line">aclVersion &#x3D; 0</span><br><span class="line">ephemeralOwner &#x3D; 0x1000209974b0000</span><br><span class="line">dataLength &#x3D; 54</span><br><span class="line">numChildren &#x3D; 0</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><ol>
<li>Kafka控制器<strong>重度依赖</strong>ZK</li>
<li>ZK是一个提供<strong>高可靠性的分布式协调服务</strong>框架</li>
<li>ZK使用类似于<strong>文件系统</strong>的树形结构，<strong>根目录</strong>以<code>/</code>开始，结构上的每个节点称为<strong>znode</strong>，用来保存一些<strong>元数据协调信息</strong></li>
<li>如果以znode的<strong>持久性</strong>来划分，znode可以分为<strong>持久性znode</strong>和<strong>临时znode</strong><ul>
<li>持久性znode不会因为ZK集群重启而消失</li>
<li>临时znode则会<strong>与创建该znode的ZK会话绑定</strong>，一旦<strong>会话结束</strong>，该节点会被<strong>自动删除</strong></li>
</ul>
</li>
<li>ZK赋予客户端<strong>监控znode变更</strong>的能力，即所谓的<strong>Watch通知</strong>功能<ul>
<li>一旦znode节点被<strong>创建</strong>、<strong>删除</strong>、<strong>子节点数量发生变化</strong>，<strong>znode所存的数据本身发生变更</strong></li>
<li>ZK会通过节点变更监听器（<strong>ChangeHandler</strong>）的方式<strong>显式通知</strong>客户端</li>
</ul>
</li>
<li>ZK被用来实现<strong>集群成员管理</strong>、<strong>分布式锁</strong>、<strong>领导者选举</strong>等功能，<strong>Kafka控制器</strong>大量使用<strong>Watch</strong>功能实现<strong>对集群的协调管理</strong></li>
</ol>
<p>kafka在ZK中创建的znode<br><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-controller-znode.png" width=1000/></p>
<h2 id="controller节点"><a href="#controller节点" class="headerlink" title="/controller节点"></a><code>/controller</code>节点</h2><ol>
<li>Broker在启动时，会尝试去ZK创建<code>/controller</code>节点</li>
<li><strong>第一个</strong>成功创建<code>/controller</code>节点的Broker会被指定为为<strong>控制器</strong></li>
</ol>
<h2 id="控制器的职责"><a href="#控制器的职责" class="headerlink" title="控制器的职责"></a>控制器的职责</h2><ol>
<li><strong>主题管理</strong><ul>
<li>完成对Kafka主题的<strong>创建</strong>、<strong>删除</strong>以及<strong>分区增加</strong>的操作</li>
<li>执行<code>kafka-topics</code>时，大部分的后台工作都是由控制器完成的</li>
</ul>
</li>
<li><strong>分区重分配</strong><ul>
<li>分区重分配主要是指<code>kafka-reassign-partitions</code>脚本提供的<strong>对已有主题分区进行细粒度的分配功能</strong></li>
</ul>
</li>
<li><strong>Preferred领导者选举</strong><ul>
<li>Preferred领导者选举主要是Kafka为了<strong>避免部分Broker负载过重</strong>而提供的一种<strong>换Leader</strong>的方案</li>
</ul>
</li>
<li><strong>集群成员管理</strong><ul>
<li>自动检测<strong>新增Broker</strong>、<strong>Broker主动关闭</strong>、<strong>Broker宕机</strong></li>
<li>自动检测依赖于<strong>Watch</strong>功能和<strong>ZK临时节点</strong>组合实现的<ul>
<li>控制器会利用Watch机制检查ZK的<code>/brokers/ids</code>节点下的<strong>子节点数量变更</strong></li>
<li>当有新Broker启动后，它会在<code>/brokers/ids/</code>下创建专属的<strong>临时znode节点</strong><ul>
<li>一旦创建完毕，ZK会通过Watch机制将消息通知<strong>推送</strong>给<strong>控制器</strong>，控制器能够自动感知这个变化</li>
</ul>
</li>
<li>当Broker<strong>宕机</strong>或者<strong>主动关闭</strong>后，该Broker与ZK的<strong>会话结束</strong>，这个znode会被<strong>自动删除</strong><ul>
<li>ZK的Watch机制会将这一变更<strong>推送</strong>给<strong>控制器</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>数据服务</strong><ul>
<li>向<strong>其它Broker</strong>提供数据服务，控制器上保存了<strong>最全的集群元数据信息</strong></li>
<li>其它Broker会<strong>定期</strong>接收<strong>控制器</strong>发来的<strong>元数据更新请求</strong>，从而更新其<strong>内存</strong>中的缓存数据</li>
</ul>
</li>
</ol>
<h2 id="控制器保存的数据"><a href="#控制器保存的数据" class="headerlink" title="控制器保存的数据"></a>控制器保存的数据</h2><p><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-controller-data.png" width=1000/></p>
<ol>
<li>所有<strong>主题信息</strong>，包括具体的分区信息、比如领导者副本是谁，ISR集合有哪些副本</li>
<li>所有<strong>Broker信息</strong>，包括哪些运行中的Broker，哪些正在关闭的Broker</li>
<li>所有<strong>涉及运维任务的分区</strong>，包括当前正在进行<strong>Preferred领导者选举</strong>以及<strong>分区重分配</strong>的分区列表</li>
<li>上述这些数据在<strong>ZK</strong>中也保存了一份，每当控制器<strong>初始化</strong>时，都会从ZK上读取对应的元数据并填充到自己的<strong>缓存</strong>中<ul>
<li>有了这些数据，控制器就能对<strong>其它Broker</strong>提供数据服务了</li>
<li>控制器通过向其它Broker<strong>发送请求</strong>的方式将这些数据<strong>同步</strong>到其它Broker上</li>
</ul>
</li>
</ol>
<h2 id="控制器故障转移"><a href="#控制器故障转移" class="headerlink" title="控制器故障转移"></a>控制器故障转移</h2><p><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-controller-failover.jpg" width=1000/></p>
<ol>
<li>故障转移<ul>
<li>当运行中的控制器突然<strong>宕机</strong>或者<strong>意外终止</strong>时，Kafka能<strong>快速感知</strong>并立即启用备用控制器来<strong>代替</strong>之前失败的控制器</li>
<li>该过程称为<strong>FailOver</strong>，该过程是<strong>自动完成</strong>的</li>
</ul>
</li>
<li>一开始，Broker 0是控制器，当Broker 0宕机后，ZK通过Watch机制感知到并<strong>删除了<code>/controller</code>临时节点</strong></li>
<li>然后，所有<strong>存活的Broker</strong>开始竞选新的控制器，Broker 3最终赢得了选举，成功地在ZK上重建了<code>/controller</code>临时节点</li>
<li>之后，Broker 3会<strong>从ZK中读取集群元数据信息</strong>，并<strong>初始化到自己的缓存</strong>中，至此控制器的FailOver完成</li>
</ol>
<h2 id="控制器内部设计原理"><a href="#控制器内部设计原理" class="headerlink" title="控制器内部设计原理"></a>控制器内部设计原理</h2><p><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-controller-design.png" width=1000/></p>
<ol>
<li>在Kafka 0.11之前，控制器的设计是相当繁琐的，导致很多Bug无法修复</li>
<li>控制器是<strong>多线程</strong>的设计，会在内部创建很多个线程<ul>
<li>控制器需要为每个Broker都创建一个对应的<strong>Socket连接</strong>，然后再创建一个<strong>专属的线程</strong>，用于向这些Broker发送请求</li>
<li>控制器连接ZK的会话，也会创建<strong>单独的线程</strong>来处理<strong>Watch机制的通知回调</strong></li>
<li>控制器还会为<strong>主题删除</strong>创建额外的<strong>IO线程</strong></li>
</ul>
</li>
<li>这些线程还会访问<strong>共享</strong>的控制器缓存数据，<strong>多线程</strong>访问<strong>共享可变数据</strong>是维持线程安全的最大难题<ul>
<li>为了保护<strong>数据安全性</strong>，控制器在代码中大量使用<strong>ReentrantLock</strong>同步机制，进一步<strong>拖慢</strong>整个控制器的<strong>处理速度</strong></li>
</ul>
</li>
<li>社区在0.11版本<strong>重构了控制器的底层设计</strong>，把多线程的方案改成了<strong>单线程+事件队列</strong>的方案<ul>
<li>引进了<strong>事件处理器</strong>，统一处理各种<strong>控制器事件</strong></li>
<li>控制器将原来执行的操作全部建模成<strong>独立的事件</strong>，发送到专属的<strong>事件队列</strong>中，供事件处理器消费</li>
<li>单线程：控制器只是把<strong>缓存状态变更方面的工作</strong>委托给了这个线程而已</li>
<li>优点：控制器缓存中保存的状态只被一个线程处理，因此不需要<strong>重量级的线程同步机制</strong>来维护线程安全</li>
</ul>
</li>
<li>针对控制器的第二个改进：将之前同步操作ZK全部换成<strong>异步操作</strong><ul>
<li>ZK本身的API提供了<strong>同步写</strong>和<strong>异步写</strong>两种方式</li>
<li>之前控制器操作ZK时使用的是<strong>同步API</strong>，<strong>性能很差</strong><ul>
<li><strong>当有大量主题分区发生变更时，ZK容易成为系统的瓶颈</strong></li>
</ul>
</li>
</ul>
</li>
<li>Kafka从2.2开始，将<strong>控制器发送的请求</strong>和<strong>普通数据类的请求</strong>分开，实现控制器请求<strong>单独处理</strong>的逻辑<ul>
<li>之前Broker对接收到的所有请求都<strong>一视同仁</strong>，不会区别对待</li>
<li>如果删除了某个主题，那么控制器会给主题的所有副本所在的Broker发送StopReplica请求</li>
<li>如果此时Broker上有大量Produce请求堆积，那么StopReplica请求只能<strong>排队</strong></li>
<li>既然主题都要被删除了，继续处理Produce请求就显得很没有意义</li>
</ul>
</li>
</ol>
<p>参考：<a href="http://zhongmingmao.me" target="_blank" rel="noopener">http://zhongmingmao.me</a></p>
]]></content>
      <categories>
        <category>Middleware</category>
        <category>MQ</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Middleware</tag>
        <tag>MQ</tag>
        <tag>Kafka</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>go -- 反射</title>
    <url>/2020/09/07/go-%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h2 id="一、为什么要用反射"><a href="#一、为什么要用反射" class="headerlink" title="一、为什么要用反射"></a>一、为什么要用反射</h2><p>需要反射的 2 个常见场景：</p>
<ol>
<li>有时你需要编写一个函数，但是并不知道传给你的参数类型是什么，可能是没约定好；也可能是传入的类型很多，这些类型并不能统一表示。这时反射就会用的上了。</li>
<li>有时候需要根据某些条件决定调用哪个函数，比如根据用户的输入来决定。这时就需要对函数和函数的参数进行反射，在运行期间动态地执行函数。</li>
</ol>
<p>但是对于反射，还是有几点不太建议使用反射的理由：</p>
<ol>
<li>与反射相关的代码，经常是难以阅读的。在软件工程中，代码可读性也是一个非常重要的指标。</li>
<li>Go 语言作为一门静态语言，编码过程中，编译器能提前发现一些类型错误，但是对于反射代码是无能为力的。所以包含反射相关的代码，很可能会运行很久，才会出错，这时候经常是直接 panic，可能会造成严重的后果。</li>
<li>反射对性能影响还是比较大的，比正常代码运行速度慢一到两个数量级。所以，对于一个项目中处于运行效率关键位置的代码，尽量避免使用反射特性。</li>
</ol>
<h2 id="二、相关基础"><a href="#二、相关基础" class="headerlink" title="二、相关基础"></a>二、相关基础</h2><p>反射是如何实现的？我们以前学习过 interface，它是 Go 语言实现抽象的一个非常强大的工具。当向接口变量赋予一个实体类型的时候，接口会存储实体的类型信息，反射就是通过接口的类型信息实现的，反射建立在类型的基础上。</p>
<p>Go 语言在 reflect 包里定义了各种类型，实现了反射的各种函数，通过它们可以在运行时检测类型的信息、改变类型的值。在进行更加详细的了解之前，我们需要重新温习一下Go语言相关的一些特性，所谓温故知新，从这些特性中了解其反射机制是如何使用的。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>特点</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>go语言是静态类型语言。</td>
<td>编译时类型已经确定，比如对已基本数据类型的再定义后的类型，反射时候需要确认返回的是何种类型。</td>
</tr>
<tr>
<td>空接口interface{}</td>
<td>go的反射机制是要通过接口来进行的，而类似于Java的Object的空接口可以和任何类型进行交互，因此对基本数据类型等的反射也直接利用了这一特点</td>
</tr>
</tbody>
</table>
</div>
<p>Go语言的类型：</p>
<ul>
<li><p>变量包括（type, value）两部分</p>
<pre><code>理解这一点就知道为什么nil != nil了
</code></pre></li>
<li><p>type 包括 static type和concrete type. 简单来说 static type是你在编码是看见的类型(如int、string)，concrete type是runtime系统看见的类型</p>
</li>
<li><p>类型断言能否成功，取决于变量的concrete type，而不是static type。因此，一个 reader变量如果它的concrete type也实现了write方法的话，它也可以被类型断言为writer。</p>
</li>
</ul>
<p>Go是静态类型语言。每个变量都拥有一个静态类型，这意味着每个变量的类型在编译时都是确定的：int，float32, *AutoType, []byte,  chan []int 诸如此类。</p>
<p>在反射的概念中， 编译时就知道变量类型的是静态类型；运行时才知道一个变量类型的叫做动态类型。</p>
<ul>
<li><p>静态类型<br>静态类型就是变量声明时的赋予的类型。比如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span> <span class="comment">// int 就是静态类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="keyword">string</span>  <span class="comment">// string就是静态</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> i *<span class="keyword">int</span>  <span class="comment">// *int就是静态类型</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>动态类型<br>动态类型：运行时给这个变量赋值时，这个值的类型(如果值为nil的时候没有动态类型)。一个变量的动态类型在运行时可能改变，这主要依赖于它的赋值（前提是这个变量是接口类型）。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> A <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 静态类型interface&#123;&#125;</span></span><br><span class="line">A = <span class="number">10</span>            <span class="comment">// 静态类型为interface&#123;&#125;  动态为int</span></span><br><span class="line">A = <span class="string">"String"</span>      <span class="comment">// 静态类型为interface&#123;&#125;  动态为string</span></span><br><span class="line"><span class="keyword">var</span> M *<span class="keyword">int</span></span><br><span class="line">A = M             <span class="comment">// A的值可以改变</span></span><br></pre></td></tr></table></figure>
<p>Go语言的反射就是建立在类型之上的，Golang的指定类型的变量的类型是静态的（也就是指定int、string这些的变量，它的type是static type），在创建变量的时候就已经确定，反射主要与Golang的interface类型相关（它的type是concrete type），只有interface类型才有反射一说。</p>
<p>在Golang的实现中，每个interface变量都有一个对应pair，pair中记录了实际变量的值和类型:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(value, <span class="keyword">type</span>)</span><br></pre></td></tr></table></figure>
<p>value是实际变量值，type是实际变量的类型。一个interface{}类型的变量包含了2个指针，一个指针指向值的类型【对应concrete type】，另外一个指针指向实际的值【对应value】。</p>
<p>例如，创建类型为*os.File的变量，然后将其赋给一个接口变量r：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tty, err := os.OpenFile(<span class="string">"/dev/tty"</span>, os.O_RDWR, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r io.Reader</span><br><span class="line">r = tty</span><br></pre></td></tr></table></figure>
<p>接口变量r的pair中将记录如下信息：(tty, *os.File)，这个pair在接口变量的连续赋值过程中是不变的，将接口变量r赋给另一个接口变量w:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = r.(io.Writer)</span><br></pre></td></tr></table></figure>
<p>接口变量w的pair与r的pair相同，都是:(tty, *os.File)，即使w是空接口类型，pair也是不变的。</p>
<p>interface及其pair的存在，是Golang中实现反射的前提，理解了pair，就更容易理解反射。反射就是用来检测存储在接口变量内部(值value；类型concrete type) pair对的一种机制。</p>
<p>所以我们要理解两个基本概念 Type 和 Value，它们也是 Go语言包中 reflect 空间里最重要的两个类型。</p>
<h2 id="三、Type和Value"><a href="#三、Type和Value" class="headerlink" title="三、Type和Value"></a>三、Type和Value</h2><p>我们一般用到的包是reflect包。</p>
<p>既然反射就是用来检测存储在接口变量内部(值value；类型concrete type) pair对的一种机制。那么在Golang的reflect反射包中有什么样的方式可以让我们直接获取到变量内部的信息呢？ 它提供了两种类型（或者说两个方法）让我们可以很容易的访问接口变量内容，分别是reflect.ValueOf() 和 reflect.TypeOf()，看看官方的解释</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ValueOf returns a new Value initialized to the concrete value</span></span><br><span class="line"><span class="comment">// stored in the interface i.  ValueOf(nil) returns the zero </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Value</span></span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">翻译一下：ValueOf用来获取输入参数接口中的数据的值，如果接口为空则返回<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeOf returns the reflection Type that represents the dynamic type of i.</span></span><br><span class="line"><span class="comment">// If i is a nil interface value, TypeOf returns nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Type</span></span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">翻译一下：TypeOf用来动态获取输入参数接口中的值的类型，如果接口为空则返回<span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>reflect.TypeOf()是获取pair中的type，reflect.ValueOf()获取pair中的value。</p>
<p>首先需要把它转化成reflect对象(reflect.Type或者reflect.Value，根据不同的情况调用不同的函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t := reflect.TypeOf(i) <span class="comment">//得到类型的元数据,通过t我们能获取类型定义里面的所有元素</span></span><br><span class="line">v := reflect.ValueOf(i) <span class="comment">//得到实际的值，通过v我们获取存储在里面的值，还可以去改变值</span></span><br></pre></td></tr></table></figure>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//反射操作：通过反射，可以获取一个接口类型变量的 类型和数值</span></span><br><span class="line">	<span class="keyword">var</span> x <span class="keyword">float64</span> =<span class="number">3.4</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"type:"</span>,reflect.TypeOf(x)) <span class="comment">//type: float64</span></span><br><span class="line">	fmt.Println(<span class="string">"value:"</span>,reflect.ValueOf(x)) <span class="comment">//value: 3.4</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"-------------------"</span>)</span><br><span class="line">	<span class="comment">//根据反射的值，来获取对应的类型和数值</span></span><br><span class="line">	v := reflect.ValueOf(x)</span><br><span class="line">	fmt.Println(<span class="string">"kind is float64: "</span>,v.Kind() == reflect.Float64)</span><br><span class="line">	fmt.Println(<span class="string">"type : "</span>,v.Type())</span><br><span class="line">	fmt.Println(<span class="string">"value : "</span>,v.Float())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type: float64</span><br><span class="line">value: 3.4</span><br><span class="line">-------------------</span><br><span class="line">kind is float64:  true</span><br><span class="line">type :  float64</span><br><span class="line">value :  3.4</span><br></pre></td></tr></table></figure>
<p>说明</p>
<ol>
<li>reflect.TypeOf： 直接给到了我们想要的type类型，如float64、int、各种pointer、struct 等等真实的类型</li>
<li>reflect.ValueOf：直接给到了我们想要的具体的值，如1.2345这个具体数值，或者类似&amp;{1 “Allen.Wu” 25} 这样的结构体struct的值</li>
<li>也就是说明反射可以将“接口类型变量”转换为“反射类型对象”，反射类型指的是reflect.Type和reflect.Value这两种</li>
</ol>
<p>Type 和 Value 都包含了大量的方法，其中第一个有用的方法应该是 Kind，这个方法返回该类型的具体信息：Uint、Float64 等。Value 类型还包含了一系列类型方法，比如 Int()，用于返回对应的值。以下是Kind的种类：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// A Kind represents the specific kind of type that a Type represents.</span></span><br><span class="line"><span class="comment">// The zero Kind is not a valid kind.</span></span><br><span class="line"><span class="keyword">type</span> Kind <span class="keyword">uint</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Invalid Kind = <span class="literal">iota</span></span><br><span class="line">	Bool</span><br><span class="line">	Int</span><br><span class="line">	Int8</span><br><span class="line">	Int16</span><br><span class="line">	Int32</span><br><span class="line">	Int64</span><br><span class="line">	Uint</span><br><span class="line">	Uint8</span><br><span class="line">	Uint16</span><br><span class="line">	Uint32</span><br><span class="line">	Uint64</span><br><span class="line">	Uintptr</span><br><span class="line">	Float32</span><br><span class="line">	Float64</span><br><span class="line">	Complex64</span><br><span class="line">	Complex128</span><br><span class="line">	Array</span><br><span class="line">	Chan</span><br><span class="line">	Func</span><br><span class="line">	Interface</span><br><span class="line">	Map</span><br><span class="line">	Ptr</span><br><span class="line">	Slice</span><br><span class="line">	String</span><br><span class="line">	Struct</span><br><span class="line">	UnsafePointer</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="四、反射的规则"><a href="#四、反射的规则" class="headerlink" title="四、反射的规则"></a>四、反射的规则</h2><p>其实反射的操作步骤非常的简单，就是通过实体对象获取反射对象(Value、Type)，然后操作相应的方法即可。</p>
<p>下图描述了实例、Value、Type 三者之间的转换关系：</p>
<p><img src="https://github.com/rubyhan1314/Golang-100-Days/raw/master/Day16-20(Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6" alt="WX20190827-170219">/img/WX20190827-170219.png)</p>
<p>反射 API 的分类总结如下：</p>
<p><strong>1) 从实例到 Value</strong></p>
<p>通过实例获取 Value 对象，直接使用 reflect.ValueOf() 函数。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span> &#123;&#125;)</span> <span class="title">Value</span></span></span><br></pre></td></tr></table></figure>
<p><strong>2) 从实例到 Type</strong></p>
<p>通过实例获取反射对象的 Type，直接使用 reflect.TypeOf() 函数。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Type</span></span></span><br></pre></td></tr></table></figure>
<p><strong>3) 从 Type 到 Value</strong></p>
<p>Type 里面只有类型信息，所以直接从一个 Type 接口变量里面是无法获得实例的 Value 的，但可以通过该 Type 构建一个新实例的 Value。reflect 包提供了两种方法，示例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//New 返回的是一个 Value，该 Value 的 type 为 PtrTo(typ)，即 Value 的 Type 是指定 typ 的指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(typ Type)</span> <span class="title">Value</span></span></span><br><span class="line"><span class="comment">//Zero 返回的是一个 typ 类型的零佳，注意返回的 Value 不能寻址，位不可改变</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Zero</span><span class="params">(typ Type)</span> <span class="title">Value</span></span></span><br></pre></td></tr></table></figure>
<p>如果知道一个类型值的底层存放地址，则还有一个函数是可以依据 type 和该地址值恢复出 Value 的。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAt</span><span class="params">(typ Type, p unsafe.Pointer)</span> <span class="title">Value</span></span></span><br></pre></td></tr></table></figure>
<p><strong>4) 从 Value 到 Type</strong></p>
<p>从反射对象 Value 到 Type 可以直接调用 Value 的方法，因为 Value 内部存放着到 Type 类型的指针。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Type</span><span class="params">()</span> <span class="title">Type</span></span></span><br></pre></td></tr></table></figure>
<p><strong>5) 从 Value 到实例</strong></p>
<p>Value 本身就包含类型和值信息，reflect 提供了丰富的方法来实现从 Value 到实例的转换。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该方法最通用，用来将 Value 转换为空接口，该空接口内部存放具体类型实例</span></span><br><span class="line"><span class="comment">//可以使用接口类型查询去还原为具体的类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Interface</span><span class="params">()</span> （<span class="title">i</span> <span class="title">interface</span></span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Value 自身也提供丰富的方法，直接将 Value 转换为简单类型实例，如果类型不匹配，则直接引起 panic</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Bool</span> <span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Float</span><span class="params">()</span> <span class="title">float64</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Int</span><span class="params">()</span> <span class="title">int64</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Uint</span><span class="params">()</span> <span class="title">uint64</span></span></span><br></pre></td></tr></table></figure>
<p><strong>6) 从 Value 的指针到值</strong></p>
<p>从一个指针类型的 Value 获得值类型 Value 有两种方法，示例如下。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果 v 类型是接口，则 Elem() 返回接口绑定的实例的 Value，如采 v 类型是指针，则返回指针值的 Value，否则引起 panic</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Elem</span><span class="params">()</span> <span class="title">Value</span></span></span><br><span class="line"><span class="comment">//如果 v 是指针，则返回指针值的 Value，否则返回 v 自身，该函数不会引起 panic</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Indirect</span><span class="params">(v Value)</span> <span class="title">Value</span></span></span><br></pre></td></tr></table></figure>
<p><strong>7) Type 指针和值的相互转换</strong></p>
<p>指针类型 Type 到值类型 Type。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//t 必须是 Array、Chan、Map、Ptr、Slice，否则会引起 panic</span></span><br><span class="line"><span class="comment">//Elem 返回的是其内部元素的 Type</span></span><br><span class="line">t.Elem() Type</span><br></pre></td></tr></table></figure>
<p>值类型 Type 到指针类型 Type。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PtrTo 返回的是指向 t 的指针型 Type</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PtrTo</span><span class="params">(t Type)</span> <span class="title">Type</span></span></span><br></pre></td></tr></table></figure>
<p><strong>8) Value 值的可修改性</strong></p>
<p>Value 值的修改涉及如下两个方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过 CanSet 判断是否能修改</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value )</span> <span class="title">CanSet</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">//通过 Set 进行修改</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value )</span> <span class="title">Set</span><span class="params">(x Value)</span></span></span><br></pre></td></tr></table></figure>
<p>Value 值在什么情况下可以修改？我们知道实例对象传递给接口的是一个完全的值拷贝，如果调用反射的方法 reflect.ValueOf() 传进去的是一个值类型变量， 则获得的 Value 实际上是原对象的一个副本，这个 Value 是无论如何也不能被修改的。</p>
<p><strong>根据 Go 官方关于反射的博客，反射有三大定律：</strong></p>
<blockquote>
<ol>
<li>Reflection goes from interface value to reflection object.</li>
<li>Reflection goes from reflection object to interface value.</li>
<li>To modify a reflection object, the value must be settable.</li>
</ol>
</blockquote>
<p>第一条是最基本的：反射可以从接口值得到反射对象。</p>
<pre><code>    反射是一种检测存储在 interface中的类型和值机制。这可以通过 TypeOf函数和 ValueOf函数得到。
</code></pre><p>第二条实际上和第一条是相反的机制，反射可以从反射对象获得接口值。</p>
<pre><code>    它将 ValueOf的返回值通过 Interface()函数反向转变成 interface变量。
</code></pre><p>前两条就是说 接口型变量和 反射类型对象可以相互转化，反射类型对象实际上就是指的前面说的 reflect.Type和 reflect.Value。</p>
<p>第三条不太好懂：如果需要操作一个反射变量，则其值必须可以修改。</p>
<pre><code>    反射变量可设置的本质是它存储了原变量本身，这样对反射变量的操作，就会反映到原变量本身；反之，如果反射变量不能代表原变量，那么操作了反射变量，不会对原变量产生任何影响，这会给使用者带来疑惑。所以第二种情况在语言层面是不被允许的。
</code></pre><h2 id="五、反射的使用"><a href="#五、反射的使用" class="headerlink" title="五、反射的使用"></a>五、反射的使用</h2><h3 id="5-1-从relfect-Value中获取接口interface的信息"><a href="#5-1-从relfect-Value中获取接口interface的信息" class="headerlink" title="5.1 从relfect.Value中获取接口interface的信息"></a>5.1 从relfect.Value中获取接口interface的信息</h3><p>当执行reflect.ValueOf(interface)之后，就得到了一个类型为”relfect.Value”变量，可以通过它本身的Interface()方法获得接口变量的真实内容，然后可以通过类型判断进行转换，转换为原有真实类型。不过，我们可能是已知原有类型，也有可能是未知原有类型，因此，下面分两种情况进行说明。</p>
<h4 id="已知原有类型"><a href="#已知原有类型" class="headerlink" title="已知原有类型"></a>已知原有类型</h4><p>已知类型后转换为其对应的类型的做法如下，直接通过Interface方法然后强制转换，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">realValue := value.Interface().(已知的类型)</span><br></pre></td></tr></table></figure>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num <span class="keyword">float64</span> = <span class="number">1.2345</span></span><br><span class="line">	<span class="comment">// "接口类型变量"--&gt;"反射类型对象"</span></span><br><span class="line">	value := reflect.ValueOf(num)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 可以理解为“强制转换”，但是需要注意的时候，转换的时候，如果转换的类型不完全符合，则直接panic</span></span><br><span class="line">	<span class="comment">// Golang 对类型要求非常严格，类型一定要完全符合</span></span><br><span class="line">	<span class="comment">// 如下两个，一个是*float64，一个是float64，如果弄混，则会panic</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// "反射类型对象" --&gt; "接口类型变量"</span></span><br><span class="line">	convertValue := value.Interface().(<span class="keyword">float64</span>)</span><br><span class="line">    fmt.Println(convertValue)</span><br><span class="line">    </span><br><span class="line">    pointer := reflect.ValueOf(&amp;num)</span><br><span class="line">	convertPointer := pointer.Interface().(*<span class="keyword">float64</span>)</span><br><span class="line">	fmt.Println(convertPointer)</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0xc000098000</span><br><span class="line">1.2345</span><br></pre></td></tr></table></figure>
<p>说明</p>
<ol>
<li>转换的时候，如果转换的类型不完全符合，则直接panic，类型要求非常严格！</li>
<li>转换的时候，要区分是指针还是指</li>
<li>也就是说反射可以将“反射类型对象”再重新转换为“接口类型变量”</li>
</ol>
<h4 id="未知原有类型"><a href="#未知原有类型" class="headerlink" title="未知原有类型"></a>未知原有类型</h4><p>很多情况下，我们可能并不知道其具体类型，那么这个时候，该如何做呢？需要我们进行遍历探测其Filed来得知，示例如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age <span class="keyword">int</span></span><br><span class="line">	Sex <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span><span class="title">Say</span><span class="params">(msg <span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line">	fmt.Println(<span class="string">"hello，"</span>,msg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span><span class="title">PrintInfo</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"姓名：%s,年龄：%d，性别：%s\n"</span>,p.Name,p.Age,p.Sex)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p1 := Person&#123;<span class="string">"王二狗"</span>,<span class="number">30</span>,<span class="string">"男"</span>&#125;</span><br><span class="line"></span><br><span class="line">	DoFiledAndMethod(p1)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过接口来获取任意参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoFiledAndMethod</span><span class="params">(input <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	getType := reflect.TypeOf(input) <span class="comment">//先获取input的类型</span></span><br><span class="line">	fmt.Println(<span class="string">"get Type is :"</span>, getType.Name()) <span class="comment">// Person</span></span><br><span class="line">	fmt.Println(<span class="string">"get Kind is : "</span>, getType.Kind()) <span class="comment">// struct</span></span><br><span class="line"></span><br><span class="line">	getValue := reflect.ValueOf(input)</span><br><span class="line">	fmt.Println(<span class="string">"get all Fields is:"</span>, getValue) <span class="comment">//&#123;王二狗 30 男&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取方法字段</span></span><br><span class="line">	<span class="comment">// 1. 先获取interface的reflect.Type，然后通过NumField进行遍历</span></span><br><span class="line">	<span class="comment">// 2. 再通过reflect.Type的Field获取其Field</span></span><br><span class="line">	<span class="comment">// 3. 最后通过Field的Interface()得到对应的value</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; getType.NumField(); i++ &#123;</span><br><span class="line">		field := getType.Field(i)</span><br><span class="line">		value := getValue.Field(i).Interface() <span class="comment">//获取第i个值</span></span><br><span class="line">		fmt.Printf(<span class="string">"字段名称:%s, 字段类型:%s, 字段数值:%v \n"</span>, field.Name, field.Type, value)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过反射，操作方法</span></span><br><span class="line">	<span class="comment">// 1. 先获取interface的reflect.Type，然后通过.NumMethod进行遍历</span></span><br><span class="line">	<span class="comment">// 2. 再公国reflect.Type的Method获取其Method</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; getType.NumMethod(); i++ &#123;</span><br><span class="line">		method := getType.Method(i)</span><br><span class="line">		fmt.Printf(<span class="string">"方法名称:%s, 方法类型:%v \n"</span>, method.Name, method.Type)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">get Type is : Person</span><br><span class="line">get Kind is :  struct</span><br><span class="line">get all Fields is: &#123;王二狗 30 男&#125;</span><br><span class="line">字段名称:Name, 字段类型:string, 字段数值:王二狗 </span><br><span class="line">字段名称:Age, 字段类型:int, 字段数值:30 </span><br><span class="line">字段名称:Sex, 字段类型:string, 字段数值:男 </span><br><span class="line">方法名称:PrintInfo, 方法类型:func(main.Person) </span><br><span class="line">方法名称:Say, 方法类型:func(main.Person, string)</span><br></pre></td></tr></table></figure>
<p>说明</p>
<p>通过运行结果可以得知获取未知类型的interface的具体变量及其类型的步骤为：</p>
<ol>
<li>先获取interface的reflect.Type，然后通过NumField进行遍历</li>
<li>再通过reflect.Type的Field获取其Field</li>
<li>最后通过Field的Interface()得到对应的value</li>
</ol>
<p>通过运行结果可以得知获取未知类型的interface的所属方法（函数）的步骤为：</p>
<ol>
<li>先获取interface的reflect.Type，然后通过NumMethod进行遍历</li>
<li>再分别通过reflect.Type的Method获取对应的真实的方法（函数）</li>
<li>最后对结果取其Name和Type得知具体的方法名</li>
<li>也就是说反射可以将“反射类型对象”再重新转换为“接口类型变量”</li>
<li>struct 或者 struct 的嵌套都是一样的判断处理方式</li>
</ol>
<p>如果是struct的话，可以使用Elem()</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tag := t.Elem().Field(<span class="number">0</span>).Tag <span class="comment">//获取定义在struct里面的Tag属性</span></span><br><span class="line">name := v.Elem().Field(<span class="number">0</span>).String() <span class="comment">//获取存储在第一个字段里面的值</span></span><br></pre></td></tr></table></figure>
<h3 id="5-2-通过reflect-Value设置实际变量的值"><a href="#5-2-通过reflect-Value设置实际变量的值" class="headerlink" title="5.2 通过reflect.Value设置实际变量的值"></a>5.2 通过reflect.Value设置实际变量的值</h3><p>reflect.Value是通过reflect.ValueOf(X)获得的，只有当X是指针的时候，才可以通过reflec.Value修改实际变量X的值，即：要修改反射类型的对象就一定要保证其值是“addressable”的。</p>
<p>这里需要一个方法：</p>
<p><img src="https://github.com/rubyhan1314/Golang-100-Days/raw/master/Day16-20(Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6" alt="WX20190826-143547">/img/WX20190826-143547.png)</p>
<p>解释起来就是：Elem返回接口v包含的值或指针v指向的值。如果v的类型不是interface或ptr，它会恐慌。如果v为零，则返回零值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> num <span class="keyword">float64</span> = <span class="number">1.2345</span></span><br><span class="line">	fmt.Println(<span class="string">"old value of pointer:"</span>, num)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过reflect.ValueOf获取num中的reflect.Value，注意，参数必须是指针才能修改其值</span></span><br><span class="line">	pointer := reflect.ValueOf(&amp;num)</span><br><span class="line">	newValue := pointer.Elem()</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"type of pointer:"</span>, newValue.Type())</span><br><span class="line">	fmt.Println(<span class="string">"settability of pointer:"</span>, newValue.CanSet())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重新赋值</span></span><br><span class="line">	newValue.SetFloat(<span class="number">77</span>)</span><br><span class="line">	fmt.Println(<span class="string">"new value of pointer:"</span>, num)</span><br><span class="line"></span><br><span class="line">	<span class="comment">////////////////////</span></span><br><span class="line">	<span class="comment">// 如果reflect.ValueOf的参数不是指针，会如何？</span></span><br><span class="line">	<span class="comment">//pointer = reflect.ValueOf(num)</span></span><br><span class="line">	<span class="comment">//newValue = pointer.Elem() // 如果非指针，这里直接panic，“panic: reflect: call of reflect.Value.Elem on float64 Value”</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 另外一个demo</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age <span class="keyword">int</span></span><br><span class="line">	School <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s1 := Student&#123;<span class="string">"王二狗"</span>,<span class="number">19</span>,<span class="string">"北大"</span>&#125;</span><br><span class="line">	<span class="comment">//通过反射，更改对象的数值：前提也是数据可以被更改</span></span><br><span class="line">	fmt.Printf(<span class="string">"%T\n"</span>,s1) <span class="comment">//main.Student</span></span><br><span class="line">	p1 := &amp;s1</span><br><span class="line">	fmt.Printf(<span class="string">"%T\n"</span>,p1)  <span class="comment">//*main.Student</span></span><br><span class="line">	fmt.Println(s1.Name)</span><br><span class="line">	fmt.Println((*p1).Name,p1.Name)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//改变数值</span></span><br><span class="line">	value:=reflect.ValueOf(&amp;s1)</span><br><span class="line">	<span class="keyword">if</span> value.Kind() == reflect.Ptr&#123;</span><br><span class="line">		newValue:=value.Elem()</span><br><span class="line">		fmt.Println(newValue.CanSet())  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">		f1 :=newValue.FieldByName(<span class="string">"Name"</span>)</span><br><span class="line">		f1.SetString(<span class="string">"小明"</span>)</span><br><span class="line">		f3:=newValue.FieldByName(<span class="string">"School"</span>)</span><br><span class="line">		f3.SetString(<span class="string">"清华"</span>)</span><br><span class="line">		fmt.Println(s1)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">old value of pointer: 1.2345</span><br><span class="line">type of pointer: float64</span><br><span class="line">settability of pointer: true</span><br><span class="line">new value of pointer: 77</span><br></pre></td></tr></table></figure>
<p>说明</p>
<ol>
<li>需要传入的参数是<em> float64这个指针，然后可以通过pointer.Elem()去获取所指向的Value，<em>*注意一定要是指针</em></em>。</li>
<li>如果传入的参数不是指针，而是变量，那么<ul>
<li>通过Elem获取原始值对应的对象则直接panic</li>
<li>通过CanSet方法查询是否可以设置返回false</li>
</ul>
</li>
<li>newValue.CantSet()表示是否可以重新设置其值，如果输出的是true则可修改，否则不能修改，修改完之后再进行打印发现真的已经修改了。</li>
<li>reflect.Value.Elem() 表示获取原始值对应的反射对象，只有原始对象才能修改，当前反射对象是不能修改的</li>
<li>也就是说如果要修改反射类型对象，其值必须是“addressable”【对应的要传入的是指针，同时要通过Elem方法获取原始值对应的反射对象】</li>
<li>struct 或者 struct 的嵌套都是一样的判断处理方式</li>
</ol>
<h3 id="5-3-通过reflect-Value来进行方法的调用"><a href="#5-3-通过reflect-Value来进行方法的调用" class="headerlink" title="5.3 通过reflect.Value来进行方法的调用"></a>5.3 通过reflect.Value来进行方法的调用</h3><p>这算是一个高级用法了，前面我们只说到对类型、变量的几种反射的用法，包括如何获取其值、其类型、以及如何重新设置新值。但是在项目应用中，另外一个常用并且属于高级的用法，就是通过reflect来进行方法【函数】的调用。比如我们要做框架工程的时候，需要可以随意扩展方法，或者说用户可以自定义方法，那么我们通过什么手段来扩展让用户能够自定义呢？关键点在于用户的自定义方法是未可知的，因此我们可以通过reflect来搞定。</p>
<p>Call()方法：</p>
<p><img src="img/WX20190902-144001.png" alt="WX20190902-144001"></p>
<p><strong>通过反射，调用方法。</strong></p>
<p>先获取结构体对象，然后</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age <span class="keyword">int</span></span><br><span class="line">	Sex <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span><span class="title">Say</span><span class="params">(msg <span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line">	fmt.Println(<span class="string">"hello，"</span>,msg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span><span class="title">PrintInfo</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"姓名：%s,年龄：%d，性别：%s\n"</span>,p.Name,p.Age,p.Sex)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">Test</span><span class="params">(i,j <span class="keyword">int</span>,s <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">	fmt.Println(i,j,s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如何通过反射来进行方法的调用？</span></span><br><span class="line"><span class="comment">// 本来可以用结构体对象.方法名称()直接调用的，</span></span><br><span class="line"><span class="comment">// 但是如果要通过反射，</span></span><br><span class="line"><span class="comment">// 那么首先要将方法注册，也就是MethodByName，然后通过反射调动mv.Call</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p2 := Person&#123;<span class="string">"Ruby"</span>,<span class="number">30</span>,<span class="string">"男"</span>&#125;</span><br><span class="line">	<span class="comment">// 1. 要通过反射来调用起对应的方法，必须要先通过reflect.ValueOf(interface)来获取到reflect.Value，</span></span><br><span class="line">	<span class="comment">// 得到“反射类型对象”后才能做下一步处理</span></span><br><span class="line">	getValue := reflect.ValueOf(p2)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.一定要指定参数为正确的方法名</span></span><br><span class="line">	<span class="comment">// 先看看没有参数的调用方法</span></span><br><span class="line"></span><br><span class="line">	methodValue1 := getValue.MethodByName(<span class="string">"PrintInfo"</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"Kind : %s, Type : %s\n"</span>,methodValue1.Kind(),methodValue1.Type())</span><br><span class="line">	methodValue1.Call(<span class="literal">nil</span>) <span class="comment">//没有参数，直接写nil</span></span><br><span class="line"></span><br><span class="line">	args1 := <span class="built_in">make</span>([]reflect.Value, <span class="number">0</span>) <span class="comment">//或者创建一个空的切片也可以</span></span><br><span class="line">	methodValue1.Call(args1)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 有参数的方法调用</span></span><br><span class="line">	methodValue2 := getValue.MethodByName(<span class="string">"Say"</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"Kind : %s, Type : %s\n"</span>,methodValue2.Kind(),methodValue2.Type())</span><br><span class="line">	args2 := []reflect.Value&#123;reflect.ValueOf(<span class="string">"反射机制"</span>)&#125;</span><br><span class="line">	methodValue2.Call(args2)</span><br><span class="line"></span><br><span class="line">	methodValue3 := getValue.MethodByName(<span class="string">"Test"</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"Kind : %s, Type : %s\n"</span>,methodValue3.Kind(),methodValue3.Type())</span><br><span class="line">	args3 := []reflect.Value&#123;reflect.ValueOf(<span class="number">100</span>), reflect.ValueOf(<span class="number">200</span>),reflect.ValueOf(<span class="string">"Hello"</span>)&#125;</span><br><span class="line"></span><br><span class="line">	methodValue3.Call(args3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Kind : func, Type : func()</span><br><span class="line">姓名：Ruby,年龄：30，性别：男</span><br><span class="line">姓名：Ruby,年龄：30，性别：男</span><br><span class="line">Kind : func, Type : func(string)</span><br><span class="line">hello， 反射机制</span><br><span class="line">Kind : func, Type : func(int, int, string)</span><br><span class="line">100 200 Hello</span><br></pre></td></tr></table></figure>
<p><strong>通过反射，调用函数。</strong></p>
<p>首先我们要先确认一点，函数像普通的变量一样，之前的章节中我们在讲到函数的本质的时候，是可以把函数作为一种变量类型的，而且是引用类型。如果说Fun()是一个函数，那么f1 := Fun也是可以的，那么f1也是一个函数，如果直接调用f1()，那么运行的就是Fun()函数。</p>
<p>那么我们就先通过ValueOf()来获取函数的反射对象，可以判断它的Kind，是一个func，那么就可以执行Call()进行函数的调用。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//函数的反射</span></span><br><span class="line">	f1 := fun1</span><br><span class="line">	value := reflect.ValueOf(f1)</span><br><span class="line">	fmt.Printf(<span class="string">"Kind : %s , Type : %s\n"</span>,value.Kind(),value.Type()) <span class="comment">//Kind : func , Type : func()</span></span><br><span class="line"></span><br><span class="line">	value2 := reflect.ValueOf(fun2)</span><br><span class="line">	fmt.Printf(<span class="string">"Kind : %s , Type : %s\n"</span>,value2.Kind(),value2.Type()) <span class="comment">//Kind : func , Type : func(int, string)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过反射调用函数</span></span><br><span class="line">	value.Call(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	value2.Call([]reflect.Value&#123;reflect.ValueOf(<span class="number">100</span>),reflect.ValueOf(<span class="string">"hello"</span>)&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">"我是函数fun1()，无参的。。"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun2</span><span class="params">(i <span class="keyword">int</span>, s <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">"我是函数fun2()，有参数。。"</span>,i,s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong></p>
<ol>
<li>要通过反射来调用起对应的方法，必须要先通过reflect.ValueOf(interface)来获取到reflect.Value，得到“反射类型对象”后才能做下一步处理</li>
<li>reflect.Value.MethodByName这个MethodByName，需要指定准确真实的方法名字，如果错误将直接panic，MethodByName返回一个函数值对应的reflect.Value方法的名字。</li>
<li>[]reflect.Value，这个是最终需要调用的方法的参数，可以没有或者一个或者多个，根据实际参数来定。</li>
<li>reflect.Value的 Call 这个方法，这个方法将最终调用真实的方法，参数务必保持一致，如果reflect.Value.Kind不是一个方法，那么将直接panic。</li>
<li>本来可以用对象访问方法直接调用的，但是如果要通过反射，那么首先要将方法注册，也就是MethodByName，然后通过反射调用methodValue.Call</li>
</ol>
<p>本文参照：</p>
<p><a href="http://www.sohu.com/a/313420275_657921" target="_blank" rel="noopener">http://www.sohu.com/a/313420275_657921</a></p>
<p><a href="https://studygolang.com/articles/12348?fr=sidebar" target="_blank" rel="noopener">https://studygolang.com/articles/12348?fr=sidebar</a></p>
<p><a href="http://c.biancheng.net/golang/" target="_blank" rel="noopener">http://c.biancheng.net/golang/</a></p>
]]></content>
      <categories>
        <category>go</category>
        <category>reflect</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>reflect</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka -- 集群安装与配置（Docker）</title>
    <url>/2018/10/09/kafka-install-cluster-docker/</url>
    <content><![CDATA[<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="文件列表"><a href="#文件列表" class="headerlink" title="文件列表"></a>文件列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">└── docker-compose.yml</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">zk1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">confluentinc/cp-zookeeper:latest</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zk1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zk1</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"12181:2181"</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ZOOKEEPER_SERVER_ID:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">ZOOKEEPER_CLIENT_PORT:</span> <span class="number">2181</span></span><br><span class="line">      <span class="attr">ZOOKEEPER_TICK_TIME:</span> <span class="number">2000</span></span><br><span class="line">      <span class="attr">ZOOKEEPER_INIT_LIMIT:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">ZOOKEEPER_SYNC_LIMIT:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">ZOOKEEPER_SERVERS:</span> <span class="string">zk1:12888:13888;zk2:22888:23888;zk3:32888:33888</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">zk2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">confluentinc/cp-zookeeper:latest</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zk2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zk2</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"22181:2181"</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ZOOKEEPER_SERVER_ID:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">ZOOKEEPER_CLIENT_PORT:</span> <span class="number">2181</span></span><br><span class="line">      <span class="attr">ZOOKEEPER_TICK_TIME:</span> <span class="number">2000</span></span><br><span class="line">      <span class="attr">ZOOKEEPER_INIT_LIMIT:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">ZOOKEEPER_SYNC_LIMIT:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">ZOOKEEPER_SERVERS:</span> <span class="string">zk1:12888:13888;zk2:22888:23888;zk3:32888:33888</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">zk3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">confluentinc/cp-zookeeper:latest</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zk3</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zk3</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"32181:2181"</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ZOOKEEPER_SERVER_ID:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">ZOOKEEPER_CLIENT_PORT:</span> <span class="number">2181</span></span><br><span class="line">      <span class="attr">ZOOKEEPER_TICK_TIME:</span> <span class="number">2000</span></span><br><span class="line">      <span class="attr">ZOOKEEPER_INIT_LIMIT:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">ZOOKEEPER_SYNC_LIMIT:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">ZOOKEEPER_SERVERS:</span> <span class="string">zk1:12888:13888;zk2:22888:23888;zk3:32888:33888</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">kafka1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">confluentinc/cp-kafka:latest</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">kafka1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kafka1</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zk1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zk2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zk3</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">KAFKA_BROKER_ID:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">KAFKA_ZOOKEEPER_CONNECT:</span> <span class="string">zk1:2181,zk2:2181,zk3:2181</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_LISTENERS:</span> <span class="string">PLAINTEXT://kafka1:9092</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">kafka2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">confluentinc/cp-kafka:latest</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">kafka2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kafka2</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zk1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zk2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zk3</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">KAFKA_BROKER_ID:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">KAFKA_ZOOKEEPER_CONNECT:</span> <span class="string">zk1:2181,zk2:2181,zk3:2181</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_LISTENERS:</span> <span class="string">PLAINTEXT://kafka2:9092</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">kafka3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">confluentinc/cp-kafka:latest</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">kafka3</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kafka3</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zk1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zk2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zk3</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">KAFKA_BROKER_ID:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">KAFKA_ZOOKEEPER_CONNECT:</span> <span class="string">zk1:2181,zk2:2181,zk3:2181</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_LISTENERS:</span> <span class="string">PLAINTEXT://kafka3:9092</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">kafka_manager:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">hlebalbau/kafka-manager:latest</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">kafka_manager</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kafka_manager</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"9000:9000"</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ZK_HOSTS:</span> <span class="string">"zk1:2181,zk2:2181,zk3:2181"</span></span><br><span class="line">      <span class="attr">APPLICATION_SECRET:</span> <span class="string">"random-secret"</span></span><br><span class="line">      <span class="attr">KAFKA_MANAGER_AUTH_ENABLED:</span> <span class="string">"true"</span></span><br><span class="line">      <span class="attr">KAFKA_MANAGER_USERNAME:</span> <span class="string">action</span></span><br><span class="line">      <span class="attr">KAFKA_MANAGER_PASSWORD:</span> <span class="string">action</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">-Dpidfile.path=/dev/null</span></span><br></pre></td></tr></table></figure>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker-compose up -d</span><br><span class="line">Creating network <span class="string">"kafka_default"</span> with the default driver</span><br><span class="line">Creating zk2           ... <span class="keyword">done</span></span><br><span class="line">Creating zk3           ... <span class="keyword">done</span></span><br><span class="line">Creating kafka_manager ... <span class="keyword">done</span></span><br><span class="line">Creating zk1           ... <span class="keyword">done</span></span><br><span class="line">Creating kafka1        ... <span class="keyword">done</span></span><br><span class="line">Creating kafka2        ... <span class="keyword">done</span></span><br><span class="line">Creating kafka3        ... <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">$ docker-compose ps</span><br><span class="line">    Name                   Command               State                      Ports</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">kafka1          /etc/confluent/docker/run        Up      9092/tcp</span><br><span class="line">kafka2          /etc/confluent/docker/run        Up      9092/tcp</span><br><span class="line">kafka3          /etc/confluent/docker/run        Up      9092/tcp</span><br><span class="line">kafka_manager   /kafka-manager/bin/kafka-m ...   Up      0.0.0.0:9000-&gt;9000/tcp</span><br><span class="line">zk1             /etc/confluent/docker/run        Up      0.0.0.0:12181-&gt;2181/tcp, 2888/tcp, 3888/tcp</span><br><span class="line">zk2             /etc/confluent/docker/run        Up      0.0.0.0:22181-&gt;2181/tcp, 2888/tcp, 3888/tcp</span><br><span class="line">zk3             /etc/confluent/docker/run        Up      0.0.0.0:32181-&gt;2181/tcp, 2888/tcp, 3888/tcp</span><br></pre></td></tr></table></figure>
<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入kafka1</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it kafka1 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建主题</span></span><br><span class="line">root@kafka1:/<span class="comment"># kafka-topics --zookeeper zk1:2181,zk2:2181,zk3:2181 --replication-factor 1 --partitions 1 --create --topic first Created topic "first"</span></span><br><span class="line"></span><br><span class="line">root@kafka1:/<span class="comment"># kafka-topics --zookeeper zk1:2181,zk2:2181,zk3:2181 --describe --topic first</span></span><br><span class="line"></span><br><span class="line">Topic: first	PartitionCount: 1	ReplicationFactor: 1	Configs: </span><br><span class="line">	Topic: first	Partition: 0	Leader: 1	Replicas: 1	Isr: 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送消息</span></span><br><span class="line">root@kafka1:/<span class="comment"># kafka-console-producer --broker-list kafka1:9092,kafka2:9092,kafka3:9092 --topic=first</span></span><br><span class="line">&gt;hello</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<h3 id="读取消息"><a href="#读取消息" class="headerlink" title="读取消息"></a>读取消息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入kafka2</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it kafka2 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取消息</span></span><br><span class="line">root@kafka2:/<span class="comment"># kafka-console-consumer --bootstrap-server kafka1:9092,kafka2:9092,kafka3:9092 --topic first --from-beginning</span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure>
<h3 id="管理后台"><a href="#管理后台" class="headerlink" title="管理后台"></a>管理后台</h3><p><a href="http://192.168.1.86:9000/clusters/docker-kafka/topics/first" target="_blank" rel="noopener">http://192.168.1.86:9000/clusters/docker-kafka/topics/first</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看防火墙状态</span><br><span class="line">firewall-cmd --state</span><br><span class="line">关闭防火墙</span><br><span class="line">systemctl stop firewalld.service</span><br></pre></td></tr></table></figure>
<h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-compose down</span><br><span class="line">Stopping kafka2        ... done</span><br><span class="line">Stopping kafka1        ... done</span><br><span class="line">Stopping kafka3        ... done</span><br><span class="line">Stopping zk1           ... done</span><br><span class="line">Stopping kafka_manager ... done</span><br><span class="line">Stopping zk3           ... done</span><br><span class="line">Stopping zk2           ... done</span><br><span class="line">Removing kafka2        ... done</span><br><span class="line">Removing kafka1        ... done</span><br><span class="line">Removing kafka3        ... done</span><br><span class="line">Removing zk1           ... done</span><br><span class="line">Removing kafka_manager ... done</span><br><span class="line">Removing zk3           ... done</span><br><span class="line">Removing zk2           ... done</span><br><span class="line">Removing network kafka_default</span><br></pre></td></tr></table></figure>
<!-- indicate-the-source -->
<h4 id="转载：http-zhongmingmao-me-2018-10-08-kafka-install-cluster-docker"><a href="#转载：http-zhongmingmao-me-2018-10-08-kafka-install-cluster-docker" class="headerlink" title="转载：http://zhongmingmao.me/2018/10/08/kafka-install-cluster-docker/"></a>转载：<a href="http://zhongmingmao.me/2018/10/08/kafka-install-cluster-docker/" target="_blank" rel="noopener">http://zhongmingmao.me/2018/10/08/kafka-install-cluster-docker/</a></h4>]]></content>
      <categories>
        <category>Middleware</category>
        <category>MQ</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Middleware</tag>
        <tag>MQ</tag>
        <tag>Kafka</tag>
        <tag>Stream</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka -- 拦截器</title>
    <url>/2019/08/13/kafka-interceptor/</url>
    <content><![CDATA[<h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><ol>
<li>基本思想：允许应用程序在不修改逻辑的情况下，动态地实现一组<strong>可插拔</strong>的事件处理逻辑链</li>
<li>拦截器能够在主业务操作的前后多个时间点上插入对应的拦截逻辑</li>
<li>以配置<strong>拦截器类</strong>的方式<strong>动态</strong>插入到应用程序中，可以快速地切换不同的拦截器，而不影响主程序逻辑</li>
</ol>
<a id="more"></a>
<h2 id="Kafka拦截器"><a href="#Kafka拦截器" class="headerlink" title="Kafka拦截器"></a>Kafka拦截器</h2><ol>
<li>Kafka拦截器自<strong>0.10.0.0</strong>版本被引入后并未得到太多的实际应用</li>
<li>Kafka拦截器分为<strong>生产者拦截器</strong>和<strong>消费者拦截器</strong><ul>
<li><strong>生产者拦截器</strong>：允许在<strong>发送消息前</strong>以及<strong>消息提交成功后</strong>植入拦截逻辑</li>
<li><strong>消费者拦截器</strong>：允许在<strong>消费消息前</strong>以及<strong>提交位移后</strong>植入拦截逻辑</li>
</ul>
</li>
<li>Kafka拦截器支持<strong>链式调用</strong>，Kafka会按照<strong>添加顺序</strong>依次执行拦截器逻辑</li>
<li>Kafka拦截器通过参数<code>interceptor.classes</code>来配置（生产者和消费者一致）<ul>
<li>指定拦截器类时需要使用<strong>全限定名</strong></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line">props.put(<span class="string">"key.serializer"</span>, StringSerializer<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">props.put(<span class="string">"value.serializer"</span>, StringSerializer<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">List&lt;String&gt; interceptors = Lists.newArrayList();</span><br><span class="line">interceptors.add(AddTimeStampInterceptor<span class="class">.<span class="keyword">class</span>.<span class="title">getCanonicalName</span>())</span>;</span><br><span class="line">interceptors.add(UpdateCounterInterceptor<span class="class">.<span class="keyword">class</span>.<span class="title">getCanonicalName</span>())</span>;</span><br><span class="line">props.put(ProducerConfig.INTERCEPTOR_CLASSES_CONFIG, interceptors);</span><br><span class="line">producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br></pre></td></tr></table></figure>
<h3 id="生产者拦截器"><a href="#生产者拦截器" class="headerlink" title="生产者拦截器"></a>生产者拦截器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProducerInterceptor</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Configurable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 消息发送之前</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProducerRecord&lt;K, V&gt; <span class="title">onSend</span><span class="params">(ProducerRecord&lt;K, V&gt; record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息成功提交或发送失败之后，onAcknowledgement要早于callback</span></span><br><span class="line">    <span class="comment">// onAcknowledgement和onSend不是在同一个线程中被调用，需要保证线程安全</span></span><br><span class="line">    <span class="comment">// onAcknowledgement在Producer发送的主路径中，避免嵌入太重的逻辑，否则会影响TPS</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAcknowledgement</span><span class="params">(RecordMetadata metadata, Exception exception)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消费者拦截器"><a href="#消费者拦截器" class="headerlink" title="消费者拦截器"></a>消费者拦截器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConsumerInterceptor</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Configurable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 消息返回给Consumer之前（即开始正式处理消息之前）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConsumerRecords&lt;K, V&gt; <span class="title">onConsume</span><span class="params">(ConsumerRecords&lt;K, V&gt; records)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Consumer提交位移之后</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCommit</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="案例：端到端延时"><a href="#案例：端到端延时" class="headerlink" title="案例：端到端延时"></a>案例：端到端延时</h2><ol>
<li>Kafka默认提供的监控指标都是针对单个<strong>客户端</strong>或者<strong>Broker</strong>，缺少<strong>消息维度</strong>的监控</li>
<li>如何<strong>追踪</strong>一条消息在<strong>集群间的流转路径</strong></li>
<li>如何<strong>监控</strong>一条消息从生产到消费的<strong>端到端延时</strong></li>
</ol>
<h3 id="生产者拦截器-1"><a href="#生产者拦截器-1" class="headerlink" title="生产者拦截器"></a>生产者拦截器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvgLatencyProducerInterceptor</span> <span class="keyword">implements</span> <span class="title">ProducerInterceptor</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProducerRecord&lt;String, String&gt; <span class="title">onSend</span><span class="params">(ProducerRecord&lt;String, String&gt; record)</span> </span>&#123;</span><br><span class="line">        jedis.incr(<span class="string">"totalSentMessage"</span>);</span><br><span class="line">        <span class="keyword">return</span> record;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAcknowledgement</span><span class="params">(RecordMetadata metadata, Exception exception)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;String, ?&gt; configs)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消费者拦截器-1"><a href="#消费者拦截器-1" class="headerlink" title="消费者拦截器"></a>消费者拦截器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvgLatencyConsumerInterceptor</span> <span class="keyword">implements</span> <span class="title">ConsumerInterceptor</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConsumerRecords&lt;String, String&gt; <span class="title">onConsume</span><span class="params">(ConsumerRecords&lt;String, String&gt; records)</span> </span>&#123;</span><br><span class="line">        AtomicLong latency = <span class="keyword">new</span> AtomicLong(<span class="number">0L</span>);</span><br><span class="line">        records.forEach(record -&gt; latency.addAndGet(System.currentTimeMillis() - record.timestamp()));</span><br><span class="line">        jedis.incrBy(<span class="string">"totalLatency"</span>, latency.get());</span><br><span class="line">        <span class="keyword">long</span> totalLatency = Long.parseLong(jedis.get(<span class="string">"totalLatency"</span>));</span><br><span class="line">        <span class="keyword">long</span> totalSentMessage = Long.parseLong(jedis.get(<span class="string">"totalSentMessage"</span>));</span><br><span class="line">        jedis.set(<span class="string">"avgLatency"</span>, String.valueOf(totalLatency / totalSentMessage));</span><br><span class="line">        <span class="keyword">return</span> records;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCommit</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;String, ?&gt; configs)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="转载：http-zhongmingmao-me-2019-08-13-kafka-interceptor"><a href="#转载：http-zhongmingmao-me-2019-08-13-kafka-interceptor" class="headerlink" title="转载：http://zhongmingmao.me/2019/08/13/kafka-interceptor/"></a>转载：<a href="http://zhongmingmao.me/2019/08/13/kafka-interceptor/" target="_blank" rel="noopener">http://zhongmingmao.me/2019/08/13/kafka-interceptor/</a></h4>]]></content>
      <categories>
        <category>Middleware</category>
        <category>MQ</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Middleware</tag>
        <tag>MQ</tag>
        <tag>Kafka</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka -- 监控消费进度</title>
    <url>/2019/09/12/kafka-monitor-consume-progress/</url>
    <content><![CDATA[<h2 id="Consumer-Lag"><a href="#Consumer-Lag" class="headerlink" title="Consumer Lag"></a>Consumer Lag</h2><ol>
<li>Consumer Lag（滞后程度）：<strong>消费者当前落后于生产者的程度</strong></li>
<li>Lag的单位是<strong>消息数</strong>，一般是在<strong>主题</strong>的级别上讨论Lag，但Kafka是在<strong>分区</strong>的级别上<strong>监控</strong>Lag，因此需要手动汇总</li>
<li>对于消费者而言，Lag是<strong>最重要</strong>的监控指标，直接反应了一个消费者的运行情况<ul>
<li>一个正常工作的消费者，它的Lag值应该很小，甚至<strong>接近于0</strong>，<strong>滞后程度很小</strong></li>
<li>如果Lag很大，表明消费者无法跟上生产者的速度，Lag会越来越大<ul>
<li>极有可能导致消费者消费的数据已经不在<strong>操作系统的页缓存</strong>中了，这些数据会失去享有<strong>Zero Copy</strong>技术的资格</li>
<li>这样消费者不得不从<strong>磁盘</strong>读取这些数据，这将<strong>进一步拉大</strong>与生产者的差距</li>
<li>马太效应：<em><strong>Lag原本就很大的消费者会越来越慢，Lag也会也来越大</strong></em></li>
</ul>
</li>
</ul>
</li>
</ol>
<a id="more"></a>
<h2 id="监控Lag"><a href="#监控Lag" class="headerlink" title="监控Lag"></a>监控Lag</h2><h3 id="Kafka自带命令"><a href="#Kafka自带命令" class="headerlink" title="Kafka自带命令"></a>Kafka自带命令</h3><ol>
<li><code>kafka-consumer-groups</code>是Kafka提供的<strong>最直接</strong>的监控消费者消费进度的工具<ul>
<li>也能监控<strong>独立消费者</strong>的Lag，独立消费者是没有使用<strong>消费者组机制</strong>的消费者程序，也要配置<code>group.id</code></li>
<li><strong>消费者组</strong>要调用<code>KafkaConsumer.subscribe</code>，<strong>独立消费者</strong>要调用<code>KafkaConsumer.assign</code><strong>直接消费指定分区</strong></li>
</ul>
</li>
<li>输出信息<ul>
<li>消费者组、主题、分区、消费者实例ID、消费者连接Broker的主机名、消费者的CLIENT-ID信息</li>
<li><strong>CURRENT-OFFSET</strong>：消费者组当前最新消费消息的位移值</li>
<li><strong>LOG-END-OFFSET</strong>：每个分区当前最新生产的消息的位移值</li>
<li><strong>LAG</strong>：LOG-END-OFFSET和CURRENT-OFFSET的<strong>差值</strong></li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kafka-consumer-groups --bootstrap-server localhost:9092 --describe --group zhongmingmao</span><br><span class="line"></span><br><span class="line">GROUP           TOPIC           PARTITION  CURRENT-OFFSET  LOG-END-OFFSET  LAG             CONSUMER-ID                                     HOST            CLIENT-ID</span><br><span class="line">zhongmingmao    zhongmingmao    1          5               5               0               consumer-1-24d9f1a8-662a-4d20-a360-26a12ddb0902 &#x2F;192.168.2.1    consumer-1</span><br><span class="line">zhongmingmao    zhongmingmao    0          5               5               0               consumer-1-24d9f1a8-662a-4d20-a360-26a12ddb0902 &#x2F;192.168.2.1    consumer-1</span><br><span class="line">zhongmingmao    zhongmingmao    4          6               6               0               consumer-1-24d9f1a8-662a-4d20-a360-26a12ddb0902 &#x2F;192.168.2.1    consumer-1</span><br><span class="line">zhongmingmao    zhongmingmao    3          6               6               0               consumer-1-24d9f1a8-662a-4d20-a360-26a12ddb0902 &#x2F;192.168.2.1    consumer-1</span><br><span class="line">zhongmingmao    zhongmingmao    2          6               6               0               consumer-1-24d9f1a8-662a-4d20-a360-26a12ddb0902 &#x2F;192.168.2.1    consumer-1</span><br><span class="line"></span><br><span class="line">$ kafka-consumer-groups --bootstrap-server localhost:9092 --describe --group zhongmingmao</span><br><span class="line"></span><br><span class="line">Consumer group &#39;zhongmingmao&#39; has no active members.</span><br><span class="line"></span><br><span class="line">GROUP           TOPIC           PARTITION  CURRENT-OFFSET  LOG-END-OFFSET  LAG             CONSUMER-ID     HOST            CLIENT-ID</span><br><span class="line">zhongmingmao    zhongmingmao    1          5               5               0               -               -               -</span><br><span class="line">zhongmingmao    zhongmingmao    0          5               5               0               -               -               -</span><br><span class="line">zhongmingmao    zhongmingmao    4          6               6               0               -               -               -</span><br><span class="line">zhongmingmao    zhongmingmao    3          6               6               0               -               -               -</span><br><span class="line">zhongmingmao    zhongmingmao    2          6               6               0               -               -               -</span><br></pre></td></tr></table></figure>
<h3 id="Kafka-Java-Consumer-API"><a href="#Kafka-Java-Consumer-API" class="headerlink" title="Kafka Java Consumer API"></a>Kafka Java Consumer API</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Map&lt;TopicPartition, Long&gt; <span class="title">lagOf</span><span class="params">(String groupId, String bootstrapServers)</span> <span class="keyword">throws</span> TimeoutException </span>&#123;</span><br><span class="line">    Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">    props.put(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);</span><br><span class="line">    <span class="keyword">try</span> (AdminClient client = AdminClient.create(props)) &#123;</span><br><span class="line">        <span class="comment">// 获取给定消费者组的最新消费消息的位移</span></span><br><span class="line">        ListConsumerGroupOffsetsResult result = client.listConsumerGroupOffsets(groupId);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Map&lt;TopicPartition, OffsetAndMetadata&gt; consumedOffsets = result.partitionsToOffsetAndMetadata().get(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">            props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="keyword">false</span>); <span class="comment">// 禁止自动提交位移</span></span><br><span class="line">            props.put(ConsumerConfig.GROUP_ID_CONFIG, groupId);</span><br><span class="line">            props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">            props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">            <span class="keyword">try</span> (<span class="keyword">final</span> KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props)) &#123;</span><br><span class="line">                <span class="comment">// 获取订阅分区的最新消息位移</span></span><br><span class="line">                Map&lt;TopicPartition, Long&gt; endOffsets = consumer.endOffsets(consumedOffsets.keySet());</span><br><span class="line">                <span class="keyword">return</span> endOffsets.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey,</span><br><span class="line">                        <span class="comment">// 计算Lag</span></span><br><span class="line">                        entry -&gt; entry.getValue() - consumedOffsets.get(entry.getKey()).offset()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 处理中断异常</span></span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(<span class="string">"Timed out when getting lag for consumer group "</span> + groupId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLagTest</span><span class="params">()</span> <span class="keyword">throws</span> TimeoutException </span>&#123;</span><br><span class="line">    lagOf(<span class="string">"zhongmingmao"</span>, <span class="string">"localhost:9092"</span>)</span><br><span class="line">            .forEach((topicPartition, lag) -&gt; log.info(<span class="string">"partition: &#123;&#125;, lag: &#123;&#125;"</span>, topicPartition, lag));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">partition: zhongmingmao-1, lag: 0</span><br><span class="line">partition: zhongmingmao-0, lag: 0</span><br><span class="line">partition: zhongmingmao-4, lag: 0</span><br><span class="line">partition: zhongmingmao-3, lag: 0</span><br><span class="line">partition: zhongmingmao-2, lag: 0</span><br></pre></td></tr></table></figure>
<h3 id="Kafka-JMX-监控指标"><a href="#Kafka-JMX-监控指标" class="headerlink" title="Kafka JMX 监控指标"></a>Kafka JMX 监控指标</h3><ol>
<li>上面的两种方式，都可以很方便地查询到给定消费者组的Lag信息</li>
<li>但在实际监控场景中，往往需要借助现成的<strong>监控框架</strong>（如<strong>Zabbix/Grafana</strong>）<ul>
<li>此时可以选择Kafka默认提供的<strong>JMX监控指标</strong>来监控消费者的Lag值</li>
</ul>
</li>
<li><strong>消费者</strong>提供了<code>kafka.consumer:type=consumer-fetch-manager-metrics,client-id=&quot;{client-id}&quot;</code>的JMX指标<ul>
<li><code>records-lag-max</code>和<code>records-lead-min</code>分别代表此<strong>消费者</strong>在<strong>测试窗口时间</strong>内曾经达到的<strong>最大Lag值</strong>和<strong>最小Lead值</strong></li>
<li>Lead：消费者<strong>最新消费消息的位移</strong>与<strong>当前分区第一条消息位移</strong>的差值，<em><strong>Lag越大，Lead越小</strong></em></li>
<li>一旦监测到<strong>Lead</strong>越来越小，甚至<strong>快接近于0</strong>，预示着消费者端要<strong>丢消息</strong>了</li>
<li>Kafka消息是有<strong>留存时间</strong>的，默认是<strong>1周</strong>，如果消费者程序足够慢，慢到它要消费的数据快被Kafka<strong>删除</strong><ul>
<li>一旦出现消息被删除，从而导致消费者程序<strong>重新调整位移值</strong>的情况，可能产生两个后果</li>
<li>一个是消费者<strong>从头消费一遍</strong>数据</li>
<li>另一个是消费者从<strong>最新的消息位移处</strong>开始消费，之前<strong>没来得及消费的消息</strong>全部被<strong>跳过</strong>，造成<strong>丢消息的假象</strong></li>
</ul>
</li>
<li>Lag值从100W增加到200W，远不如Lead值从200减少到100重要，实际生产环境中，要<strong>同时监控Lag值和Lead值</strong></li>
</ul>
</li>
<li><strong>消费者</strong>还在<strong>分区级别</strong>提供了额外的JMX指标，用于<strong>单独监控</strong>分区级别的Lag和Lead值<ul>
<li><code>kafka.consumer:type=consumer-fetch-manager-metrics,client-id=&quot;{client-id}&quot;,topic=&quot;{topic}&quot;,partition=&quot;{partition}&quot;</code></li>
<li>多了<code>records-lag-avg</code>和<code>records-lead-avg</code>，可以计算<strong>平均</strong>的Lag值和Lead值，经常使用</li>
</ul>
</li>
</ol>
<p><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-consumer-jmx-lag-lead.png" width=1000/><br><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-consumer-jmx-partition-lag-lead.png" width=1000/></p>
<p>参考：<a href="http://zhongmingmao.me/2019/09/12/kafka-monitor-consume-progress/" target="_blank" rel="noopener">http://zhongmingmao.me/2019/09/12/kafka-monitor-consume-progress/</a></p>
]]></content>
      <categories>
        <category>Middleware</category>
        <category>MQ</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Middleware</tag>
        <tag>MQ</tag>
        <tag>Kafka</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka -- 监控</title>
    <url>/2019/09/29/kafka-monitor/</url>
    <content><![CDATA[<h2 id="主机监控"><a href="#主机监控" class="headerlink" title="主机监控"></a>主机监控</h2><ol>
<li>主机监控：监控Kafka集群Broker所在的节点机器的性能</li>
<li>常见的主机监控指标<ul>
<li><strong>机器负载</strong></li>
<li><strong>CPU使用率</strong></li>
<li><strong>内存使用率</strong>，包括空闲内存和已使用内存</li>
<li><strong>磁盘IO使用率</strong>，包括读使用率和写使用率</li>
<li><strong>网络IO使用率</strong></li>
<li><strong>TCP连接数</strong></li>
<li><strong>打开文件数</strong></li>
<li><strong>inode使用情况</strong></li>
</ul>
</li>
</ol>
<a id="more"></a>
<h2 id="JVM监控"><a href="#JVM监控" class="headerlink" title="JVM监控"></a>JVM监控</h2><ol>
<li>重点指标<ul>
<li>Full GC发生频率和时长</li>
<li>活跃对象大小</li>
<li>应用线程总数</li>
</ul>
</li>
<li>设置堆大小<ul>
<li>经历一次<strong>Full GC</strong>后，堆上存活的活跃对象大小为S，可以安全地将<strong>老年代</strong>堆大小设置为<strong>1.5S</strong>或者<strong>2S</strong></li>
</ul>
</li>
<li>从<strong>0.9.0.0</strong>版本开始，社区将默认的GC收集器设置为<strong>G1</strong>，而G1的<strong>Full GC</strong>是由<strong>单线程</strong>执行的，速度<strong>非常慢</strong><ul>
<li>一旦发现Broker进程<strong>频繁Full GC</strong>，可以开启G1的<strong><code>-XX:+PrintAdaptiveSizePolicy</code></strong>，获知引发Full GC的<strong>原因</strong></li>
</ul>
</li>
</ol>
<h2 id="集群监控"><a href="#集群监控" class="headerlink" title="集群监控"></a>集群监控</h2><ol>
<li>查看Broker进程是否启动，端口是否建立<ul>
<li>在容器化的Kafka环境，容器虽然启动成功，但由于网络配置有误，会出现进程已经启动但端口未成功监听的情形</li>
</ul>
</li>
<li>查看Broker端<strong>关键日志</strong><ul>
<li>Broker端服务器日志<strong>server.log</strong> — 最重要</li>
<li>控制器日志<strong>controller.log</strong></li>
<li>主题分区状态变更日志<strong>state-change.log</strong></li>
</ul>
</li>
<li>查看Broker端<strong>关键线程</strong>的运行状态<ul>
<li>这些关键线程的<strong>意外挂掉</strong>，往往<strong>无声无息</strong>，但却影响巨大</li>
<li><strong>Log Compaction</strong>线程，这类线程以<code>kafka-log-cleaner-thread</code>开头<ul>
<li>挂掉后，所有Compaction操作都会中断，导致Kafka内部的<strong>位移主题</strong>所占用的磁盘空间越来越大</li>
</ul>
</li>
<li><strong>副本拉取消息</strong>的线程，通常以<code>ReplicaFetcherThread</code>开头<ul>
<li>挂掉后，系统会表现为对应Follower副本不再从Leader副本拉取消息，Follower副本的<strong>Lag</strong>会越来越大</li>
</ul>
</li>
</ul>
</li>
<li>查看Broker端<strong>关键JMX指标</strong><ul>
<li><strong>BytesIn/BytesOut</strong><ul>
<li><code>kafka.server:type=BrokerTopicMetrics,name=BytesInPerSec</code></li>
<li><code>kafka.server:type=BrokerTopicMetrics,name=BytesOutPerSec</code></li>
<li>Broker端每秒入站和出站字节数，要确保这组值<strong>不要接近网络带宽</strong>，容易出现<strong>网络丢包</strong>的情形</li>
</ul>
</li>
<li><strong>NetworkProcessorAvgIdlePercent</strong><ul>
<li><code>kafka.network:type=SocketServer,name=NetworkProcessorAvgIdlePercent</code></li>
<li><strong>网络线程池平均的空闲比例</strong>，要确保该值长期大于<strong>30%</strong></li>
</ul>
</li>
<li><strong>RequestHandlerAvgIdlePercent</strong><ul>
<li><code>kafka.server:type=KafkaRequestHandlerPool,name=RequestHandlerAvgIdlePercent</code></li>
<li><strong>IO线程池平均的空闲比例</strong>，要确保该值长期大于<strong>30%</strong></li>
</ul>
</li>
<li><strong>UnderReplicatedPartitions</strong><ul>
<li><code>kafka.server:type=ReplicaManager,name=UnderReplicatedPartitions</code></li>
<li>未充分备份的分区数，一般为0<ul>
<li>未充分备份，即<strong>并非所有的Follower副本都和Leader副本保持同步</strong>，此时可能会出现<strong>数据丢失</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>ISRShrink/ISRExpand</strong><ul>
<li><code>kafka.server:type=ReplicaManager,name=IsrShrinksPerSec</code></li>
<li><code>kafka.server:type=ReplicaManager,name=IsrExpandsPerSec</code></li>
<li>ISR收缩和扩容的频次指标</li>
</ul>
</li>
<li><strong>ActiveControllerCount</strong><ul>
<li><code>kafka.controller:type=KafkaController,name=ActiveControllerCount</code></li>
<li>当前处于<strong>激活状态</strong>的控制器数量<ul>
<li>正常情况下，Controller所在Broker上的这个JMX指标值为1，其它Broker上这个值为0</li>
<li>如果发现存在<strong>多台Broker</strong>上该值都是<strong>1</strong>时，通常表明集群中出现了<strong>脑裂</strong>，此时一定要查看<strong>网络连通性</strong></li>
<li>脑裂是<strong>非常严重的分布式故障</strong>，Kafka目前依托<strong>ZK</strong>来防止脑裂</li>
<li>一旦出现脑裂，Kafka是<strong>无法保证正常工作</strong>的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>监控Kafka客户端<ul>
<li>首先要关心的是客户端所在机器与Kafka Broker机器之间的<strong>网络往返时延</strong>（<strong>RTT</strong>），可以借助<strong>ping</strong>命令</li>
<li>生产者<ul>
<li>以<code>kafka-producer-network-thread</code>开头的线程，负责<strong>实际消息发送</strong></li>
<li>一旦该线程挂掉，Producer将无法正常工作，但Producer进程不会自动挂掉</li>
</ul>
</li>
<li>消费者<ul>
<li>关注以<code>kafka-coordinator-heartbeat-thread</code>开头的线程，心跳线程事关<strong>Rebalance</strong></li>
</ul>
</li>
<li>JMX<ul>
<li>生产者：<code>request-latency</code>，消息生产请求的延时，最直接表征Producer程序的<strong>TPS</strong></li>
<li>消费者：<code>records-lag</code>、<code>records-lead</code>，直接反应消费者的<strong>消费进度</strong></li>
<li>消费者组：<code>join rate</code>、<code>sync rate</code>，表征<strong>Rebalance的频繁程度</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>参考：<a href="http://zhongmingmao.me" target="_blank" rel="noopener">http://zhongmingmao.me</a></p>
]]></content>
      <categories>
        <category>Middleware</category>
        <category>MQ</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Middleware</tag>
        <tag>MQ</tag>
        <tag>Kafka</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka -- 多线程消费者</title>
    <url>/2019/09/08/kafka-multi-thread-consumer/</url>
    <content><![CDATA[<h2 id="Kafka-Java-Consumer设计原理"><a href="#Kafka-Java-Consumer设计原理" class="headerlink" title="Kafka Java Consumer设计原理"></a>Kafka Java Consumer设计原理</h2><ol>
<li>Kafka Java Consumer从Kafka 0.10.1.0开始，KafkaConsumer变成了<strong>双线程</strong>设计，即<strong>用户主线程</strong>和<strong>心跳线程</strong><ul>
<li>用户主线程：启动Consumer应用程序main方法的那个线程</li>
<li>心跳线程：只负责定期给对应的Broker机器发送心跳请求，以标识消费者应用的存活性</li>
</ul>
</li>
<li>引入心跳线程的另一个目的<ul>
<li>将心跳频率和主线程调用KafkaConsumer.poll方法的频率分开，解耦<strong>真实的消息处理逻辑</strong>和<strong>消费组成员存活性管理</strong></li>
</ul>
</li>
<li>虽然有了心跳线程，但实际的消息获取逻辑依然是在用户主线程中完成<ul>
<li>因此在<strong>消费消息</strong>的这个层面，依然可以安全地认为KafkaConsumer是<strong>单线程的设计</strong></li>
</ul>
</li>
<li>老版本Consumer是<strong>多线程</strong>的架构<ul>
<li>每个Consumer实例在内部为<strong>所有订阅的主题分区</strong>创建对应的<strong>消息获取线程</strong>，即Fetcher线程</li>
</ul>
</li>
<li>老版本Consumer同时也是<strong>阻塞式</strong>的，Consumer实例启动后，内部会创建很多阻塞式的消息获取迭代器<ul>
<li>但在很多场景下，Consumer端有<strong>非阻塞</strong>需求，如在<strong>流处理</strong>应用中执行<strong>过滤</strong>、<strong>分组</strong>等操作就不能是阻塞式的</li>
<li>基于这个原因，社区为新版本Consumer设计了<strong>单线程+轮询</strong>的机制，该机制能较好地实现非阻塞的消息获取</li>
</ul>
</li>
<li>单线程的设计<strong>简化</strong>了Consumer端的设计<ul>
<li>Consumer获取到消息后，处理消息的逻辑是否采用多线程，完全由使用者决定</li>
</ul>
</li>
<li>不论使用哪一种编程语言，单线程的设计都比较容易实现<ul>
<li>并不是所有的编程语言都能很好地支持多线程，而单线程设计的Consumer更容易<strong>移植</strong>到其他语言上</li>
</ul>
</li>
</ol>
<a id="more"></a>
<h2 id="多线程方案"><a href="#多线程方案" class="headerlink" title="多线程方案"></a>多线程方案</h2><ol>
<li>KafkaConsumer是<strong>线程不安全</strong>的</li>
<li>不能多线程共享一个KafkaConsumer实例，否则会抛出<strong>ConcurrentModificationException</strong></li>
<li>但KafkaConsumer.wakeup()是线程安全的</li>
</ol>
<h3 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h3><p><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-multi-thread-consumer-1.png" width=1000></p>
<ol>
<li>消费者程序启动多个线程，<strong>每个线程维护专属的KafkaConsumer实例</strong>，负责完整的消息获取、消息处理流程</li>
<li>优点<ul>
<li><strong>实现简单</strong>，比较符合目前使用Consumer API的习惯</li>
<li>多个线程之间<strong>没有任何交互</strong>，省去了很多保障线程安全方面的开销</li>
<li>Kafka主题中的<strong>每个分区</strong>都能保证<strong>只被一个线程处理</strong>，容易实现<strong>分区内的消息消费顺序</strong></li>
</ul>
</li>
<li>缺点<ul>
<li>每个线程都维护自己的KafkaConsumer实例，必然会占用<strong>更多的系统资源</strong>，如内存、TCP连接等</li>
<li>能使用的线程数<strong>受限</strong>于Consumer<strong>订阅主题的总分区数</strong></li>
<li>每个线程<strong>完整</strong>地执行消息获取和消息处理逻辑<ul>
<li>一旦消息处理逻辑很重，消息处理速度很慢，很容易出现<strong>不必要的Rebalance</strong>，引发整个消费者组的<strong>消费停滞</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConsumerRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean closed = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> KafkaConsumer consumer = <span class="keyword">new</span> KafkaConsumer(<span class="keyword">new</span> Properties());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            consumer.subscribe(Collections.singletonList(<span class="string">"topic"</span>));</span><br><span class="line">            <span class="keyword">while</span> (!closed.get()) &#123;</span><br><span class="line">                ConsumerRecords records = consumer.poll(Duration.ofMillis(<span class="number">10000</span>));</span><br><span class="line">                <span class="comment">//  执行消息处理逻辑</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (WakeupException e) &#123;</span><br><span class="line">            <span class="comment">// Ignore exception if closing</span></span><br><span class="line">            <span class="keyword">if</span> (!closed.get()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            consumer.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shutdown hook which can be called from a separate thread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        closed.set(<span class="keyword">true</span>);</span><br><span class="line">        consumer.wakeup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h3><p><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-multi-thread-consumer-2.png" width=1000></p>
<ol>
<li>消费者程序使用单个或多个线程获取消息，同时创建多个消费线程执行消息处理逻辑<ul>
<li>获取消息的线程可以是一个，也可以是多个，<strong>每个线程维护专属的KafkaConsumer实例</strong></li>
<li>处理消息则由<strong>特定的线程池</strong>来做，从而实现<strong>消息获取</strong>和<strong>消息处理</strong>的<strong>真正解耦</strong></li>
</ul>
</li>
<li>优点<ul>
<li>把任务切分成<strong>消息获取</strong>和<strong>消息处理</strong>两部分，分别由不同的线程来处理</li>
<li>相对于方案1，方案2最大的优势是它的<strong>高伸缩性</strong><ul>
<li>可以独立地调节消息获取的线程数，以及消息处理的线程数，不必考虑两者之间是否相互影响</li>
</ul>
</li>
</ul>
</li>
<li>缺点<ul>
<li><strong>实现难度大</strong>，因为要分别管理两组线程</li>
<li>消息获取和消息处理解耦，<strong>无法保证分区内的消费顺序</strong></li>
<li>两组线程，使得<strong>整个消息消费链路被拉长</strong>，最终导致<strong>正确位移提交会变得异常困难</strong>，可能会出现消息的<strong>重复消费</strong></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> KafkaConsumer&lt;String, String&gt; consumer;</span><br><span class="line"><span class="keyword">private</span> ExecutorService executors;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> workerNum = <span class="number">10</span>;</span><br><span class="line">executors = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">    workerNum, workerNum, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">	<span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1000</span>), </span><br><span class="line">	<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> ConsumerRecord record : records) &#123;</span><br><span class="line">        <span class="comment">// 由专门的线程池负责处理具体的消息</span></span><br><span class="line">        executors.submit(<span class="keyword">new</span> Worker(record));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h5 id="讨论的都是多线程的方案，可能有人会说，何必这么麻烦，我直接启动多个-Consumer-进程不就得了？那么，请你比较一下多线程方案和多进程方案，想一想它们各自的优劣之处"><a href="#讨论的都是多线程的方案，可能有人会说，何必这么麻烦，我直接启动多个-Consumer-进程不就得了？那么，请你比较一下多线程方案和多进程方案，想一想它们各自的优劣之处" class="headerlink" title="讨论的都是多线程的方案，可能有人会说，何必这么麻烦，我直接启动多个 Consumer 进程不就得了？那么，请你比较一下多线程方案和多进程方案，想一想它们各自的优劣之处"></a>讨论的都是多线程的方案，可能有人会说，何必这么麻烦，我直接启动多个 Consumer 进程不就得了？那么，请你比较一下多线程方案和多进程方案，想一想它们各自的优劣之处</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">多进程的上下文切换成本较大，没有多线程好</span><br></pre></td></tr></table></figure>
<p>参考：<a href="http://zhongmingmao.me/2019/09/08/kafka-multi-thread-consumer/" target="_blank" rel="noopener">http://zhongmingmao.me/2019/09/08/kafka-multi-thread-consumer/</a></p>
]]></content>
      <categories>
        <category>Middleware</category>
        <category>MQ</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Middleware</tag>
        <tag>MQ</tag>
        <tag>Kafka</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka -- 位移主题</title>
    <url>/2019/08/26/kafka-offset-topic/</url>
    <content><![CDATA[<h2 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h2><ol>
<li>老版本Consumer的位移管理依托于<strong>Apache ZooKeeper</strong>，自动或手动地将位移数据提交到ZK中保存</li>
<li>当Consumer重启后，能自动从ZK中读取位移数据，从而在上次消费截止的地方继续消费</li>
<li>这种设计使得Kafka Broker不需要保存位移数据，减少了Broker端需要持有的<strong>状态空间</strong>，有利于实现<strong>高伸缩性</strong></li>
<li>但ZK并<strong>不适用于高频的写操作</strong></li>
</ol>
<a id="more"></a>
<h2 id="位移主题"><a href="#位移主题" class="headerlink" title="位移主题"></a>位移主题</h2><ol>
<li>将Consumer的位移数据作为<strong>普通的Kafka消息</strong>，提交到<code>__consumer_offsets</code>（保存Consumer的位移信息）<ul>
<li>提交过程需要实现<strong>高持久性</strong>，并需要支持<strong>高频的写操作</strong></li>
</ul>
</li>
<li>位移主题是<strong>普通的Kafka主题</strong>，同时也是一个<strong>内部主题</strong>，交由Kafka管理即可</li>
<li>位移主题的<strong>消息格式由Kafka定义</strong>，用户不能修改<ul>
<li>因此不能随意向位移主题写消息，一旦写入的消息不能满足格式，那Kafka内部无法成功解析，会造成<strong>Broker崩溃</strong></li>
<li>Kafka Consumer有<strong>API</strong>来提交位移（即向位移主题写消息）</li>
</ul>
</li>
</ol>
<h3 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h3><ol>
<li>常用格式：<strong>Key-Value</strong><ul>
<li>Key为<strong>消息键值</strong>，Value为<strong>消息体</strong>，在Kafka中都是<strong>字节数组</strong></li>
<li>Key<ul>
<li><strong><code>&lt;Group ID, Topic, Partition&gt;</code></strong></li>
</ul>
</li>
<li>Value<ul>
<li><strong>Offset</strong> + Other MetaData（时间戳等，这是为了执行各种各样的后续操作，例如删除过去位移信息等）</li>
</ul>
</li>
</ul>
</li>
<li>用于<strong>保存Consumer Group信息</strong>的消息<ul>
<li>用来<strong>注册</strong>Consumer Group</li>
</ul>
</li>
<li>用于<strong>删除Group过期位移</strong>甚至<strong>删除Group</strong>的消息<ul>
<li>专属名词：<strong>tombstone消息</strong>，即<strong>墓碑消息</strong>，也称<strong>delete mark</strong>，主要特点是<strong>消息体为null</strong></li>
<li>一旦某个Consumer Group下<strong>所有的Consumer实例都停止</strong>，而且它们的<strong>位移数据已被删除</strong><ul>
<li>Kafka会向<strong>位移主题的对应分区</strong>写入tombstone消息，表明要<strong>彻底删除</strong>这个Consumer Group</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="创建位移主题"><a href="#创建位移主题" class="headerlink" title="创建位移主题"></a>创建位移主题</h3><ol>
<li>Kafka集群中的<strong>第一个Consumer</strong>程序启动时，会自动创建位移主题<ul>
<li>Broker端参数：<strong>offsets.topic.num.partitions=50</strong>，Kafka会自动创建<strong>50分区</strong>的位移主题</li>
<li>Broker端参数：<strong>offsets.topic.replication.factor=3</strong>，Kafka会自动创建<strong>3副本</strong>的位移主题</li>
</ul>
</li>
<li>手动创建位移主题<ul>
<li>在Kafka集群尚未启动任何Consumer之前，使用Kafka API来创建</li>
</ul>
</li>
<li>推荐：采用Kafka的<strong>自动创建</strong></li>
</ol>
<h3 id="提交位移"><a href="#提交位移" class="headerlink" title="提交位移"></a>提交位移</h3><ol>
<li>自动提交位移<ul>
<li><strong>enable.auto.commit=true</strong></li>
<li>Consumer在后台默默地<strong>定期提交位移</strong>，提交间隔由参数控制<code>auto.commit.interval.ms</code></li>
<li>缺点<ul>
<li>完全无法把控Consumer端的位移管理<ul>
<li>很多与Kafka集成的大数据框架都<strong>禁用自动提交位移</strong>的，如Spark、Flink等</li>
</ul>
</li>
<li>只要Consumer一直启动着，就会<strong>无限期</strong>地向位移主题写入消息<ul>
<li>假设Consumer当前消费了某个主题的最新一条消息，位移为100，之后该主题就没有产生任何新消息</li>
<li>但由于设置了自动提交位移，位移主题会不停地写入位移=100，这就要求位移主题有特定的<strong>消息删除策略</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>手动提交位移<ul>
<li><strong>enable.auto.commit=false</strong></li>
<li>需要应用程序手动提交位移</li>
</ul>
</li>
</ol>
<h3 id="删除过期消息"><a href="#删除过期消息" class="headerlink" title="删除过期消息"></a>删除过期消息</h3><ol>
<li>策略：<strong>Compaction</strong>（整理）</li>
<li>Kafka使用<strong>Compact策略</strong>来删除位移主题中的<strong>过期消息</strong>，避免该主题<strong>无限期膨胀</strong></li>
<li>过期消息：对于<strong>同一个Key</strong>的两条消息M1和M2，如果M1的发送时间早于M2，那么M1就是过期消息</li>
<li>Compact过程：扫描日志的<strong>所有消息</strong>，剔除过期的消息，然后把剩下的消息整理在一起</li>
<li>Kafka提供了<strong>专门的后台线程</strong>（<strong>Log Cleaner</strong>）来<strong>定期巡检</strong>待Compact的主题<ul>
<li>如果位移主题<strong>无限期膨胀</strong>，占用过多的磁盘空间，检查下Log Cleaner线程的状态</li>
</ul>
</li>
</ol>
<p><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-offset-topic-compact.jpeg" width=800/></p>
<p>参考：<a href="http://zhongmingmao.me/2019/08/26/kafka-offset-topic/" target="_blank" rel="noopener">http://zhongmingmao.me/2019/08/26/kafka-offset-topic/</a></p>
]]></content>
      <categories>
        <category>Middleware</category>
        <category>MQ</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Middleware</tag>
        <tag>MQ</tag>
        <tag>Kafka</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka -- 无消息丢失</title>
    <url>/2019/08/09/kafka-no-msg-loss/</url>
    <content><![CDATA[<h2 id="持久化保证"><a href="#持久化保证" class="headerlink" title="持久化保证"></a>持久化保证</h2><ol>
<li>Kafka只对<strong>已提交的消息</strong>做<strong>有限度的持久化保证</strong></li>
<li><strong>已提交的消息</strong><ul>
<li>当Kafka的<strong>若干个Broker</strong>成功地<strong>接收</strong>到一条消息并<strong>写入到日志文件</strong>后，会告诉生产者这条消息已经成功提交</li>
</ul>
</li>
<li><strong>有限度的持久化保证</strong><ul>
<li>Kafka不保证在任何情况下都能做到不丢失消息，例如机房着火等极端情况</li>
</ul>
</li>
</ol>
<a id="more"></a>
<h2 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h2><h3 id="生产者丢失"><a href="#生产者丢失" class="headerlink" title="生产者丢失"></a>生产者丢失</h3><ol>
<li>目前Kafka Producer是<strong>异步</strong>发送消息的，<code>Producer.send(record)</code>立即返回，但不能认为消息已经发送成功</li>
<li>丢失场景：网络抖动，导致消息没有到达Broker；消息太大，超过Broker的承受能力，Broker拒收</li>
<li>解决方案：Producer永远要使用带有<strong>回调通知</strong>的发送API，即<strong><code>Producer.send(record, callback)</code></strong><ul>
<li>callback能够准确地告知Producer消息是不是真的提交成功，一旦出现消息提交失败，可以进行针对性的处理</li>
</ul>
</li>
</ol>
<h3 id="消费者丢失"><a href="#消费者丢失" class="headerlink" title="消费者丢失"></a>消费者丢失</h3><ol>
<li>Consumer端丢失数据主要体现在<strong>Consumer端要消费的消息不见了</strong></li>
<li>Consumer程序有<strong>位移</strong>的概念，表示<strong>该Consumer当前消费到Topic分区的位置</strong></li>
<li>丢失原因：Consumer接收一批消息后，在未处理完所有消息之前，就直接更新位移</li>
<li>解决方案：<strong>先消费消息，再更新位移</strong><ul>
<li>这种方式能最大限度地保证消息不丢失，但带来了<strong>重复消息</strong>的问题，因此Consumer需要支持<strong>幂等</strong></li>
</ul>
</li>
<li>如果采用<strong>多线程异步处理消息</strong>，Consumer程序要关闭自动提交位移，由应用程序<strong>手动提交位移</strong></li>
</ol>
<p><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-loss-msg-consumer.png" width=600/></p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><ol>
<li>使用带有<strong>回调</strong>的发送API：<code>Producer.send(record, callback)</code></li>
<li><code>acks = all</code>，表示<strong>所有Broker</strong>都要接收到，该消息才算是<strong>已提交</strong></li>
<li>将<code>retries</code>设置为一个<strong>较大的值</strong>，Producer<strong>自动重试</strong>的次数</li>
</ol>
<h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><ol>
<li><code>unclean.leader.election.enable = false</code>，控制哪些Broker有资格竞选分区Leader<ul>
<li>如果一个落后很多的Broker也能参与竞选并且成为新的Leader，必然会造成<strong>消息丢失</strong></li>
</ul>
</li>
<li><code>replication.factor &gt;= 3</code>，将消息多保存几份副本，目前防止消息丢失的主要机制是<strong>冗余</strong></li>
<li><code>min.insync.replicas &gt; 1</code>，消息至少被写入多少个<strong>副本</strong>才算已提交，生产环境中不能使用默认值1</li>
<li><code>replication.factor &gt; min.insync.replicas</code>，如果两者相等，只要有一个副本宕机，整个<strong>分区</strong>就无法正常工作了<ul>
<li>应该在<strong>不降低可用性</strong>的基础上，改善消息的持久性，防止数据丢失</li>
<li>推荐设置为<strong><code>replication.factor = min.insync.replicas + 1</code></strong></li>
</ul>
</li>
</ol>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><ol>
<li><code>enable.auto.commit = false</code>，确保消息消费完再手动提交</li>
</ol>
<h4 id="转载：http-zhongmingmao-me-2019-08-09-kafka-no-msg-loss"><a href="#转载：http-zhongmingmao-me-2019-08-09-kafka-no-msg-loss" class="headerlink" title="转载：http://zhongmingmao.me/2019/08/09/kafka-no-msg-loss/"></a>转载：<a href="http://zhongmingmao.me/2019/08/09/kafka-no-msg-loss/" target="_blank" rel="noopener">http://zhongmingmao.me/2019/08/09/kafka-no-msg-loss/</a></h4>]]></content>
      <categories>
        <category>Middleware</category>
        <category>MQ</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Middleware</tag>
        <tag>MQ</tag>
        <tag>Kafka</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka -- 处理请求</title>
    <url>/2019/09/15/kafka-process-request/</url>
    <content><![CDATA[<h2 id="请求协议"><a href="#请求协议" class="headerlink" title="请求协议"></a>请求协议</h2><ol>
<li>Kafka自定义了一组请求协议，用于实现各种各样的交互操作<ul>
<li><strong>PRODUCE</strong>请求用于生产消息，<strong>FETCH</strong>请求用于消费消息，<strong>METADATA</strong>请求用于请求Kafka集群元数据信息</li>
</ul>
</li>
<li>Kafka 2.3总共定义了<strong>45</strong>种请求格式，所有请求都通过<strong>TCP</strong>网络以<strong>Socket</strong>的方式进行通讯</li>
</ol>
<a id="more"></a>
<h2 id="处理请求方案"><a href="#处理请求方案" class="headerlink" title="处理请求方案"></a>处理请求方案</h2><h3 id="顺序处理"><a href="#顺序处理" class="headerlink" title="顺序处理"></a>顺序处理</h3><p>实现简单，但<strong>吞吐量太差</strong>，只适用于请求发送<strong>非常不频繁</strong>的场景<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    Request request = accept(connection);</span><br><span class="line">    handle(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="单独线程处理"><a href="#单独线程处理" class="headerlink" title="单独线程处理"></a>单独线程处理</h3><p>为每个请求都<strong>创建一个新的线程异步处理</strong>，完全异步，但<strong>开销极大</strong>，只适用于请求发送<strong>频率很低</strong>的场景<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    Request request = accept(connection);</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123; handle(request); &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h3><p><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-process-request-reactor.png" width=1000></p>
<ol>
<li>Reactor模式是<strong>事件驱动</strong>架构的一种实现方式，特别适合应用于处理多个客户端<strong>并发</strong>向服务器端发起请求的场景</li>
<li>多个客户端会发送请求给<strong>Reactor</strong>，Reactor有个<strong>请求分发线程Acceptor</strong>，将不同的请求下发到多个<strong>工作线程</strong>中处理</li>
<li><strong>Acceptor</strong>线程只用于请求分发，不涉及具体的逻辑处理，非常<strong>轻量级</strong>，有<strong>很高的吞吐量</strong><ul>
<li>工作线程可以根据实际业务处理需要任意增减，从而<strong>动态调节系统负载能力</strong></li>
</ul>
</li>
</ol>
<h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><p><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-process-request-reactor-kafka.png" width=1000></p>
<ol>
<li>Broker端有一个<strong>SocketServer</strong>组件，类似于Reactor模式中的<strong>Dispatcher</strong><ul>
<li>也有对应的<strong>Acceptor线程</strong>和一个工作线程池（即<strong>网络线程池</strong>，参数设置<code>num.network.threads</code>，默认值为<strong>3</strong>）</li>
</ul>
</li>
<li>Acceptor线程采用<strong>轮询</strong>的方式将入站请求<strong>公平</strong>地发到所有网络线程中<ul>
<li>实现简单，<strong>避免了请求处理的倾斜</strong>，有利于实现<strong>较为公平</strong>的请求处理调度</li>
</ul>
</li>
</ol>
<p><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-process-request-reactor-kafka-io-pool.png" width=1000></p>
<ol>
<li>当<strong>网络线程</strong>拿到请求后，并不是自己处理，而是将请求放入到一个<strong>共享请求队列</strong>中</li>
<li>Broker端还有一个<strong>IO线程池</strong>，负责从共享请求队列中取出请求，执行<strong>真正的处理</strong><ul>
<li>如果是<strong>PRODUCE</strong>请求，将消息写入到<strong>底层的磁盘日志</strong>中</li>
<li>如果是<strong>FETCH</strong>请求，则从<strong>磁盘</strong>或<strong>页缓存</strong>中读取消息</li>
</ul>
</li>
<li>IO线程池中的线程才是执行请求逻辑的线程，参数<code>num.io.threads</code>，默认值为<strong>8</strong></li>
<li>当<strong>IO线程</strong>处理完请求后，会将<strong>生成的响应</strong>发送到<strong>网络线程池的响应队列</strong>中<ul>
<li>然后由<strong>对应的网络线程</strong>负责将Response返回给客户端</li>
</ul>
</li>
<li><strong>请求队列</strong>是所有网络线程<strong>共享</strong>的，而<strong>响应队列</strong>是每个网络线程<strong>专属</strong>的<ul>
<li>Purgatory组件用于<em><strong>缓存延时请求</strong></em></li>
<li>如<code>acks=all</code>的<strong>PRODUCE</strong>请求，必须等待<strong>ISR中所有副本</strong>都接收消息后才能返回<ul>
<li>此时处理该请求的IO线程必须等待其他Broker的写入结果，当请求不能处理时，就会<strong>暂存</strong>在Purgatory中</li>
<li>等到条件满足后，IO线程会继续处理该请求，并将Response放入<strong>对应</strong>网络线程的响应队列中</li>
</ul>
</li>
</ul>
</li>
<li>Kafka将PRODUCE、FETCH这类请求称为<strong>数据类请求</strong>，把LeaderAndIsr、StopReplica这类请求称为<strong>控制类请求</strong><ul>
<li>在<strong>Kafka 2.3</strong>，正式实现了<strong>数据类请求</strong>和<strong>控制类请求</strong>的<strong>分离</strong>（<strong>完全拷贝</strong>一套组件，实现两类请求的分离）</li>
</ul>
</li>
</ol>
<p>参考：<a href="http://zhongmingmao.me/2019/09/15/kafka-process-request/" target="_blank" rel="noopener">http://zhongmingmao.me/2019/09/15/kafka-process-request/</a></p>
]]></content>
      <categories>
        <category>Middleware</category>
        <category>MQ</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Middleware</tag>
        <tag>MQ</tag>
        <tag>Kafka</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka -- 幂等性生产者 + 事务生产者</title>
    <url>/2019/08/19/kafka-producer-idempotence-transaction/</url>
    <content><![CDATA[<h2 id="消息交付可靠性保障"><a href="#消息交付可靠性保障" class="headerlink" title="消息交付可靠性保障"></a>消息交付可靠性保障</h2><ol>
<li>消息交付可靠性保障：Kafka对Producer和Consumer要处理的消息所提供的承诺</li>
<li>常见的承诺<ul>
<li>最多一次（at most once）：消息可能会丢失，但绝不会被重复发送</li>
<li><strong>至少一次</strong>（at least once）：消息不会丢失，但有可能被重复发送</li>
<li>精确一次（exactly once）：消息不会丢失，也不会被重复发送</li>
</ul>
</li>
<li>Kafka默认提供的交付可靠性保障：<em><strong>至少一次</strong></em><ul>
<li>只有Broker成功<strong>提交</strong>消息且Producer接到Broker的应答才会认为该消息成功发送</li>
<li>如果Broker成功提交消息，但Broker的应答没有成功送回Producer端，Producer只能选择<strong>重试</strong></li>
</ul>
</li>
<li>最多一次<ul>
<li>Kafka也可以提供<strong>最多一次</strong>交付可靠性保证，只需要让<strong>Producer禁止重试</strong>即可，但大部分场景下并不希望出现消息丢失</li>
</ul>
</li>
<li><strong>精确一次</strong><ul>
<li>消息不会丢失，也不会被重复处理，即使Producer端重复发送了相同的消息，Broker端也能自动去重</li>
<li>两种机制：<strong>幂等性</strong>、<strong>事务</strong></li>
</ul>
</li>
</ol>
<a id="more"></a>
<h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><ol>
<li>幂等原是数学中的概念：某些操作或者函数能够被执行多次，但每次得到的结果都是<strong>不变</strong>的<ul>
<li>幂等操作：乘1，取整函数；非幂等操作：加1</li>
</ul>
</li>
<li>计算机领域<ul>
<li>在<strong>命令式</strong>编程语言（如C）中，如果一个子程序是幂等的，那它必然<strong>不能修改系统状态</strong></li>
<li>在<strong>函数式</strong>编程语言（如Scala、Haskell）中，很多<strong>纯函数</strong>天然就是幂等的，不执行任何的Side Effect</li>
</ul>
</li>
<li>幂等性的好处：可以<strong>安全地重试</strong>任何幂等性操作</li>
</ol>
<h2 id="幂等性Producer"><a href="#幂等性Producer" class="headerlink" title="幂等性Producer"></a>幂等性Producer</h2><ol>
<li>在Kafka中，<strong>Producer默认不是幂等的</strong>，在<strong>0.11.0.0</strong>版本引入了幂等性Producer</li>
<li><strong>默认情况下</strong>，Producer向Broker发送数据时，可能会出现同一条消息被发送多次，导致<strong>消息重复</strong></li>
<li>升级为幂等性Producer<ul>
<li><code>props.put(&quot;enable.idempotence&quot;, true)</code>或</li>
<li><code>props.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, true)</code></li>
</ul>
</li>
<li>基本原理<ul>
<li><strong>空间换时间</strong>，在Broker端多保存一些字段</li>
<li>当Producer发送了具有相同字段值的消息后，Broker能够自动发现这些重复消息，然后默默<strong>丢弃</strong></li>
</ul>
</li>
<li><strong>作用范围</strong><ul>
<li>幂等性Producer只能保证<strong>单分区</strong>上的幂等性<ul>
<li>即只能保证某个主题上的一个分区上不出现重复消息，无法实现多个分区的幂等性</li>
</ul>
</li>
<li>幂等性Producer只能实现<strong>单会话</strong>上的幂等性，不能实现跨会话的幂等性<ul>
<li>会话：<strong>Producer进程的一次运行</strong>，如果重启Producer进程，将丢失幂等性保证</li>
</ul>
</li>
<li>如果要实现<strong>多分区</strong>或者<strong>多会话</strong>的消息无重复，可以采用<strong>事务Producer</strong></li>
</ul>
</li>
</ol>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ol>
<li>数据库事务提供了<strong>ACID</strong>的安全性保障：<strong>Atomicity</strong>、<strong>Consistency</strong>、<strong>Isolation</strong>、<strong>Durability</strong></li>
<li>Kafka在<strong>0.11</strong>版本开始提供了对事务的支持，目前主要在<strong>Read Committed</strong>的隔离级别上做事情<ul>
<li>保证<strong>多条消息原子性地写入目标分区</strong>，同时也保证<strong>Consumer只能看到事务成功提交的消息</strong></li>
</ul>
</li>
</ol>
<h2 id="事务Producer"><a href="#事务Producer" class="headerlink" title="事务Producer"></a>事务Producer</h2><ol>
<li>事务Producer能够保证<strong>一批消息原子性地写入多个分区</strong>，这批消息要么<strong>全部写入成功</strong>，要么<strong>全部写入失败</strong></li>
<li><strong>事务Producer允许进程重启</strong>，Producer重启后，Kafka依然保证它们发送的消息的<strong>精确一次</strong>处理</li>
<li>升级为事务Producer<ul>
<li><code>props.put(&quot;enable.idempotence&quot;, true)</code></li>
<li><code>props.put(&quot;transactional.id&quot;, &quot;my-transactional-id&quot;)</code></li>
</ul>
</li>
<li>record1和record2会被当作一个事务统一提交到Kafka，要么全部提交成功，要么全部写入失败</li>
<li>即使写入失败，Kafka也会把它们写入到<strong>底层日志</strong>中，即Consumer还是会看到这些消息</li>
<li>因此在Consumer端，读取事务Producer发送的消息，需要设置<strong>isolation.level</strong>参数<ul>
<li><strong>read_uncommitted</strong><ul>
<li>默认值，Consumer能够读取到Kafka写入的<strong>任何消息</strong>，不论事务Producer提交事务还是终止事务</li>
</ul>
</li>
<li><strong>read_committed</strong><ul>
<li>Consumer只会读取到<strong>事务Producer成功提交事务写入的消息</strong>，也能读取到<strong>非事务Producer写入的所有消息</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">producer.initTransactions();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    producer.beginTransaction();</span><br><span class="line">    producer.send(<span class="keyword">new</span> ProducerRecord&lt;&gt;(TOPIC, KEY, VALUE + <span class="number">1</span>));</span><br><span class="line">    producer.send(<span class="keyword">new</span> ProducerRecord&lt;&gt;(TOPIC, KEY, VALUE + <span class="number">2</span>));</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    producer.commitTransaction();</span><br><span class="line">&#125; <span class="keyword">catch</span> (KafkaException e) &#123;</span><br><span class="line">    producer.abortTransaction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>幂等性Producer和事务Producer都是Kafka社区为了实现<strong>精确一次</strong>处理语义所提供的工具，只是<strong>作用范围</strong>不同而已</li>
<li>幂等性Producer只能保证<strong>单分区、单会话</strong>上的消息幂等性；而事务Producer能够保证<strong>跨分区、跨会话</strong>的幂等性</li>
<li>事务Producer与幂等性Producer相比，<strong>性能更差</strong></li>
</ol>
]]></content>
      <categories>
        <category>Middleware</category>
        <category>MQ</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Middleware</tag>
        <tag>MQ</tag>
        <tag>Kafka</tag>
        <tag>Stream</tag>
        <tag>Idempotence</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka -- 生产者管理TCP连接</title>
    <url>/2019/08/16/kafka-producer-manage-tcp-connection/</url>
    <content><![CDATA[<h2 id="为何采用TCP"><a href="#为何采用TCP" class="headerlink" title="为何采用TCP"></a>为何采用TCP</h2><ul>
<li>1.TCP本身提供多路复用请求，同时轮询多个连接的能力</li>
<li>2.已知的 HTTP 库在很多编程语言中都略显简陋</li>
</ul>
<h2 id="建立TCP连接"><a href="#建立TCP连接" class="headerlink" title="建立TCP连接"></a>建立TCP连接</h2><h3 id="创建KafkaProducer实例"><a href="#创建KafkaProducer实例" class="headerlink" title="创建KafkaProducer实例"></a>创建KafkaProducer实例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">properties.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line">properties.put(<span class="string">"key.serializer"</span>, StringSerializer<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">properties.put(<span class="string">"value.serializer"</span>, StringSerializer<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"><span class="comment">// try-with-resources</span></span><br><span class="line"><span class="comment">// 创建KafkaProducer实例时，会在后台创建并启动Sender线程，Sender线程开始运行时首先会创建与Broker的TCP连接</span></span><br><span class="line"><span class="keyword">try</span> (Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(properties)) &#123;</span><br><span class="line">    ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(TOPIC, KEY, VALUE);</span><br><span class="line">    Callback callback = (metadata, exception) -&gt; &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    producer.send(record, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<ol>
<li><code>bootstrap.servers</code>是Producer的核心参数之一，指定了Producer<strong>启动</strong>时要连接的Broker地址</li>
<li>如果<code>bootstrap.servers</code>指定了1000个Broker，那么Producer启动时会首先创建与这1000个Broker的<strong>TCP连接</strong></li>
<li>因此不建议把集群中所有的Broker信息都配置到<code>bootstrap.servers</code>中，通常配置<strong>3~4台</strong>足够<ul>
<li>Producer一旦连接到集群中的<strong>任意一台Broker</strong>，就能拿到<strong>整个集群</strong>的Broker信息（<strong>metadata request</strong>）</li>
</ul>
</li>
<li>在创建KafkaProducer实例时启动Sender线程是<strong>不合理</strong>的<ul>
<li>在对象构造器中启动线程会造成<strong>this指针逃逸</strong>，理论上Sender线程能够观测到一个<strong>尚未构造完成</strong>的KafkaProducer实例</li>
<li>在构造对象时创建线程是没有问题的，但最好不要同时启动线程</li>
</ul>
</li>
</ol>
<p>相关日志<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sender          - Starting Kafka producer I&#x2F;O thread.</span><br><span class="line">KafkaProducer   - Kafka producer started</span><br><span class="line">NetworkClient   - Initialize connection to node localhost:9092 (id: -1 rack: null) for sending metadata request</span><br><span class="line">NetworkClient   - Initiating connection to node localhost:9092 (id: -1 rack: null)</span><br><span class="line">Selector        - Created socket with SO_RCVBUF &#x3D; 326640, SO_SNDBUF &#x3D; 146988, SO_TIMEOUT &#x3D; 0 to node -1</span><br><span class="line">NetworkClient   - Completed connection to node -1. Fetching API versions.</span><br><span class="line">NetworkClient   - Initiating API versions fetch from node -1.</span><br><span class="line">NetworkClient   - Sending metadata request (type&#x3D;MetadataRequest, topics&#x3D;zhongmingmao) to node localhost:9092 (id: -1 rack: null)</span><br><span class="line">KafkaProducer   - Closing the Kafka producer with timeoutMillis &#x3D; 9223372036854775807 ms.</span><br><span class="line">NetworkClient   - Initiating connection to node 192.168.2.1:9092 (id: 0 rack: null)</span><br><span class="line">Sender          - Beginning shutdown of Kafka producer I&#x2F;O thread, sending remaining records.</span><br><span class="line">Sender          - Shutdown of Kafka producer I&#x2F;O thread has completed.</span><br><span class="line">KafkaProducer   - Kafka producer has been closed</span><br></pre></td></tr></table></figure></p>
<h3 id="其他场景"><a href="#其他场景" class="headerlink" title="其他场景"></a>其他场景</h3><ol>
<li>其他<strong>可能</strong>创建TCP连接的场景：<strong>更新元数据后</strong>，<strong>消息发送时</strong></li>
<li>当Producer更新了<strong>集群的元数据</strong>后，如果发现与某些Broker当前没有连接，那么Producer会创建一个TCP连接<ul>
<li>场景1<ul>
<li>当Producer尝试向<strong>不存在的主题</strong>发送消息时，Broker会告诉Producer这个主题不存在</li>
<li>此时Producer会发送<strong>metadata request</strong>到<strong>Kafka集群</strong>，去尝试获取最新的元数据信息<ul>
<li>与<strong>集群中所有的Broker</strong>建立TCP连接</li>
</ul>
</li>
</ul>
</li>
<li>场景2<ul>
<li>Producer通过<code>metadata.max.age.ms</code>参数<strong>定期</strong>地去更新元数据信息，默认值300000，即<strong>5分钟</strong></li>
</ul>
</li>
</ul>
</li>
<li>当Producer要<strong>发送消息</strong>时，Producer发现与<strong>目标Broker</strong>（依赖<strong>负载均衡</strong>算法）还没有连接，也会创建一个TCP连接</li>
</ol>
<h2 id="关闭TCP连接"><a href="#关闭TCP连接" class="headerlink" title="关闭TCP连接"></a>关闭TCP连接</h2><ol>
<li>Producer端关闭TCP连接有两种方式：<strong>用户主动关闭</strong>、<strong>Kafka自动关闭</strong></li>
<li><strong>用户主动关闭</strong><ul>
<li>广义的主动关闭，包括用户调用<code>kill -9</code>来杀掉Producer，最推荐的方式：<code>producer.close()</code></li>
</ul>
</li>
<li><strong>Kafka自动关闭</strong><ul>
<li>Producer端参数<code>connections.max.idle.ms</code>，默认值540000，即<strong>9分钟</strong></li>
<li>如果9分钟内<strong>没有任何请求</strong>经过某个TCP连接，Kafka会主动把TCP连接关闭</li>
<li><code>connections.max.idle.ms=-1</code>会<strong>禁用</strong>这种机制，一旦设置成-1，TCP连接将成为<strong>永久长连接</strong><ul>
<li>Kafka创建的Socket连接都开启了<strong>keepalive</strong></li>
</ul>
</li>
<li>关闭TCP连接的发起方是<strong>Kafka客户端</strong>，属于<strong>被动关闭</strong>的场景<ul>
<li>被动关闭的后果就是会产生大量的<strong>CLOSE_WAIT</strong>连接</li>
<li><em><strong>Producer端或Client端没有机会显式地观测到此TCP连接已被中断</strong></em></li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="转载：http-zhongmingmao-me-2019-08-16-kafka-producer-manage-tcp-connection"><a href="#转载：http-zhongmingmao-me-2019-08-16-kafka-producer-manage-tcp-connection" class="headerlink" title="转载：http://zhongmingmao.me/2019/08/16/kafka-producer-manage-tcp-connection/"></a>转载：<a href="http://zhongmingmao.me/2019/08/16/kafka-producer-manage-tcp-connection/" target="_blank" rel="noopener">http://zhongmingmao.me/2019/08/16/kafka-producer-manage-tcp-connection/</a></h4>]]></content>
      <categories>
        <category>Middleware</category>
        <category>MQ</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Middleware</tag>
        <tag>MQ</tag>
        <tag>Kafka</tag>
        <tag>Stream</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka -- 生产者消息分区机制</title>
    <url>/2019/07/24/kafka-producer-partitioning-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E6%81%AF%E5%88%86%E5%8C%BA%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="分区概念"><a href="#分区概念" class="headerlink" title="分区概念"></a>分区概念</h2><p><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-producer-partitioning-topic.png" width=800/></p>
<a id="more"></a>
<ol>
<li>主题是承载真实数据的<strong>逻辑容器</strong>，主题之下分为若干个分区，Kafka的消息组织方式为三级结构：<strong>主题、分区、消息</strong></li>
<li>主题下的每条消息只会保存在某个分区中，而不会在多个分区中被保存多份</li>
<li>分区的作用是提供<strong>负载均衡</strong>的能力，实现系统的<strong>高伸缩性</strong><ul>
<li>不同的分区能够被放置在不同的机器节点上，而数据读写操作的粒度也是分区</li>
<li>每个机器节点都能独立地执行各自分区的读写请求处理，还可以通过添加新的机器节点来增加整体系统的吞吐量</li>
</ul>
</li>
<li>分区在不同的分布式系统有不同的叫法，但分区的思想都是类似的<ul>
<li>Kafka — <strong>Partition</strong></li>
<li>MongoDB、Elasticsearch — <strong>Shard</strong></li>
<li>HBase — <strong>Region</strong></li>
</ul>
</li>
</ol>
<h2 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h2><ol>
<li>分区策略：<strong>决定生产者将消息发送到哪个分区的算法</strong>，Kafka提供了默认的分区策略，也支持自定义的分区策略</li>
<li>自定义的分区策略，需要<strong>显式</strong>地配置生产者端的参数<strong>partitioner.class</strong></li>
<li>实现接口：org.apache.kafka.clients.producer.Partitioner<ul>
<li>消息数据：topic、key、keyBytes、value、valueBytes</li>
<li>集群数据：cluster</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Partitioner</span> <span class="keyword">extends</span> <span class="title">Configurable</span>, <span class="title">Closeable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Compute the partition for the given record.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topic The topic name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key The key to partition on (or null if no key)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyBytes The serialized key to partition on( or null if no key)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value The value to partition on or null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> valueBytes The serialized value to partition on or null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cluster The current cluster metadata</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes, Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This is called when partitioner is closed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="轮询策略"><a href="#轮询策略" class="headerlink" title="轮询策略"></a>轮询策略</h3><p><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-producer-partitioning-strategy-round-robin.png" width=800/></p>
<ol>
<li>轮询策略是Kafka Java生产者的<strong>默认分区策略</strong></li>
<li>轮询策略的<strong>负载均衡表现非常优秀</strong>，总能保证消息<strong>最大限度</strong>地被平均分配到所有分区上，默认情况下它是最合理的分区策略</li>
</ol>
<h3 id="随机策略"><a href="#随机策略" class="headerlink" title="随机策略"></a>随机策略</h3><p><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-producer-partitioning-strategy-randomness.png" width=800/></p>
<p>从实际表现来看，随机策略要逊于轮询策略，<strong>如果追求数据的均匀分布，建议使用轮询策略</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes, Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取Topic的分区数量</span></span><br><span class="line">    Integer partitionCount = cluster.partitionCountForTopic(topic);</span><br><span class="line">    <span class="keyword">return</span> ThreadLocalRandom.current().nextInt(partitionCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="按消息键保序策略"><a href="#按消息键保序策略" class="headerlink" title="按消息键保序策略"></a>按消息键保序策略</h3><p><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-producer-partitioning-strategy-key-ordering.png" width=800/></p>
<ol>
<li>Kafka允许为每条消息定义<strong>消息键</strong>，简称为Key</li>
<li>Key可以是一个有明确业务含义的字符串：客户代码、部门编号、业务ID、用来表征消息的元数据等</li>
<li>一旦消息被定义了Key，可以保证<strong>同一个Key的所有消息都进入到相同的分区里</strong><ul>
<li>由于每个分区下的消息处理都是<strong>顺序</strong>的，所以这个策略被称为<strong>按消息键保序策略</strong></li>
</ul>
</li>
<li>Kafka Java生产者的默认分区策略<ul>
<li>如果<strong>指定了Key</strong>，采用<strong>按消息键保序策略</strong></li>
<li>如果<strong>没有指定Key</strong>，采用<strong>轮询策略</strong></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes, Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取Topic的分区数量</span></span><br><span class="line">    Integer partitionCount = cluster.partitionCountForTopic(topic);</span><br><span class="line">    <span class="keyword">return</span> Math.abs(key.hashCode() % partitionCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基于地理位置的分区策略"><a href="#基于地理位置的分区策略" class="headerlink" title="基于地理位置的分区策略"></a>基于地理位置的分区策略</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes, Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster)</span> </span>&#123;</span><br><span class="line">    List&lt;PartitionInfo&gt; partitionInfos = cluster.partitionsForTopic(topic);</span><br><span class="line">    <span class="keyword">return</span> partitionInfos.stream()</span><br><span class="line">            .filter(partitionInfo -&gt; isSouth(partitionInfo.leader().host()))</span><br><span class="line">            .map(PartitionInfo::partition)</span><br><span class="line">            .findAny().get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="转载：http-zhongmingmao-me-2019-07-24-kafka-producer-partitioning"><a href="#转载：http-zhongmingmao-me-2019-07-24-kafka-producer-partitioning" class="headerlink" title="转载：http://zhongmingmao.me/2019/07/24/kafka-producer-partitioning/"></a>转载：<a href="http://zhongmingmao.me/2019/07/24/kafka-producer-partitioning/" target="_blank" rel="noopener">http://zhongmingmao.me/2019/07/24/kafka-producer-partitioning/</a></h4>]]></content>
      <categories>
        <category>Middleware</category>
        <category>MQ</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Middleware</tag>
        <tag>MQ</tag>
        <tag>Kafka</tag>
        <tag>Stream</tag>
        <tag>Producer</tag>
        <tag>Load Balance</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka -- 副本</title>
    <url>/2019/09/14/kafka-replication/</url>
    <content><![CDATA[<h2 id="副本机制的优点"><a href="#副本机制的优点" class="headerlink" title="副本机制的优点"></a>副本机制的优点</h2><ol>
<li>提供<strong>数据冗余</strong><ul>
<li>即使系统部分组件失效，系统依然能够继续运转，增加了<strong>整体可用性</strong>和<strong>数据持久性</strong></li>
</ul>
</li>
<li>提供<strong>高伸缩性</strong><ul>
<li>支持<strong>横向扩展</strong>，能够通过增加机器的方式来提升读性能，进而提高<strong>读操作吞吐量</strong></li>
</ul>
</li>
<li>改善<strong>数据局部性</strong><ul>
<li>允许将数据放入与用户<strong>地理位置相近</strong>的地方，从而<strong>降低系统延时</strong></li>
</ul>
</li>
<li><strong>Kafka</strong>只能享受副本机制提供<strong>数据冗余</strong>实现的<strong>高可用性</strong>和<strong>高持久性</strong></li>
</ol>
<a id="more"></a>
<h2 id="副本定义"><a href="#副本定义" class="headerlink" title="副本定义"></a>副本定义</h2><ol>
<li>Kafka主题划分为若干个分区，副本的概念上是在<strong>分区层级</strong>下定义的，<strong>每个分区配置若干个副本</strong></li>
<li>副本：本质上是一个<em><strong>只能追加写消息的提交日志</strong></em><ul>
<li><strong>同一个分区下的所有副本保存有相同的消息序列</strong>，这些副本<strong>分散保存在不同的Broker</strong>上，提高了<strong>数据可用性</strong></li>
</ul>
</li>
<li>实际生产环境中，每台Broker都可能保存有各个主题不同分区的不同副本</li>
</ol>
<p><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-replication-def.png" width=600/></p>
<h2 id="副本角色"><a href="#副本角色" class="headerlink" title="副本角色"></a>副本角色</h2><p><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-replication-role.png" width=800/></p>
<ol>
<li>Kafka采用基于领导者（<strong>Leader-based</strong>）的副本机制<ul>
<li>副本分为两类：<strong>领导者副本</strong>（Leader Replica）和<strong>追随者副本</strong>（Follower Replica）<ul>
<li>每个分区在<strong>创建</strong>时都要<strong>选举</strong>一个副本，称为领导者副本，其余的副本自动称为追随者副本</li>
</ul>
</li>
<li><strong>追随者副本是不对外提供服务</strong>的，<strong>所有的读写请求</strong>都必须发往<strong>领导者副本</strong>所在的Broker，由该Broker负责处理<ul>
<li>追随者副本的任务：从领导者副本<strong>异步拉取消息</strong>，并写入到自己的<strong>提交日志</strong>中，从而实现与领导者副本的<strong>同步</strong></li>
<li>所以Kafka无法提供<strong>读操作横向扩展</strong>和<strong>改善局部性</strong></li>
</ul>
</li>
<li>当领导者副本所在的Broker挂了，Kafka依托于<strong>ZK</strong>提供的<strong>监控功能</strong>能够<strong>实时感知</strong>，并立即开启新一轮的领导者选举<ul>
<li>从追随者副本中选择一个作为新的领导者，<strong>老Leader</strong>副本重启后，也只能作为<strong>追随者副本</strong>加入到集群中</li>
</ul>
</li>
</ul>
</li>
<li>Leader-based副本机制的好处<ul>
<li>方便实现<strong><code>Read-your-writes</code></strong><ul>
<li>Read-your-writes：使用生产者API向Kafka成功写入消息后，马上使用消费者API去读取刚才生产的消息</li>
<li>如果允许追随者副本对外提供服务，由于副本同步是<strong>异步</strong>的，客户端可能看不到最新写入的消息</li>
</ul>
</li>
<li>方便实现<strong>单调读</strong><code>Monotonic Reads</code><ul>
<li>单调读：对于一个消费者用户而言，在<strong>多次消费</strong>消息时，不会看到某条消息一会存在一会不存在</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="ISR-In-Sync-Replicas"><a href="#ISR-In-Sync-Replicas" class="headerlink" title="ISR(In-Sync Replicas)"></a><strong>ISR</strong>(In-Sync Replicas)</h2><p><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-replication-isr.png" width=600/></p>
<ol>
<li>ISR中的副本都是<strong>与Leader同步的副本</strong>，不在ISR中的追随者副本就被认为与Leader不同步</li>
<li><strong>Leader副本天然在ISR中</strong>，某些特殊情况下，ISR只有Leader副本</li>
<li>上图中的2个Follower都有可能与Leader不同步，也都有可能与Leader同步<ul>
<li>参照标准是Broker端参数<strong><code>replica.lag.time.max.ms</code></strong>，而不是相差的消息数</li>
<li><code>replica.lag.time.max.ms</code>：Follower副本能够落后Leader副本的最长时间间隔，默认<strong>10秒</strong></li>
</ul>
</li>
<li>Follower副本同步的速度<strong>持续慢于</strong>Leader副本的消息写入速度<ul>
<li>在<code>replica.lag.time.max.ms</code>后，Follower副本就会被认为与Leader副本不同步</li>
<li>此时，Kafka会<strong>自动收缩ISR</strong>，将该Follower副本踢出ISR</li>
<li>如果该Follower副本后面慢慢追上Leader的进度，它能够<strong>重新</strong>被加回ISR，因此ISR是一个<strong>动态调整</strong>的集合</li>
</ul>
</li>
</ol>
<h2 id="Unclean-Leader-Election"><a href="#Unclean-Leader-Election" class="headerlink" title="Unclean Leader Election"></a>Unclean Leader Election</h2><ol>
<li>如果<strong>ISR为空</strong>，说明Leader副本也挂了，Kafka需要重新选举一个新的Leader</li>
<li>Kafka把<strong>所有不在ISR中的存活副本</strong>都称为<strong>非同步副本</strong></li>
<li>通常来说，<strong>非同步副本落后Leader太多</strong>，如果选择非同步副本作为新Leader，可能会出现<strong>数据丢失</strong></li>
<li>选举<strong>非同步副本</strong>的过程称为<strong>Unclean Leader Election</strong>，Broker端参数<code>unclean.leader.election.enable</code></li>
<li><strong>A Or C</strong><ul>
<li><strong>开启</strong>Unclean Leader Election可能会造成<strong>数据丢失</strong>（C），但提高了<strong>可用性</strong>（A）</li>
<li><strong>关闭</strong>Unclean Leader Election维护了<strong>数据一致性</strong>（C），但牺牲了<strong>可用性</strong>（A）<ul>
<li>强烈<strong>推荐</strong>关闭Unclean Leader Election</li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="思考：我反复强调了-Follower-副本不对外提供服务这件事情。有意思的是，社区最近正在考虑是否要打破这个限制，即允许-Follower-副本处理客户端消费者发来的请求。社区主要的考量是，这能够用于改善云上数据的局部性，更好地服务地理位置相近的客户。如果允许-Follower-副本对外提供读服务，你觉得应该如何避免或缓解因-Follower-副本与-Leader-副本不同步而导致的数据不一致的情形？"><a href="#思考：我反复强调了-Follower-副本不对外提供服务这件事情。有意思的是，社区最近正在考虑是否要打破这个限制，即允许-Follower-副本处理客户端消费者发来的请求。社区主要的考量是，这能够用于改善云上数据的局部性，更好地服务地理位置相近的客户。如果允许-Follower-副本对外提供读服务，你觉得应该如何避免或缓解因-Follower-副本与-Leader-副本不同步而导致的数据不一致的情形？" class="headerlink" title="思考：我反复强调了 Follower 副本不对外提供服务这件事情。有意思的是，社区最近正在考虑是否要打破这个限制，即允许 Follower 副本处理客户端消费者发来的请求。社区主要的考量是，这能够用于改善云上数据的局部性，更好地服务地理位置相近的客户。如果允许 Follower 副本对外提供读服务，你觉得应该如何避免或缓解因 Follower 副本与 Leader 副本不同步而导致的数据不一致的情形？"></a>思考：我反复强调了 Follower 副本不对外提供服务这件事情。有意思的是，社区最近正在考虑是否要打破这个限制，即允许 Follower 副本处理客户端消费者发来的请求。社区主要的考量是，这能够用于改善云上数据的局部性，更好地服务地理位置相近的客户。如果允许 Follower 副本对外提供读服务，你觉得应该如何避免或缓解因 Follower 副本与 Leader 副本不同步而导致的数据不一致的情形？</h5><p>参考：<a href="http://zhongmingmao.me/2019/09/14/kafka-replication/" target="_blank" rel="noopener">http://zhongmingmao.me/2019/09/14/kafka-replication/</a></p>
]]></content>
      <categories>
        <category>Middleware</category>
        <category>MQ</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Middleware</tag>
        <tag>MQ</tag>
        <tag>Kafka</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka -- 重设消费者组位移</title>
    <url>/2019/09/26/kafka-reset-consumer-group-offset/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ol>
<li>Kafka和传统的消息引擎在设计上有很大的区别，Kafka消费者读取消息是可以<strong>重演</strong>的</li>
<li>像RabbitMQ和ActiveMQ等传统消息中间件，处理和响应消息的方式是<strong>破坏性</strong><ul>
<li>一旦消息被成功处理，就会从Broker上被<strong>删除</strong></li>
</ul>
</li>
<li>Kafka是基于<strong>日志</strong>结构（Log-based）的消息引擎<ul>
<li>消费者在消费消息时，仅仅是从磁盘文件中读取数据而已，是<strong>只读</strong>操作，因为消费者<strong>不会删除</strong>消息数据</li>
<li>同时，由于位移数据是由消费者控制的，因此能够很容易地修改位移值，实现<strong>重复消费</strong>历史数据的功能</li>
</ul>
</li>
<li>Kafka Or 传统消息中间件<ul>
<li>传统消息中间件：消息处理逻辑非常复杂，处理代价高、又<strong>不关心消息之间的顺序</strong></li>
<li>Kafka：需要<strong>较高的吞吐量</strong>、但<strong>每条消息的处理时间很短</strong>，又<strong>关心消息的顺序</strong></li>
</ul>
</li>
</ol>
<a id="more"></a>
<h2 id="重设位移策略"><a href="#重设位移策略" class="headerlink" title="重设位移策略"></a>重设位移策略</h2><ol>
<li><strong>位移</strong>维度<ul>
<li>直接把消费者的位移值重设成给定的位移值</li>
</ul>
</li>
<li><strong>时间</strong>维度<ul>
<li>给定一个时间，让消费者把位移调整成<strong>大于该时间的最小位移</strong></li>
</ul>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>维度</th>
<th>策略</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>位移维度</td>
<td><strong>Earliest</strong></td>
<td>把位移调整到<strong>当前最早</strong>位移处</td>
</tr>
<tr>
<td></td>
<td><strong>Latest</strong></td>
<td>把位移调整到<strong>当前最新</strong>位移处</td>
</tr>
<tr>
<td></td>
<td><strong>Current</strong></td>
<td>把位移调整到<strong>当前最新提交</strong>位移处</td>
</tr>
<tr>
<td></td>
<td><strong>Specified-Offset</strong></td>
<td>把位移调整成<strong>指定位移</strong></td>
</tr>
<tr>
<td></td>
<td><strong>Shift-By-N</strong></td>
<td>把位移调整成到<strong>当前位移+N</strong>处（N可以是<strong>负值</strong>）</td>
</tr>
<tr>
<td>时间维度</td>
<td><strong>DateTime</strong></td>
<td>把位移调整到<strong>大于给定时间的最小位移</strong>处</td>
</tr>
<tr>
<td></td>
<td><strong>Duration</strong></td>
<td>把位移调整到<strong>距离当前时间指定间隔的位移</strong>处</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li><strong>Earliest</strong><ul>
<li><strong>最早位移不一定是0</strong>，在生产环境中，很久远的消息会被Kafka<strong>自动删除</strong></li>
<li>如果想要<strong>重新消费主题的所有消息</strong>，可以使用Earliest策略</li>
</ul>
</li>
<li><strong>Latest</strong><ul>
<li>如果想要<strong>跳过所有历史消息</strong>，打算从最新的消息处开始消费，可以使用Latest策略</li>
</ul>
</li>
<li><strong>Specified-Offset</strong><ul>
<li>典型使用场景：消费者程序在处理某条<strong>错误消息</strong>时，可以<strong>手动跳过</strong>此消息的处理</li>
</ul>
</li>
<li><strong>Duration</strong><ul>
<li>格式为<code>PnDTnHnMnS</code>，<strong>D</strong>、<strong>H</strong>、<strong>M</strong>、<strong>S</strong>分别代表天、小时、分钟、秒</li>
<li>如果想将位移调回到15分钟前，可以指定<strong><code>PT0H15M0S</code></strong></li>
</ul>
</li>
</ol>
<h2 id="重设位移方式"><a href="#重设位移方式" class="headerlink" title="重设位移方式"></a>重设位移方式</h2><h3 id="消费者API"><a href="#消费者API" class="headerlink" title="消费者API"></a>消费者API</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.apache.kafka.clients.consumer.Consumer</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seek</span><span class="params">(TopicPartition partition, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seekToBeginning</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seekToEnd</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>每次调用<code>seek</code>方法<strong>只能重设一个分区的位移</strong></li>
<li><code>seekToBeginning</code>和<code>seekToEnd</code>可以一次性重设多个分区</li>
</ol>
<h4 id="Earliest"><a href="#Earliest" class="headerlink" title="Earliest"></a>Earliest</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties consumerProperties = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="comment">// 禁止自动提交位移</span></span><br><span class="line">consumerProperties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="keyword">false</span>);</span><br><span class="line">consumerProperties.put(ConsumerConfig.GROUP_ID_CONFIG, <span class="string">"zhongmingmao"</span>);</span><br><span class="line">consumerProperties.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, <span class="string">"earliest"</span>);</span><br><span class="line">consumerProperties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">consumerProperties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">consumerProperties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">"localhost:9092"</span>);</span><br><span class="line"></span><br><span class="line">String topic = <span class="string">"zhongmingmao"</span>;  <span class="comment">// 要重设位移的Kafka主题</span></span><br><span class="line"><span class="keyword">try</span> (<span class="keyword">final</span> KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(consumerProperties)) &#123;</span><br><span class="line">    consumer.subscribe(Collections.singleton(topic));</span><br><span class="line">    <span class="comment">// 调用consumer.poll(0)，不要调用consumer.poll(Duration.ofSecond(0))</span></span><br><span class="line">    consumer.poll(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 一次性构造主题的所有分区对象</span></span><br><span class="line">    consumer.seekToBeginning(consumer.partitionsFor(topic).stream().map(</span><br><span class="line">            partitionInfo -&gt; <span class="keyword">new</span> TopicPartition(topic, partitionInfo.partition())).collect(Collectors.toList()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Latest"><a href="#Latest" class="headerlink" title="Latest"></a>Latest</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">consumer.seekToEnd(consumer.partitionsFor(topic).stream().map(</span><br><span class="line">        partitionInfo -&gt; <span class="keyword">new</span> TopicPartition(topic, partitionInfo.partition())).collect(Collectors.toList()));</span><br></pre></td></tr></table></figure>
<h4 id="Current"><a href="#Current" class="headerlink" title="Current"></a>Current</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">consumer.partitionsFor(topic).stream().map(</span><br><span class="line">        info -&gt; <span class="keyword">new</span> TopicPartition(topic, info.partition())).forEach(</span><br><span class="line">        tp -&gt; &#123;</span><br><span class="line">            <span class="comment">// 通过committed方法获取分区当前提交的最新位移</span></span><br><span class="line">            <span class="keyword">long</span> committedOffset = consumer.committed(tp).offset();</span><br><span class="line">            consumer.seek(tp, committedOffset);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Specified-Offset"><a href="#Specified-Offset" class="headerlink" title="Specified-Offset"></a>Specified-Offset</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> targetOffset = <span class="number">1234L</span>;</span><br><span class="line"><span class="keyword">for</span> (PartitionInfo info : consumer.partitionsFor(topic)) &#123;</span><br><span class="line">    TopicPartition tp = <span class="keyword">new</span> TopicPartition(topic, info.partition());</span><br><span class="line">    consumer.seek(tp, targetOffset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Shift-By-N"><a href="#Shift-By-N" class="headerlink" title="Shift-By-N"></a>Shift-By-N</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (PartitionInfo info : consumer.partitionsFor(topic)) &#123;</span><br><span class="line">    TopicPartition tp = <span class="keyword">new</span> TopicPartition(topic, info.partition());</span><br><span class="line">    <span class="comment">// 假设向前跳123条消息</span></span><br><span class="line">    <span class="keyword">long</span> targetOffset = consumer.committed(tp).offset() + <span class="number">123L</span>;</span><br><span class="line">    consumer.seek(tp, targetOffset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="DateTime"><a href="#DateTime" class="headerlink" title="DateTime"></a>DateTime</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> ts = LocalDateTime.of(<span class="number">2019</span>, <span class="number">6</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">0</span>)</span><br><span class="line">        .toInstant(ZoneOffset.ofHours(<span class="number">8</span>)).toEpochMilli();</span><br><span class="line"><span class="comment">// 查找对应的位移值</span></span><br><span class="line">Map&lt;TopicPartition, Long&gt; timeToSearch =</span><br><span class="line">        consumer.partitionsFor(topic).stream().map(info -&gt;</span><br><span class="line">                <span class="keyword">new</span> TopicPartition(topic, info.partition()))</span><br><span class="line">                .collect(Collectors.toMap(Function.identity(), tp -&gt; ts));</span><br><span class="line"></span><br><span class="line"><span class="comment">// offsetsForTimes</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;TopicPartition, OffsetAndTimestamp&gt; entry : consumer.offsetsForTimes(timeToSearch).entrySet()) &#123;</span><br><span class="line">    consumer.seek(entry.getKey(), entry.getValue().offset());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Duration"><a href="#Duration" class="headerlink" title="Duration"></a>Duration</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;TopicPartition, Long&gt; timeToSearch = consumer.partitionsFor(topic).stream().map(</span><br><span class="line">        info -&gt; <span class="keyword">new</span> TopicPartition(topic, info.partition()))</span><br><span class="line">        .collect(Collectors.toMap(Function.identity(), tp -&gt; System.currentTimeMillis() - <span class="number">30</span> * <span class="number">1000</span> * <span class="number">60</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;TopicPartition, OffsetAndTimestamp&gt; entry : consumer.offsetsForTimes(timeToSearch).entrySet()) &#123;</span><br><span class="line">    consumer.seek(entry.getKey(), entry.getValue().offset());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h3><p>从Kafka <strong>0.11</strong>版本开始引入</p>
<h4 id="Earliest-1"><a href="#Earliest-1" class="headerlink" title="Earliest"></a>Earliest</h4><p><code>--to-earliest</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kafka-consumer-groups --bootstrap-server localhost:9092 --group test-group --reset-offsets --all-topics --to-earliest --execute</span><br></pre></td></tr></table></figure></p>
<h4 id="Latest-1"><a href="#Latest-1" class="headerlink" title="Latest"></a>Latest</h4><p><code>--to-latest</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kafka-consumer-groups --bootstrap-server localhost:9092 --group test-group --reset-offsets --all-topics --to-latest --execute</span><br></pre></td></tr></table></figure></p>
<h4 id="Current-1"><a href="#Current-1" class="headerlink" title="Current"></a>Current</h4><p><code>--to-current</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kafka-consumer-groups --bootstrap-server localhost:9092 --group test-group --reset-offsets --all-topics --to-current --execute</span><br></pre></td></tr></table></figure></p>
<h4 id="Specified-Offset-1"><a href="#Specified-Offset-1" class="headerlink" title="Specified-Offset"></a>Specified-Offset</h4><p><code>--to-offset</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kafka-consumer-groups --bootstrap-server localhost:9092 --group test-group --reset-offsets --all-topics --to-offset &lt;offset&gt; --execute</span><br></pre></td></tr></table></figure></p>
<h4 id="Shift-By-N-1"><a href="#Shift-By-N-1" class="headerlink" title="Shift-By-N"></a>Shift-By-N</h4><p><code>--shift-by</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kafka-consumer-groups --bootstrap-server localhost:9092 --group test-group --reset-offsets --shift-by &lt;offset_N&gt; --execute</span><br></pre></td></tr></table></figure></p>
<h4 id="DateTime-1"><a href="#DateTime-1" class="headerlink" title="DateTime"></a>DateTime</h4><p><code>--to-datetime</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kafka-consumer-groups --bootstrap-server localhost:9092 --group test-group --reset-offsets --to-datetime 2019-09-26T00:00:00.000 --execute</span><br></pre></td></tr></table></figure></p>
<h4 id="Duration-1"><a href="#Duration-1" class="headerlink" title="Duration"></a>Duration</h4><p><code>--by-duration</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kafka-consumer-groups --bootstrap-server localhost:9092 --group test-group --reset-offsets --by-duration PT0H30M0S --execute</span><br></pre></td></tr></table></figure><br>参考：<a href="http://zhongmingmao.me" target="_blank" rel="noopener">http://zhongmingmao.me</a></p>
]]></content>
      <categories>
        <category>Middleware</category>
        <category>MQ</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Middleware</tag>
        <tag>MQ</tag>
        <tag>Kafka</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka -- 重平衡</title>
    <url>/2019/09/16/kafka-rebalance/</url>
    <content><![CDATA[<h2 id="触发重平衡"><a href="#触发重平衡" class="headerlink" title="触发重平衡"></a>触发重平衡</h2><ol>
<li><strong>组成员数量</strong>发生变化 — <strong>最常见</strong></li>
<li><strong>订阅主题数量</strong>发生变化</li>
<li><strong>订阅主题的分区数</strong>发生变化</li>
</ol>
<a id="more"></a>
<h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><ol>
<li>重平衡过程是通过<strong>消费者的心跳线程</strong>通知到其它消费者实例的</li>
<li>Kafka Java消费者需要<strong>定期</strong>地发送心跳请求到Broker端的协调者，表明它还活着</li>
<li>在Kafka <strong>0.10.1.0</strong>之前，<strong>发送心跳请求</strong>是在消费者<strong>主线程</strong>完成的，即调用<code>poll</code>方法的那个线程<ul>
<li>弊端<ul>
<li><strong>消息处理</strong>逻辑是也在<strong>主线程</strong>完成的</li>
<li>一旦消息处理消耗了很长时间，心跳请求将无法及时发送给协调者，导致协调者<strong>误以为消费者已死</strong></li>
</ul>
</li>
<li>从Kafka 0.10.1.0开始，社区引入了<strong>单独的心跳线程</strong></li>
</ul>
</li>
<li><strong>重平衡的通知机制</strong>是通过<strong>心跳线程</strong>来完成的<ul>
<li>当协调者决定开启新一轮重平衡后，会将<code>REBALANCE_IN_PROGRESS</code>封装进<strong>心跳请求的响应</strong>中</li>
<li>当消费者实例发现心跳响应中包含<code>REBALANCE_IN_PROGRESS</code>，就知道重平衡要开始了，这是重平衡的通知机制</li>
</ul>
</li>
<li><code>heartbeat.interval.ms</code>的真正作用是控制<strong>重平衡通知的频率</strong></li>
</ol>
<h2 id="消费者组状态机"><a href="#消费者组状态机" class="headerlink" title="消费者组状态机"></a>消费者组状态机</h2><div class="table-container">
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Empty</strong></td>
<td>组内<strong>没有任何成员</strong>，但消费者组可能<strong>存在已提交的位移数据</strong>，而且这些位移<strong>尚未过期</strong></td>
</tr>
<tr>
<td><strong>Dead</strong></td>
<td>组内<strong>没有任何成员</strong>，但<strong>组的元数据已经在协调者端被移除</strong>，协调者组件保存着当前向它注册过的所有组信息</td>
</tr>
<tr>
<td><strong>PreparingRebalance</strong></td>
<td>消费者组<strong>准备开启</strong>重平衡，此时所有成员都要<strong>重新请求加入消费者组</strong></td>
</tr>
<tr>
<td><strong>CompletingRebalance</strong></td>
<td>消费者组下<strong>所有成员已经加入</strong>，各个成员正在<strong>等待分配方案</strong><br/>该状态在老版本中称为<strong>AwaitingSync</strong>，与CompetingRebalance是等价的</td>
</tr>
<tr>
<td><strong>Stable</strong></td>
<td>消费者组的<strong>稳定状态</strong>，该状态表明重平衡<strong>已经完成</strong>，组内各成员都能够<strong>正常消费数据</strong>了</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-rebalance-consumer-group-state-machine.png" width=1000></p>
<ol>
<li>一个消费者组最开始是<strong>Empty</strong>状态，当重平衡过程开启后，会被置于<strong>PreparingRebalance</strong>状态等待成员加入<ul>
<li>之后变更到<strong>CompletingRebalance</strong>状态等待分配方案，最后流转到<strong>Stable</strong>状态完成重平衡</li>
</ul>
</li>
<li>当有新成员加入或已有成员退出时，消费者组的状态从<strong>Stable</strong>直接跳到<strong>PreparingRebalance</strong>状态<ul>
<li>所有现存成员都必须<strong>重新申请加入组</strong></li>
</ul>
</li>
<li>当所有成员都退出组后，消费者组状态变更为<strong>Empty</strong><ul>
<li>Kafka<strong>定期自动删除过期位移</strong>的条件是消费者组要处于<strong>Empty</strong>状态</li>
<li><code>Removed ✘✘✘ expired offsets in ✘✘✘ milliseconds</code></li>
</ul>
</li>
</ol>
<h2 id="重平衡流程"><a href="#重平衡流程" class="headerlink" title="重平衡流程"></a>重平衡流程</h2><p>重平衡流程需要<strong>消费者端</strong>和<strong>协调者组件</strong>共同参与才能完成</p>
<h3 id="消费者端"><a href="#消费者端" class="headerlink" title="消费者端"></a>消费者端</h3><ol>
<li>在消费者端，重平衡分为两个步骤：<strong>加入组</strong>、<strong>等待领导者消费者（Leader Consumer）分配方案</strong><ul>
<li>分别对应两类特定的请求：<strong>JoinGroup请求</strong>、<strong>SyncGroup请求</strong></li>
</ul>
</li>
<li>当组内成员加入组时，会向协调者发送JoinGroup请求<ul>
<li>在JoinGroup请求中，每个成员都要将自己<strong>订阅的主题</strong>上报，这样协调者就能收集所有成员的订阅信息</li>
<li>一旦收集了<strong>全部</strong>成员的JoinGroup请求后，协调者会从这些成员中选择一个担任这个消费者组的<strong>领导者</strong><ul>
<li>通常请求下，<strong>第一个</strong>发送JoinGroup请求的成员会自动成为领导者</li>
<li>这里的领导者与<strong>领导者副本</strong>不是一个概念，这里的领导者是<strong>具体的消费者实例</strong></li>
</ul>
</li>
<li>消费者领导者的职责：<strong>收集所有成员的订阅信息</strong>，然后根据这些信息，<em><strong>制定具体的分区消费分配方案</strong></em></li>
<li>选出领导者后协调者会把<strong>消费者组订阅信息</strong>封装进JoinGroup请求的响应体中，返回给领导者，<strong>由领导者统一分配</strong></li>
</ul>
</li>
<li><strong>领导者</strong>向协调者发送<strong>SyncGroup请求</strong>，将刚刚做出的<strong>分配方案</strong>发给协调者<ul>
<li>其它成员也会向协调者发送SyncGroup请求，只不过请求体中并没有实际的内容</li>
<li>让协调者接收分配方案，然后统一以<strong>SyncGroup响应</strong>的方式分发给所有成员</li>
</ul>
</li>
</ol>
<h4 id="JoinGroup"><a href="#JoinGroup" class="headerlink" title="JoinGroup"></a>JoinGroup</h4><p><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-rebalance-consumer-join-group.png" width=1000></p>
<ol>
<li><strong>JoinGroup</strong>请求的主要作用是<em><strong>将组成员订阅信息发送给领导者消费者</strong></em></li>
<li>待领导者<strong>制定好分配方案</strong>后，重平衡流程进入到<strong>SyncGroup</strong>请求阶段</li>
</ol>
<h4 id="SyncGroup"><a href="#SyncGroup" class="headerlink" title="SyncGroup"></a>SyncGroup</h4><p><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-rebalance-consumer-sync-group.png" width=1000></p>
<ol>
<li><strong>SyncGroup</strong>请求的主要作用是<em><strong>让协调者把领导者制定的分配方案下发给各个组内成员</strong></em></li>
<li>当所有成员都<strong>成功接收到分配方案</strong>后，消费者组进入<strong>Stable</strong>状态，即开始正常的消费工作</li>
</ol>
<h3 id="Broker端"><a href="#Broker端" class="headerlink" title="Broker端"></a>Broker端</h3><h4 id="新成员加入组"><a href="#新成员加入组" class="headerlink" title="新成员加入组"></a>新成员加入组</h4><p><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-rebalance-broker-join-group.png" width=1000></p>
<ol>
<li>新成员加入组指的是消费者组处于<strong>Stable</strong>状态后，有新成员加入，而不是全新启动一个消费者组</li>
<li>当协调者收到新的<strong>JoinGroup</strong>请求后，会通过<strong>心跳请求响应</strong>的方式通知组内现有的所有成员，<strong>强制它们开启新一轮重平衡</strong></li>
</ol>
<h4 id="组成员主动离组"><a href="#组成员主动离组" class="headerlink" title="组成员主动离组"></a>组成员主动离组</h4><p><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-rebalance-broker-leave-group.png" width=1000></p>
<ol>
<li>主动离组：消费者实例所在的线程或者进程调用<strong>close()</strong>方法<strong>主动</strong>通知协调者它要退出，即<strong>LeaveGroup</strong>请求</li>
<li>协调者收到<strong>LeaveGroup</strong>请求后，依然会以<strong>心跳响应</strong>的方式通知其它成员</li>
</ol>
<h4 id="组成员崩溃离组"><a href="#组成员崩溃离组" class="headerlink" title="组成员崩溃离组"></a>组成员崩溃离组</h4><p><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-rebalance-broker-crash-leave-group.png" width=1000></p>
<ol>
<li>崩溃离组：消费者实例出现<strong>严重故障</strong>，突然宕机导致的离组</li>
<li>主动离组，协调者能<strong>马上感知</strong>并处理；崩溃离组，协调者需要<strong>等待一段时间</strong>才能感知到，参数<code>session.timeout.ms</code></li>
</ol>
<h4 id="重平衡时协调者对组内成员提出位移的处理"><a href="#重平衡时协调者对组内成员提出位移的处理" class="headerlink" title="重平衡时协调者对组内成员提出位移的处理"></a>重平衡时协调者对组内成员提出位移的处理</h4><p><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-rebalance-broker-commit-offset.png" width=1000></p>
<ol>
<li>正常情况下，每个组内成员都会<strong>定期</strong>汇报位移给协调者</li>
<li>当重平衡开启时，协调者会给予成员一段<strong>缓冲时间</strong><ul>
<li>要求每个成员必须在这段缓冲时间内<strong>快速上报位移信息</strong>，然后再开启正常的<strong>JoinGroup/SyncGroup</strong>请求</li>
</ul>
</li>
</ol>
<p>参考：<a href="http://zhongmingmao.me/2019/09/16/kafka-rebalance/" target="_blank" rel="noopener">http://zhongmingmao.me/2019/09/16/kafka-rebalance/</a></p>
]]></content>
      <categories>
        <category>Middleware</category>
        <category>MQ</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Middleware</tag>
        <tag>MQ</tag>
        <tag>Kafka</tag>
        <tag>Stream</tag>
        <tag>Rebalance</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka -- 常用脚本</title>
    <url>/2019/09/27/kafka-shell/</url>
    <content><![CDATA[<h2 id="脚本列表"><a href="#脚本列表" class="headerlink" title="脚本列表"></a>脚本列表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connect-distributed              kafka-consumer-perf-test         kafka-reassign-partitions        kafka-verifiable-producer</span><br><span class="line">connect-standalone               kafka-delegation-tokens          kafka-replica-verification       trogdor</span><br><span class="line">kafka-acls                       kafka-delete-records             kafka-run-class                  zookeeper-security-migration</span><br><span class="line">kafka-broker-api-versions        kafka-dump-log                   kafka-server-start               zookeeper-server-start</span><br><span class="line">kafka-configs                    kafka-log-dirs                   kafka-server-stop                zookeeper-server-stop</span><br><span class="line">kafka-console-consumer           kafka-mirror-maker               kafka-streams-application-reset  zookeeper-shell</span><br><span class="line">kafka-console-producer           kafka-preferred-replica-election kafka-topics</span><br><span class="line">kafka-consumer-groups            kafka-producer-perf-test         kafka-verifiable-consumer</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="脚本注解"><a href="#脚本注解" class="headerlink" title="脚本注解"></a>脚本注解</h4><ul>
<li><p><code>connect-standalone 和 connect-distributed</code>: 这两个脚本是 Kafka Connect 组件的启动脚本</p>
</li>
<li><p><code>kafka-acls</code>: 它是用于设置 Kafka 权限的，比如设置哪些用户可以访问 Kafka 的哪些主题之类的权限</p>
</li>
<li><p><code>kafka-broker-api-versions</code>: 这个脚本的主要目的是验证不同 Kafka 版本之间服务器和客户端的适配性</p>
</li>
<li><p><code>kafka-configs</code>: 主要参数配置</p>
</li>
<li><p><code>kafka-console-consumer</code>：消费者脚本</p>
</li>
<li><p><code>kafka-console-producer</code>： 生产者脚本</p>
</li>
<li><p><code>kafka-producer-perf-test、 kafka-consumer-perf-test</code> ：生产者和消费者的性能测试工具</p>
</li>
<li><p><code>kafka-consumer-groups</code>:消费者组位移</p>
</li>
<li><p><code>kafka-delegation-tokens</code>：它是管理 Delegation Token 的。基于 Delegation Token 的认证是一种轻量级的认证机制，补充了现有的 SASL 认证机制</p>
</li>
<li><p><code>kafka-delete-records</code>：用于删除kafka分区消息，kafka本身有自己的自动消息删除策略，所以使用的不多</p>
</li>
<li><p><code>kafka-dump-log</code> ：非常实用，查看kafka消息文件的内容，消息的元数据信息，消息体本身</p>
</li>
<li><p><code>kafka-log-dirs</code>：查询各个Broker上的各个日志路径的磁盘占用情况</p>
</li>
<li><p><code>kafka-mirror-maker</code>：实现kafka集群间的消息同步的</p>
</li>
<li><p><code>kafka-preferred-replica-election</code>：执行 Preferred Leader 选举的。它可以为指定的主题执行“换 Leader”的操作</p>
</li>
<li><p><code>kafka-reassign-partitions</code>：用于执行分区副本迁移以及副本文件路径迁移</p>
</li>
<li><p><code>kafka-topics</code>：所有主题管理操作</p>
</li>
<li><p><code>kafka-run-class</code>： 执行任何带 main 方法的 Kafka 类</p>
</li>
<li><p><code>kafka-server-start、kafka-server-stop</code>：用于启动和停止 Kafka Broker 进程的</p>
</li>
<li><p><code>kafka-streams-application-reset</code>: 脚本用来给 Kafka Streams 应用程序重设位移，以便重新消费数据</p>
</li>
<li><p><code>kafka-verifiable-producer 、 kafka-verifiable-consumer</code>: 脚本是用来测试生产者和消费者功能的，过时，用不到</p>
<p>​</p>
</li>
</ul>
<h2 id="kafka-broker-api-versions"><a href="#kafka-broker-api-versions" class="headerlink" title="kafka-broker-api-versions"></a>kafka-broker-api-versions</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kafka-broker-api-versions --bootstrap-server localhost:9092</span><br><span class="line">localhost:9092 (id: 0 rack: null) -&gt; (</span><br><span class="line">	Produce(0): 0 to 7 [usable: 7],</span><br><span class="line">	Fetch(1): 0 to 11 [usable: 11],</span><br><span class="line">	ListOffsets(2): 0 to 5 [usable: 5],</span><br><span class="line">	Metadata(3): 0 to 8 [usable: 8],</span><br><span class="line">	LeaderAndIsr(4): 0 to 2 [usable: 2],</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ol>
<li>kafka-broker-api-versions脚本用于验证<strong>不同Kafka版本</strong>之间<strong>服务器</strong>和<strong>客户端</strong>的适配性</li>
<li><code>Produce(0): 0 to 7 [usable: 7]</code><ul>
<li>Produce请求，序号为0，表示Kafka所有请求类型中的<strong>第一号</strong>请求</li>
<li><code>0 to 7</code>表示Produce请求在Kafka 2.3中总共有<strong>8个版本</strong></li>
<li><code>usable: 7</code>表示当前连入这个Broker的客户端API能够使用的版本号是7，即<strong>最新版本</strong></li>
</ul>
</li>
<li>在<strong>0.10.2.0</strong>之前，Kafka是<strong>单向兼容</strong>的，即高版本的Broker能够处理低版本Client发送的请求，反正则不行</li>
<li>从<strong>0.10.2.0</strong>开始，Kafka正式支持<strong>双向兼容</strong>，即<em><strong>低版本的Broker也能处理高版本Client的请求</strong></em></li>
</ol>
<h2 id="kafka-topics"><a href="#kafka-topics" class="headerlink" title="kafka-topics"></a>kafka-topics</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-- 创建主题 </span><br><span class="line">    bin/kafka-topics.sh --create --zookeeper zk1:2181 --replication-factor 3 --partitions 1 --topic action</span><br><span class="line">	bin/kafka-topics.sh --zookeeper zk1:2181 --create --topic action --partitions 1 --replication-factor 1 --config retention.ms=15552000000 --config max.message.bytes=5242880</span><br><span class="line">	-- topic 定义topic名</span><br><span class="line">    -- partitions 定义分区数</span><br><span class="line">    -- replication-factor 定义副本数</span><br><span class="line">-- 修改主题</span><br><span class="line">	bin/kafka-configs.sh --zookeeper zk1:2181 --entity-type topics --entity-name action --alter --add-config max.message.bytes=10485760</span><br><span class="line">-- 查看主题</span><br><span class="line">	bin/kafka-topics.sh --describe --zookeeper zk1:2181 --topic action</span><br><span class="line">-- 查看所有主题</span><br><span class="line">	bin/kafka-topics.sh --zookeeper zk1:2181 --list</span><br><span class="line">-- 删除主题</span><br><span class="line">	bin/kafka-topics.sh --zookeeper  zk1:2181 --delete --topic first</span><br></pre></td></tr></table></figure>
<h2 id="kafka-console-producer"><a href="#kafka-console-producer" class="headerlink" title="kafka-console-producer"></a>kafka-console-producer</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;kafka-console-producer.sh --broker-list 192.168.1.67:9092 --topic second --request-required-acks -1 --producer-property compression.type&#x3D;lz4</span><br><span class="line">&gt;hello</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<h2 id="kafka-console-consumer"><a href="#kafka-console-consumer" class="headerlink" title="kafka-console-consumer"></a>kafka-console-consumer</h2><p>如果没有指定<code>group</code>，每次运行Console Consumer，都会<strong>自动生成一个新的消费者组</strong>（console-consumer开头）来消费<br><code>--from-beginning</code>等同于将Consumer端参数<code>auto.offset.reset</code>设置为<strong><code>Earliest</code></strong>（默认值为<code>Latest</code>）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;kafka-console-consumer.sh --bootstrap-server 192.168.1.67:9092 --topic second --group second --from-beginning --consumer-property enable.auto.commit&#x3D;false</span><br><span class="line">hello</span><br></pre></td></tr></table></figure></p>
<h2 id="kafka-producer-perf-test"><a href="#kafka-producer-perf-test" class="headerlink" title="kafka-producer-perf-test"></a>kafka-producer-perf-test</h2><p>向指定专题发送1千万条消息，每条消息大小为<strong>1KB</strong>，一般关注<strong>99th</strong>分位即可，可以作为该生产者对外承诺的<strong>SLA</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;kafka-producer-perf-test.sh --topic second --num-records 10000000 --throughput -1 --record-size 1024 --producer-props bootstrap.servers&#x3D;192.168.1.67:9092 acks&#x3D;-1 linger.ms&#x3D;2000 compression.type&#x3D;lz4</span><br><span class="line">24041 records sent, 4802.4 records&#x2F;sec (4.69 MB&#x2F;sec), 2504.6 ms avg latency, 3686.0 ms max latency.</span><br><span class="line">374745 records sent, 74829.3 records&#x2F;sec (73.08 MB&#x2F;sec), 3955.9 ms avg latency, 4258.0 ms max latency.</span><br><span class="line">530462 records sent, 106092.4 records&#x2F;sec (103.61 MB&#x2F;sec), 5043.2 ms avg latency, 5979.0 ms max latency.</span><br><span class="line">973178 records sent, 194402.3 records&#x2F;sec (189.85 MB&#x2F;sec), 4616.0 ms avg latency, 6092.0 ms max latency.</span><br><span class="line">1114737 records sent, 222858.3 records&#x2F;sec (217.64 MB&#x2F;sec), 3226.9 ms avg latency, 3501.0 ms max latency.</span><br><span class="line">1274003 records sent, 254647.8 records&#x2F;sec (248.68 MB&#x2F;sec), 2967.1 ms avg latency, 3258.0 ms max latency.</span><br><span class="line">1315568 records sent, 262798.2 records&#x2F;sec (256.64 MB&#x2F;sec), 2655.6 ms avg latency, 2790.0 ms max latency.</span><br><span class="line">1384239 records sent, 276847.8 records&#x2F;sec (270.36 MB&#x2F;sec), 2665.2 ms avg latency, 2799.0 ms max latency.</span><br><span class="line">1419418 records sent, 283883.6 records&#x2F;sec (277.23 MB&#x2F;sec), 2509.9 ms avg latency, 2612.0 ms max latency.</span><br><span class="line">10000000 records sent, 201751.200420 records&#x2F;sec (197.02 MB&#x2F;sec), 3041.05 ms avg latency, 6092.00 ms max latency, 2684 ms 50th, 5500 ms 95th, 5999 ms 99th, 6085 ms 99.9th.</span><br></pre></td></tr></table></figure></p>
<h2 id="kafka-consumer-perf-test"><a href="#kafka-consumer-perf-test" class="headerlink" title="kafka-consumer-perf-test"></a>kafka-consumer-perf-test</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;kafka-consumer-perf-test.sh --broker-list 192.168.1.67:9092 --messages 10000000 --topic second</span><br><span class="line">start.time, end.time, data.consumed.in.MB, MB.sec, data.consumed.in.nMsg, nMsg.sec, rebalance.time.ms, fetch.time.ms, fetch.MB.sec, fetch.nMsg.sec</span><br><span class="line">2019-09-27 19:46:34:219, 2019-10-30 19:46:52:092, 9765.6250, 546.3898, 10000002, 559503.2731, 50, 17823, 547.9226, 561072.8834</span><br></pre></td></tr></table></figure>
<h2 id="查看主题消息总数"><a href="#查看主题消息总数" class="headerlink" title="查看主题消息总数"></a>查看主题消息总数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ .&#x2F;kafka-run-class.sh kafka.tools.GetOffsetShell --broker-list 192.168.1.67:9092 --time -2 --topic second</span><br><span class="line">second:0:0</span><br><span class="line"></span><br><span class="line">$ .&#x2F;kafka-run-class.sh kafka.tools.GetOffsetShell --broker-list 192.168.1.67:9092 --time -1 --topic second</span><br><span class="line">second:0:10000014</span><br></pre></td></tr></table></figure>
<h2 id="查看消息文件数据"><a href="#查看消息文件数据" class="headerlink" title="查看消息文件数据"></a>查看消息文件数据</h2><p><code>--files</code>显式的是消息批次或消息集合的<strong>元数据</strong>信息<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;kafka-dump-log.sh --files &#x2F;tmp&#x2F;kafka-logs&#x2F;transaction-0&#x2F;00000000000000635791.log | head -n 10</span><br><span class="line">Dumping &#x2F;tmp&#x2F;kafka-logs&#x2F;transaction-0&#x2F;00000000000000635791.log</span><br><span class="line">Starting offset: 635791</span><br><span class="line">baseOffset: 635791 lastOffset: 635791 count: 1 baseSequence: -1 lastSequence: -1 producerId: -1 producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false isControl: false position: 0 CreateTime: 1590738831653 isvalid: true size: 51272 magic: 2 compresscodec: NONE crc: 2926696969</span><br><span class="line">baseOffset: 635792 lastOffset: 635792 count: 1 baseSequence: -1 lastSequence: -1 producerId: -1 producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false isControl: false position: 51272 CreateTime: 1590738831657 isvalid: true size: 51272 magic: 2 compresscodec: NONE crc: 3982704702</span><br><span class="line">baseOffset: 635793 lastOffset: 635793 count: 1 baseSequence: -1 lastSequence: -1 producerId: -1 producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false isControl: false position: 102544 CreateTime: 1590738831657 isvalid: true size: 51272 magic: 2 compresscodec: NONE crc: 3982704702</span><br><span class="line">baseOffset: 635794 lastOffset: 635794 count: 1 baseSequence: -1 lastSequence: -1 producerId: -1 producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false isControl: false position: 153816 CreateTime: 1590738831657 isvalid: true size: 51272 magic: 2 compresscodec: NONE crc: 3982704702</span><br><span class="line">baseOffset: 635795 lastOffset: 635795 count: 1 baseSequence: -1 lastSequence: -1 producerId: -1 producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false isControl: false position: 205088 CreateTime: 1590738831657 isvalid: true size: 51272 magic: 2 compresscodec: NONE crc: 3982704702</span><br><span class="line">baseOffset: 635796 lastOffset: 635796 count: 1 baseSequence: -1 lastSequence: -1 producerId: -1 producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false isControl: false position: 256360 CreateTime: 1590738831657 isvalid: true size: 51272 magic: 2 compresscodec: NONE crc: 3982704702</span><br><span class="line">baseOffset: 635797 lastOffset: 635797 count: 1 baseSequence: -1 lastSequence: -1 producerId: -1 producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false isControl: false position: 307632 CreateTime: 1590738831657 isvalid: true size: 51272 magic: 2 compresscodec: NONE crc: 3982704702</span><br><span class="line">baseOffset: 635798 lastOffset: 635798 count: 1 baseSequence: -1 lastSequence: -1 producerId: -1 producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false isControl: false position: 358904 CreateTime: 1590738831657 isvalid: true size: 51272 magic: 2 compresscodec: NONE crc: 3982704702</span><br></pre></td></tr></table></figure><br><code>--deep-iteration</code>用于查看每条<strong>具体</strong>的消息<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ .&#x2F;kafka-dump-log.sh --files &#x2F;tmp&#x2F;kafka-logs&#x2F;transaction-0&#x2F;00000000000000635791.log --deep-iteration | head -n 25</span><br><span class="line">Dumping &#x2F;tmp&#x2F;kafka-logs&#x2F;transaction-0&#x2F;00000000000000635791.log</span><br><span class="line">Starting offset: 635791</span><br><span class="line">offset: 635791 position: 0 CreateTime: 1590738831653 isvalid: true keysize: -1 valuesize: 51200 magic: 2 compresscodec: NONE producerId: -1 producerEpoch: -1 sequence: -1 isTransactional: false headerKeys: []</span><br><span class="line">offset: 635792 position: 51272 CreateTime: 1590738831657 isvalid: true keysize: -1 valuesize: 51200 magic: 2 compresscodec: NONE producerId: -1 producerEpoch: -1 sequence: -1 isTransactional: false headerKeys: []</span><br><span class="line">offset: 635793 position: 102544 CreateTime: 1590738831657 isvalid: true keysize: -1 valuesize: 51200 magic: 2 compresscodec: NONE producerId: -1 producerEpoch: -1 sequence: -1 isTransactional: false headerKeys: []</span><br><span class="line">offset: 635794 position: 153816 CreateTime: 1590738831657 isvalid: true keysize: -1 valuesize: 51200 magic: 2 compresscodec: NONE producerId: -1 producerEpoch: -1 sequence: -1 isTransactional: false headerKeys: []</span><br><span class="line">offset: 635795 position: 205088 CreateTime: 1590738831657 isvalid: true keysize: -1 valuesize: 51200 magic: 2 compresscodec: NONE producerId: -1 producerEpoch: -1 sequence: -1 isTransactional: false headerKeys: []</span><br><span class="line">offset: 635796 position: 256360 CreateTime: 1590738831657 isvalid: true keysize: -1 valuesize: 51200 magic: 2 compresscodec: NONE producerId: -1 producerEpoch: -1 sequence: -1 isTransactional: false headerKeys: []</span><br><span class="line">offset: 635797 position: 307632 CreateTime: 1590738831657 isvalid: true keysize: -1 valuesize: 51200 magic: 2 compresscodec: NONE producerId: -1 producerEpoch: -1 sequence: -1 isTransactional: false headerKeys: []</span><br><span class="line">offset: 635798 position: 358904 CreateTime: 1590738831657 isvalid: true keysize: -1 valuesize: 51200 magic: 2 compresscodec: NONE producerId: -1 producerEpoch: -1 sequence: -1 isTransactional: false headerKeys: []</span><br><span class="line">offset: 635799 position: 410176 CreateTime: 1590738831657 isvalid: true keysize: -1 valuesize: 51200 magic: 2 compresscodec: NONE producerId: -1 producerEpoch: -1 sequence: -1 isTransactional: false headerKeys: []</span><br><span class="line">offset: 635800 position: 461448 CreateTime: 1590738831658 isvalid: true keysize: -1 valuesize: 51200 magic: 2 compresscodec: NONE producerId: -1 producerEpoch: -1 sequence: -1 isTransactional: false headerKeys: []</span><br><span class="line">offset: 635801 position: 512720 CreateTime: 1590738831660 isvalid: true keysize: -1 valuesize: 51200 magic: 2 compresscodec: NONE producerId: -1 producerEpoch: -1 sequence: -1 isTransactional: false headerKeys: []</span><br><span class="line">offset: 635802 position: 563992 CreateTime: 1590738831660 isvalid: true keysize: -1 valuesize: 51200 magic: 2 compresscodec: NONE producerId: -1 producerEpoch: -1 sequence: -1 isTransactional: false headerKeys: []</span><br><span class="line">offset: 635803 position: 615264 CreateTime: 1590738831661 isvalid: true keysize: -1 valuesize: 51200 magic: 2 compresscodec: NONE producerId: -1 producerEpoch: -1 sequence: -1 isTransactional: false headerKeys: []</span><br><span class="line">offset: 635804 position: 666536 CreateTime: 1590738831661 isvalid: true keysize: -1 valuesize: 51200 magic: 2 compresscodec: NONE producerId: -1 producerEpoch: -1 sequence: -1 isTransactional: false headerKeys: []</span><br><span class="line">offset: 635805 position: 717808 CreateTime: 1590738831661 isvalid: true keysize: -1 valuesize: 51200 magic: 2 compresscodec: NONE producerId: -1 producerEpoch: -1 sequence: -1 isTransactional: false headerKeys: []</span><br><span class="line">offset: 635806 position: 769080 CreateTime: 1590738831662 isvalid: true keysize: -1 valuesize: 51200 magic: 2 compresscodec: NONE producerId: -1 producerEpoch: -1 sequence: -1 isTransactional: false headerKeys: []</span><br><span class="line">offset: 635807 position: 820352 CreateTime: 1590738831662 isvalid: true keysize: -1 valuesize: 51200 magic: 2 compresscodec: NONE producerId: -1 producerEpoch: -1 sequence: -1 isTransactional: false headerKeys: []</span><br><span class="line">offset: 635808 position: 871624 CreateTime: 1590738831663 isvalid: true keysize: -1 valuesize: 51200 magic: 2 compresscodec: NONE producerId: -1 producerEpoch: -1 sequence: -1 isTransactional: false headerKeys: []</span><br><span class="line">offset: 635809 position: 922896 CreateTime: 1590738831663 isvalid: true keysize: -1 valuesize: 51200 magic: 2 compresscodec: NONE producerId: -1 producerEpoch: -1 sequence: -1 isTransactional: false headerKeys: []</span><br><span class="line">offset: 635810 position: 974168 CreateTime: 1590738831663 isvalid: true keysize: -1 valuesize: 51200 magic: 2 compresscodec: NONE producerId: -1 producerEpoch: -1 sequence: -1 isTransactional: false headerKeys: []</span><br><span class="line">offset: 635811 position: 1025440 CreateTime: 1590738831668 isvalid: true keysize: -1 valuesize: 51200 magic: 2 compresscodec: NONE producerId: -1 producerEpoch: -1 sequence: -1 isTransactional: false headerKeys: []</span><br><span class="line">offset: 635812 position: 1076712 CreateTime: 1590738831668 isvalid: true keysize: -1 valuesize: 51200 magic: 2 compresscodec: NONE producerId: -1 producerEpoch: -1 sequence: -1 isTransactional: false headerKeys: []</span><br><span class="line">offset: 635813 position: 1127984 CreateTime: 1590738831668 isvalid: true keysize: -1 valuesize: 51200 magic: 2 compresscodec: NONE producerId: -1 producerEpoch: -1 sequence: -1 isTransactional: false headerKeys: []</span><br></pre></td></tr></table></figure><br><code>--print-data-log</code>用于查看<strong>消息里面的实际数据</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kafka-dump-log --files &#x2F;tmp&#x2F;kafka-logs&#x2F;transaction-0&#x2F;00000000000000000000.log --deep-iteration --print-data-log | head -n 8</span><br><span class="line">Dumping &#x2F;usr&#x2F;local&#x2F;var&#x2F;lib&#x2F;kafka-logs&#x2F;transaction-0&#x2F;00000000000000000000.log</span><br><span class="line">Starting offset: 0</span><br><span class="line">baseOffset: 0 lastOffset: 0 count: 1 baseSequence: -1 lastSequence: -1 producerId: -1 producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false isControl: false position: 0 CreateTime: 1572434815538 size: 79 magic: 2 compresscodec: NONE crc: 234703942 isvalid: true</span><br><span class="line">| offset: 0 CreateTime: 1572434815538 keysize: -1 valuesize: 11 sequence: -1 headerKeys: [] payload: hello world</span><br><span class="line">baseOffset: 1 lastOffset: 1 count: 1 baseSequence: -1 lastSequence: -1 producerId: -1 producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false isControl: false position: 79 CreateTime: 1572434920055 size: 69 magic: 2 compresscodec: NONE crc: 1305542871 isvalid: true</span><br><span class="line">| offset: 1 CreateTime: 1572434920055 keysize: -1 valuesize: 1 sequence: -1 headerKeys: [] payload: w</span><br><span class="line">baseOffset: 2 lastOffset: 16 count: 15 baseSequence: -1 lastSequence: -1 producerId: -1 producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false isControl: false position: 148 CreateTime: 1572435583918 size: 1241 magic: 2 compresscodec: LZ4 crc: 3547131642 isvalid: true</span><br><span class="line">| offset: 2 CreateTime: 1572435583623 keysize: -1 valuesize: 1024 sequence: -1 headerKeys: [] payload: SSXVNJHPDQDXVCRASTVYBCWVMGNYKRXVZXKGXTSPSJDGYLUEGQFLAQLOCFLJBEPOWFNSOMYARHAOPUFOJHHDXEHXJBHWGSMZJGNLONJVXZXZOZITKXJBOZWDJMCBOSYQQKCPRRDCZWMRLFXBLGQPRPGRNTAQOOSVXPKJPJLAVSQCCRXFRROLLHWHOHFGCFWPNDLMWCSSHWXQQYKALAAWCMXYLMZALGDESKKTEESEMPRHROVKUMPSXHELIDQEOOHOIHEGJOAZBVPUMCHSHGXZYXXQRUICRIJGQEBBWAXABQRIRUGZJUUVFYQOVCDEDXYFPRLGSGZXSNIAVODTJKSQWHNWVPSAMZKOUDTWHIORJSCZIQYPCZMBYWKDIKOKYNGWPXZWMKRDCMBXKFUILWDHBFXRFAOPRUGDFLPDLHXXCXCUPLWGDPPHEMJGMTVMFQQFVCUPOFYWLDUEBICKPZKHKVMCJVWVKTXBKAPWAPENUEZNWNWDCACDRLPIPHJQQKMOFDQSPKKNURFBORJLBPCBIWTSJNPRBNITTKJYWAHWGKZYNUSFISPIYPIOGAUPZDXHCFVGXGIVVCPFHIXAACZXZLFDMOOSSNTKUPJQEIRRQAMUCTBLBSVPDDYOIHAOODZNJTVHDCIEGTAVMYZOCIVSKUNSMXEKBEWNZPRPWPUJABJXNQBOXSHOEGMJSNBUTGTIFVEQPSYBDXEXORPQDDODZGBELOISTRWXMEYWVVHGMJKWLJCCHPKAFRASZEYQZCVLFSLOWTLBMPPWPPFPQSAZPTULSTCDMODYKZGSRFQTRFTGCNMNXQQIYVUQZHVNIPHZWVBSGOBYIFDNNXUTBBQUYNXOZCSICGRTZSSRHROJRGBHMHEQJRDLOQBEPTOBMYLMIGPPDPOLTEUVDGATCGYPQOGOYYESKEGBLOCBIYSLQEYGCCIPBXPNSPKDYTBEWDHBHWVDPLOVHJPNYGJUHKKHDASNFGZDAIWWQEPPBRJKDGOSAFAPRLWFFXRVMZQTKRYF</span><br></pre></td></tr></table></figure></p>
<h2 id="查询消费者组位移"><a href="#查询消费者组位移" class="headerlink" title="查询消费者组位移"></a>查询消费者组位移</h2><p><code>CURRENT-OFFSET</code>表示该消费者当前消费的最新位移，<code>LOG-END-OFFSET</code>表示对应分区最新生产消息的位移<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;kafka-consumer-groups.sh --bootstrap-server localhost:9092 --describe --group transaction</span><br></pre></td></tr></table></figure><br>参考：<a href="http://zhongmingmao.me" target="_blank" rel="noopener">http://zhongmingmao.me</a></p>
]]></content>
      <categories>
        <category>Middleware</category>
        <category>MQ</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Middleware</tag>
        <tag>MQ</tag>
        <tag>Kafka</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka -- 动态配置</title>
    <url>/2019/09/25/kafka-dynamic-config/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ol>
<li>Kafka安装目录的config路径下，有<code>server.properties</code>文件<ul>
<li>通常情况下，会指定<code>server.properties</code>来启动Broker</li>
<li>如果要设置Broker端的任何参数，必须要显式修改<code>server.properties</code>，然后重启Broker，让参数生效</li>
<li>但在生产环境，不能随意重启Broker，因此需要能够<strong>动态</strong>修改Broker端参数</li>
</ul>
</li>
<li>社区于<strong>1.1.0</strong>正式引入了<strong>动态Broker参数</strong><ul>
<li>动态指的是修改参数后，无需重启Broker就能立即生效，而之前<code>server.properties</code>中配置的参数称为<strong>静态参数</strong></li>
</ul>
</li>
<li>并非所有Broker端参数都可以动态调整的，官方文档中有<code>Dynamic Update Mode</code>一列<ul>
<li><strong>read-only</strong><ul>
<li>与原来的参数行为一样，只有重启Broker，才能令修改生效</li>
</ul>
</li>
<li><strong>per-broker</strong><ul>
<li><strong>动态参数</strong>，修改之后，只会在<strong>对应的Broker</strong>上生效</li>
</ul>
</li>
<li><strong>cluster-wide</strong><ul>
<li><strong>动态参数</strong>，修改之后，会在<strong>整个集群</strong>范围内生效</li>
</ul>
</li>
</ul>
</li>
</ol>
<a id="more"></a>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>动态调整Broker端各种<strong>线程池大小</strong>，实时应对<strong>突发流量</strong> — 比较常用</li>
<li>动态调整Broker端连接信息或安全配置信息</li>
<li>动态更新SSL KeyStore有效期</li>
<li>动态调整Broker端Compact操作性能</li>
<li>实时变更JMX指标收集器（JMX Metrics Reporter）</li>
</ol>
<h2 id="保存机制"><a href="#保存机制" class="headerlink" title="保存机制"></a>保存机制</h2><p><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-dynamic-config-znode.png" width=1000/></p>
<ol>
<li>Kafka将<strong>动态Broker参数</strong>保存在<strong>ZK</strong>中</li>
<li><code>changes</code>节点用来<strong>实时监测动态参数变更</strong>的，<strong>不会保存参数值</strong></li>
<li><code>topics</code>节点用来保存Kafka<strong>主题级别</strong>参数的</li>
<li><code>users</code>节点和<code>clients</code>节点用来<strong>动态调整客户端配额</strong><ul>
<li>配额：限制连入集群的客户端的<strong>吞吐量</strong>或<strong>使用的CPU资源</strong></li>
</ul>
</li>
<li><code>brokers</code>节点用来保存<strong>动态Broker端参数</strong><ul>
<li><code>&lt;default&gt;</code>节点用来保存<code>cluster-wide</code>范围的动态参数</li>
<li><code>broker_id</code>节点用来保存特定Broker的<code>per-broker</code>范围的动态参数</li>
</ul>
</li>
<li>参数优先级<ul>
<li><em><strong><code>per-broker</code>参数 &gt; <code>cluster-wide</code>参数 &gt; static参数 &gt; Kafka默认值</strong></em></li>
</ul>
</li>
<li>下图中的<strong>ephemeralOwner</strong>字段都是<code>0x0</code>，表示这些znode都是<strong>持久化节点</strong>，即使ZK集群重启，动态参数也不会丢失</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 21] ls &#x2F;config</span><br><span class="line">[changes, clients, brokers, topics, users]</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 22] ls &#x2F;config&#x2F;brokers</span><br><span class="line">[0, &lt;default&gt;]</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 23] get &#x2F;config&#x2F;brokers&#x2F;&lt;default&gt;</span><br><span class="line">&#123;&quot;version&quot;:1,&quot;config&quot;:&#123;&quot;unclean.leader.election.enable&quot;:&quot;true&quot;&#125;&#125;</span><br><span class="line">cZxid &#x3D; 0xe89</span><br><span class="line">ctime &#x3D; Thu Oct 24 09:28:50 CST 2019</span><br><span class="line">mZxid &#x3D; 0xe89</span><br><span class="line">mtime &#x3D; Thu Oct 24 09:28:50 CST 2019</span><br><span class="line">pZxid &#x3D; 0xe89</span><br><span class="line">cversion &#x3D; 0</span><br><span class="line">dataVersion &#x3D; 0</span><br><span class="line">aclVersion &#x3D; 0</span><br><span class="line">ephemeralOwner &#x3D; 0x0</span><br><span class="line">dataLength &#x3D; 64</span><br><span class="line">numChildren &#x3D; 0</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 24] get &#x2F;config&#x2F;brokers&#x2F;0</span><br><span class="line">&#123;&quot;version&quot;:1,&quot;config&quot;:&#123;&quot;leader.replication.throttled.rate&quot;:&quot;104857600&quot;,&quot;follower.replication.throttled.rate&quot;:&quot;104857600&quot;&#125;&#125;</span><br><span class="line">cZxid &#x3D; 0xdef</span><br><span class="line">ctime &#x3D; Mon Oct 21 09:50:13 CST 2019</span><br><span class="line">mZxid &#x3D; 0xe07</span><br><span class="line">mtime &#x3D; Mon Oct 21 10:07:23 CST 2019</span><br><span class="line">pZxid &#x3D; 0xdef</span><br><span class="line">cversion &#x3D; 0</span><br><span class="line">dataVersion &#x3D; 1</span><br><span class="line">aclVersion &#x3D; 0</span><br><span class="line">ephemeralOwner &#x3D; 0x0</span><br><span class="line">dataLength &#x3D; 122</span><br><span class="line">numChildren &#x3D; 0</span><br></pre></td></tr></table></figure>
<h2 id="配置命令"><a href="#配置命令" class="headerlink" title="配置命令"></a>配置命令</h2><h3 id="设置cluster-wide参数"><a href="#设置cluster-wide参数" class="headerlink" title="设置cluster-wide参数"></a>设置cluster-wide参数</h3><p>如果要设置<code>cluster-wide</code>范围的动态参数，需要显式指定<strong><code>entity-default</code></strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bin&#x2F;kafka-configs.sh --bootstrap-server localhost:9092 --entity-type brokers --entity-default --alter --add-config unclean.leader.election.enable&#x3D;true</span><br><span class="line">Completed updating default config for brokers in the cluster,</span><br></pre></td></tr></table></figure><br>查看配置是否成功，<code>sensitive=false</code>表明<strong>要调整的参数不是敏感数据</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bin&#x2F;kafka-configs.sh --bootstrap-server localhost:9092 --entity-type brokers --entity-default --describe</span><br><span class="line">Default config for brokers in the cluster are:</span><br><span class="line">  unclean.leader.election.enable&#x3D;true sensitive&#x3D;false synonyms&#x3D;&#123;DYNAMIC_DEFAULT_BROKER_CONFIG:unclean.leader.election.enable&#x3D;true&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="设置per-broker参数"><a href="#设置per-broker参数" class="headerlink" title="设置per-broker参数"></a>设置per-broker参数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bin&#x2F;kafka-configs.sh --bootstrap-server localhost:9092 --entity-type brokers --entity-name 1 --alter --add-config    unclean.leader.election.enable&#x3D;false,leader.replication.throttled.rate&#x3D;104857600,follower.replication.throttled.rate&#x3D;104857600</span><br><span class="line">Completed updating config for broker: 1.</span><br></pre></td></tr></table></figure>
<p>查看配置是否成功，重点关注<br>实际值：<code>unclean.leader.election.enable=false</code><br>per-broker参数：<code>DYNAMIC_BROKER_CONFIG:unclean.leader.election.enable=false</code><br>cluster-wide参数：<code>DYNAMIC_DEFAULT_BROKER_CONFIG:unclean.leader.election.enable=true</code><br>Kafka默认值：<code>DEFAULT_CONFIG:unclean.leader.election.enable=false</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bin&#x2F;kafka-configs.sh --bootstrap-server localhost:9092 --entity-type brokers --entity-name 1 --describe</span><br><span class="line">Configs for broker 0 are:</span><br><span class="line">  leader.replication.throttled.rate&#x3D;null sensitive&#x3D;true synonyms&#x3D;&#123;DYNAMIC_BROKER_CONFIG:leader.replication.throttled.rate&#x3D;null&#125;</span><br><span class="line">  follower.replication.throttled.rate&#x3D;null sensitive&#x3D;true synonyms&#x3D;&#123;DYNAMIC_BROKER_CONFIG:follower.replication.throttled.rate&#x3D;null&#125;</span><br><span class="line">  unclean.leader.election.enable&#x3D;false sensitive&#x3D;false synonyms&#x3D;&#123;DYNAMIC_BROKER_CONFIG:unclean.leader.election.enable&#x3D;false, DYNAMIC_DEFAULT_BROKER_CONFIG:unclean.leader.election.enable&#x3D;true, DEFAULT_CONFIG:unclean.leader.election.enable&#x3D;false&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="删除cluster-wide参数"><a href="#删除cluster-wide参数" class="headerlink" title="删除cluster-wide参数"></a>删除cluster-wide参数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kafka-configs --bootstrap-server localhost:9092 --entity-type brokers --entity-default --alter --delete-config unclean.leader.election.enable</span><br><span class="line">Completed updating default config for brokers in the cluster,</span><br><span class="line"></span><br><span class="line">$ kafka-configs --bootstrap-server localhost:9092  --entity-type brokers --entity-default --describe</span><br><span class="line">Default config for brokers in the cluster are:</span><br></pre></td></tr></table></figure>
<h3 id="删除per-broker参数"><a href="#删除per-broker参数" class="headerlink" title="删除per-broker参数"></a>删除per-broker参数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kafka-configs --bootstrap-server localhost:9092 --entity-type brokers --entity-name 0 --alter --delete-config unclean.leader.election.enable,leader.replication.throttled.rate,follower.replication.throttled.rate</span><br><span class="line">Completed updating config for broker: 0.</span><br><span class="line"></span><br><span class="line">$ kafka-configs --bootstrap-server localhost:9092  --entity-type brokers --entity-name 0 --describe</span><br><span class="line">Configs for broker 0 are:</span><br></pre></td></tr></table></figure>
<h2 id="常用动态参数"><a href="#常用动态参数" class="headerlink" title="常用动态参数"></a>常用动态参数</h2><ol>
<li>log.retention.ms<ul>
<li>修改<strong>日志留存时间</strong></li>
</ul>
</li>
<li>num.io.threads、num.network.threads<ul>
<li>实现生产环境<strong>动态按需扩容</strong></li>
</ul>
</li>
<li>与SSL相关：ssl.keystore.type、ssl.keystore.location、ssl.keystore.password 和 ssl.key.password<ul>
<li>允许动态实时调整这些参数后，可以创建那些<strong>过期时间很短的SSL证书</strong></li>
<li>每当调整这些参数后，Kafka底层会<strong>重新配置Socket连接通道并更新Keystore</strong></li>
<li>新的连接会使用新的Keystore，<strong>阶段性地调整这些参数，有利于增加安全性</strong></li>
</ul>
</li>
<li>num.replica.fetchers<ul>
<li><strong>提高Follower拉取副本的速度</strong></li>
</ul>
</li>
</ol>
<p>参考：<a href="http://zhongmingmao.me" target="_blank" rel="noopener">http://zhongmingmao.me</a></p>
]]></content>
      <categories>
        <category>Middleware</category>
        <category>MQ</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Middleware</tag>
        <tag>MQ</tag>
        <tag>Kafka</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka -- 主题管理</title>
    <url>/2019/09/23/kafka-topic-management/</url>
    <content><![CDATA[<h2 id="日常管理"><a href="#日常管理" class="headerlink" title="日常管理"></a>日常管理</h2><h3 id="创建主题"><a href="#创建主题" class="headerlink" title="创建主题"></a>创建主题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bin&#x2F;kafka-topics.sh --bootstrap-server localhost:9092 --create --topic t1 --partitions 1 --replication-factor 1</span><br></pre></td></tr></table></figure>
<ol>
<li>从Kafka <strong>2.2</strong>版本开始，推荐使用<code>--bootstrap-server</code>代替<code>--zookeeper</code>（标记为<strong>已过期</strong>）</li>
<li>原因<ul>
<li>使用<code>--zookeeper</code>会绕过Kafka的<strong>安全体系</strong>，不受认证体系的约束</li>
<li>使用<code>--bootstrap-server</code>与集群交互是<strong>未来的趋势</strong></li>
</ul>
</li>
</ol>
<a id="more"></a>
<h3 id="查询主题列表"><a href="#查询主题列表" class="headerlink" title="查询主题列表"></a>查询主题列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bin&#x2F;kafka-topics.sh --bootstrap-server localhost:9092 --list</span><br><span class="line">__consumer_offsets</span><br><span class="line">_schemas</span><br><span class="line">t1</span><br><span class="line">transaction</span><br></pre></td></tr></table></figure>
<h3 id="查询单个主题"><a href="#查询单个主题" class="headerlink" title="查询单个主题"></a>查询单个主题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bin&#x2F;kafka-topics.sh --bootstrap-server localhost:9092 --describe --topic __consumer_offsets</span><br><span class="line">Topic:__consumer_offsets	PartitionCount:50	ReplicationFactor:1	Configs:compression.type&#x3D;producer,cleanup.policy&#x3D;compact,segment.bytes&#x3D;104857600</span><br><span class="line">    Topic: __consumer_offsets	Partition: 0	Leader: 0	Replicas: 0	Isr: 0</span><br><span class="line">    Topic: __consumer_offsets	Partition: 1	Leader: 0	Replicas: 0	Isr: 0</span><br><span class="line">    ...</span><br><span class="line">    Topic: __consumer_offsets	Partition: 48	Leader: 0	Replicas: 0	Isr: 0</span><br><span class="line">    Topic: __consumer_offsets	Partition: 49	Leader: 0	Replicas: 0	Isr: 0</span><br></pre></td></tr></table></figure>
<h3 id="增加主题分区"><a href="#增加主题分区" class="headerlink" title="增加主题分区"></a>增加主题分区</h3><p>Kafka目前<strong>不允许减少某个主题的分区数</strong>，指定的分区数一定要<strong>比原有分区数大</strong>，否则Kafka会抛出InvalidPartitionsException<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bin&#x2F;kafka-topics.sh --bootstrap-server localhost:9092 --alter --topic t1 --partitions 3</span><br><span class="line"></span><br><span class="line">$ bin&#x2F;kafka-topics.sh --bootstrap-server localhost:9092 --describe --topic t1</span><br><span class="line">Topic:t1	PartitionCount:3	ReplicationFactor:1	Configs:segment.bytes&#x3D;1073741824</span><br><span class="line">	Topic: t1	Partition: 0	Leader: 0	Replicas: 0	Isr: 0</span><br><span class="line">	Topic: t1	Partition: 1	Leader: 0	Replicas: 0	Isr: 0</span><br><span class="line">	Topic: t1	Partition: 2	Leader: 0	Replicas: 0	Isr: 0</span><br><span class="line"></span><br><span class="line">$ bin&#x2F;kafka-topics.sh --bootstrap-server localhost:9092 --alter --topic t1 --partitions 2</span><br><span class="line">Error while executing topic command : org.apache.kafka.common.errors.InvalidPartitionsException: Topic currently has 3 partitions, which is higher than the requested 2.</span><br><span class="line">[2019-10-21 09:36:14,368] ERROR java.util.concurrent.ExecutionException: org.apache.kafka.common.errors.InvalidPartitionsException: Topic currently has 3 partitions, which is higher than the requested 2.</span><br><span class="line">	at org.apache.kafka.common.internals.KafkaFutureImpl.wrapAndThrow(KafkaFutureImpl.java:45)</span><br><span class="line">	at org.apache.kafka.common.internals.KafkaFutureImpl.access$000(KafkaFutureImpl.java:32)</span><br><span class="line">	at org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:89)</span><br><span class="line">	at org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:260)</span><br><span class="line">	at kafka.admin.TopicCommand$AdminClientTopicService.alterTopic(TopicCommand.scala:215)</span><br><span class="line">	at kafka.admin.TopicCommand$.main(TopicCommand.scala:62)</span><br><span class="line">	at kafka.admin.TopicCommand.main(TopicCommand.scala)</span><br><span class="line">Caused by: org.apache.kafka.common.errors.InvalidPartitionsException: Topic currently has 3 partitions, which is higher than the requested 2.</span><br><span class="line"> (kafka.admin.TopicCommand$)</span><br></pre></td></tr></table></figure></p>
<h3 id="修改主题级别参数"><a href="#修改主题级别参数" class="headerlink" title="修改主题级别参数"></a>修改主题级别参数</h3><p><code>--bootstrap-server</code>是用来设置<strong>动态参数</strong>的，而<strong>常规的主题级别参数</strong>，还是使用<code>--zookeeper</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ bin/kafka-configs.sh --zookeeper localhost:<span class="number">2181</span> --entity-type topics --entity-name t1 --alter --add-config max.message.bytes=<span class="number">10485760</span></span><br><span class="line">Completed Updating config <span class="keyword">for</span> entity: topic <span class="string">'t1'</span>.</span><br></pre></td></tr></table></figure></p>
<h3 id="变更副本数"><a href="#变更副本数" class="headerlink" title="变更副本数"></a>变更副本数</h3><p>使用<code>kafka-reassign-partitions</code>脚本<strong>增加</strong>主题的副本数，参照下文</p>
<h3 id="修改主题限速"><a href="#修改主题限速" class="headerlink" title="修改主题限速"></a>修改主题限速</h3><p>主要是指设置Leader副本和Follower副本使用的<strong>带宽</strong>，想要让某个主题的副本在执行<strong>副本同步</strong>机制时，不要消耗过多的带宽<br>需要修改Broker端参数<strong><code>leader.replication.throttled.rate</code></strong>和<strong><code>follower.replication.throttled.rate</code></strong><br>如果某主题的副本分别在0、1、2、3多个Broker上，需要依次到Broker0、Broker1、Broker2、Broker3上执行这条命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bin&#x2F;kafka-configs.sh --zookeeper localhost:2181 --entity-type brokers --entity-name 0 --alter --add-config &#39;leader.replication.throttled.rate&#x3D;104857600,follower.replication.throttled.rate&#x3D;104857600&#39;</span><br><span class="line">Completed Updating config for entity: brokers &#39;0&#39;.</span><br></pre></td></tr></table></figure><br>设置完上面两个参数后，需要为该主题设置要限速的副本，通配符<code>*</code>代表<strong>所有副本</strong>都设置限速<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bin&#x2F;kafka-configs.sh --zookeeper localhost:2181 --entity-type topics --entity-name t1 --alter --add-config &#39;leader.replication.throttled.replicas&#x3D;*,follower.replication.throttled.replicas&#x3D;*&#39;</span><br><span class="line">Completed Updating config for entity: topic &#39;t1&#39;.</span><br></pre></td></tr></table></figure></p>
<h3 id="主题分区迁移"><a href="#主题分区迁移" class="headerlink" title="主题分区迁移"></a>主题分区迁移</h3><p>使用<code>kafka-reassign-partitions</code>脚本对<strong>主题各个分区的副本</strong>进行调整，如把某些分区批量迁移到其它Broker上，参照下文</p>
<h3 id="删除主题"><a href="#删除主题" class="headerlink" title="删除主题"></a>删除主题</h3><p>删除操作是<strong>异步</strong>的，执行完命令后，主题仅仅被<strong>标记为已删除</strong>而已，Kafka会在<strong>后台</strong>默默开启主题删除操作<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bin&#x2F;kafka-topics.sh --bootstrap-server localhost:9092 --delete --topic t1</span><br></pre></td></tr></table></figure></p>
<h2 id="位移主题"><a href="#位移主题" class="headerlink" title="位移主题"></a>位移主题</h2><h3 id="副本数量"><a href="#副本数量" class="headerlink" title="副本数量"></a>副本数量</h3><ol>
<li>在Kafka <strong>0.11</strong>之前，当Kafka<strong>自动创建</strong><code>__consumer_offsets</code>时<ul>
<li>会综合考虑<strong>当前运行的Broker台数</strong>和Broker端参数<strong><code>offsets.topic.replication.factor</code></strong>，取两者中的<strong>较小值</strong></li>
<li>这违背了用户设置<code>offsets.topic.replication.factor</code>的初衷</li>
</ul>
</li>
<li>在Kafka <strong>0.11</strong>之后，Kafka会<strong>严格遵守</strong><code>offsets.topic.replication.factor</code>的值<ul>
<li>如果当前运行的Broker数量小于<code>offsets.topic.replication.factor</code>，Kafka会<strong>创建位移主题失败</strong>，并抛出异常</li>
</ul>
</li>
<li>如果<code>__consumer_offsets</code>的副本值为1，可以<strong>增加</strong>到3</li>
</ol>
<p>reassign.json — 副本的配置<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"version"</span>:<span class="number">1</span>, <span class="attr">"partitions"</span>:[</span><br><span class="line">    &#123;<span class="attr">"topic"</span>:<span class="string">"__consumer_offsets"</span>,<span class="attr">"partition"</span>:<span class="number">0</span>,<span class="attr">"replicas"</span>:[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]&#125;, </span><br><span class="line">    &#123;<span class="attr">"topic"</span>:<span class="string">"__consumer_offsets"</span>,<span class="attr">"partition"</span>:<span class="number">1</span>,<span class="attr">"replicas"</span>:[<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>]&#125;,</span><br><span class="line">    &#123;<span class="attr">"topic"</span>:<span class="string">"__consumer_offsets"</span>,<span class="attr">"partition"</span>:<span class="number">2</span>,<span class="attr">"replicas"</span>:[<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>]&#125;,</span><br><span class="line">    ...</span><br><span class="line">    &#123;<span class="attr">"topic"</span>:<span class="string">"__consumer_offsets"</span>,<span class="attr">"partition"</span>:<span class="number">49</span>,<span class="attr">"replicas"</span>:[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]&#125;</span><br><span class="line">]&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bin&#x2F;kafka-reassign-partitions.sh --zookeeper localhost:2181 --reassignment-json-file reassign.json --execute</span><br><span class="line">Current partition replica assignment</span><br><span class="line"></span><br><span class="line">&#123;&quot;version&quot;:1,&quot;partitions&quot;:[&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:22,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:30,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:8,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:21,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:4,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:27,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:7,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:9,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:46,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:25,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:35,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:41,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:33,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:23,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:49,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:47,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:16,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:28,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:31,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:36,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:42,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:3,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:18,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:37,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:15,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:24,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:38,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:17,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:48,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:19,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:11,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:13,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:43,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:6,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:14,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:20,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:44,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:39,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:12,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:45,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:5,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:26,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:29,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:34,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:10,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:32,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;__consumer_offsets&quot;,&quot;partition&quot;:40,&quot;replicas&quot;:[0],&quot;log_dirs&quot;:[&quot;any&quot;]&#125;]&#125;</span><br><span class="line"></span><br><span class="line">Save this to use as the --reassignment-json-file option during rollback</span><br><span class="line">Successfully started reassignment of partitions.</span><br></pre></td></tr></table></figure></p>
<h3 id="查看消费者组提交的位移数据"><a href="#查看消费者组提交的位移数据" class="headerlink" title="查看消费者组提交的位移数据"></a>查看消费者组提交的位移数据</h3><p><strong>OffsetsMessageFormatter</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bin&#x2F;kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic __consumer_offsets --formatter &quot;kafka.coordinator.group.GroupMetadataManager\$OffsetsMessageFormatter&quot; --from-beginning</span><br><span class="line">[console-consumer-40652,test,0]::OffsetAndMetadata(offset&#x3D;2, leaderEpoch&#x3D;Optional.empty, metadata&#x3D;, commitTimestamp&#x3D;1538842068384, expireTimestamp&#x3D;Some(1539446868384))</span><br><span class="line">[console-consumer-6657,test,0]::NULL</span><br><span class="line">[console-consumer-66385,zhongmingmao,0]::OffsetAndMetadata(offset&#x3D;5, leaderEpoch&#x3D;Optional.empty, metadata&#x3D;, commitTimestamp&#x3D;1538999538770, expireTimestamp&#x3D;Some(1539604338770))</span><br><span class="line">[console-consumer-41615,test,0]::NULL</span><br><span class="line">[zhongmingmao,zhongmingmao1,0]::NULL</span><br><span class="line">[stock,stock,0]::NULL</span><br><span class="line">[zhongmingmao,zhongmingmao,1]::OffsetAndMetadata(offset&#x3D;5, leaderEpoch&#x3D;Optional.empty, metadata&#x3D;, commitTimestamp&#x3D;1570536122165, expireTimestamp&#x3D;None)</span><br><span class="line">[zhongmingmao,zhongmingmao,0]::OffsetAndMetadata(offset&#x3D;5, leaderEpoch&#x3D;Optional.empty, metadata&#x3D;, commitTimestamp&#x3D;1570536122165, expireTimestamp&#x3D;None)</span><br><span class="line">[zhongmingmao,zhongmingmao,4]::OffsetAndMetadata(offset&#x3D;6, leaderEpoch&#x3D;Optional.empty, metadata&#x3D;, commitTimestamp&#x3D;1570536122165, expireTimestamp&#x3D;None)</span><br><span class="line">[zhongmingmao,zhongmingmao,3]::OffsetAndMetadata(offset&#x3D;6, leaderEpoch&#x3D;Optional.empty, metadata&#x3D;, commitTimestamp&#x3D;1570536122165, expireTimestamp&#x3D;None)</span><br><span class="line">[zhongmingmao,zhongmingmao,2]::OffsetAndMetadata(offset&#x3D;6, leaderEpoch&#x3D;Optional.empty, metadata&#x3D;, commitTimestamp&#x3D;1570536122165, expireTimestamp&#x3D;None)</span><br><span class="line">[console-consumer-29492,test,0]::OffsetAndMetadata(offset&#x3D;5, leaderEpoch&#x3D;Optional.empty, metadata&#x3D;, commitTimestamp&#x3D;1539220886461, expireTimestamp&#x3D;Some(1539825686461))</span><br><span class="line">[console-consumer-88677,test,0]::OffsetAndMetadata(offset&#x3D;10, leaderEpoch&#x3D;Optional.empty, metadata&#x3D;, commitTimestamp&#x3D;1539222370827, expireTimestamp&#x3D;Some(1539827170827))</span><br><span class="line">[bijection,bijection,0]::OffsetAndMetadata(offset&#x3D;20, leaderEpoch&#x3D;Optional.empty, metadata&#x3D;, commitTimestamp&#x3D;1553425113337, expireTimestamp&#x3D;None)</span><br><span class="line">[console-consumer-60394,zhongmingmao,0]::OffsetAndMetadata(offset&#x3D;3, leaderEpoch&#x3D;Optional.empty, metadata&#x3D;, commitTimestamp&#x3D;1538880245612, expireTimestamp&#x3D;Some(1539485045612))</span><br><span class="line">[console-consumer-40652,test,0]::NULL</span><br><span class="line">[console-consumer-29492,test,0]::NULL</span><br><span class="line">[console-consumer-88677,test,0]::NULL</span><br><span class="line">[bijection,bijection,0]::NULL</span><br><span class="line">[console-consumer-66385,zhongmingmao,0]::NULL</span><br><span class="line">[console-consumer-60394,zhongmingmao,0]::NULL</span><br><span class="line">[zhongmingmao,zhongmingmao,1]::NULL</span><br><span class="line">[zhongmingmao,zhongmingmao,0]::NULL</span><br><span class="line">[zhongmingmao,zhongmingmao,4]::NULL</span><br><span class="line">[zhongmingmao,zhongmingmao,3]::NULL</span><br><span class="line">[zhongmingmao,zhongmingmao,2]::NULL</span><br></pre></td></tr></table></figure></p>
<h3 id="读取位移主题消息，查看消费者组的状态信息"><a href="#读取位移主题消息，查看消费者组的状态信息" class="headerlink" title="读取位移主题消息，查看消费者组的状态信息"></a>读取位移主题消息，查看消费者组的状态信息</h3><p><strong>GroupMetadataMessageFormatter</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bin&#x2F;kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic __consumer_offsets --formatter &quot;kafka.coordinator.group.GroupMetadataManager\$GroupMetadataMessageFormatter&quot; --from-beginning</span><br><span class="line">console-consumer-40652::GroupMetadata(groupId&#x3D;console-consumer-40652, generation&#x3D;2, protocolType&#x3D;Some(consumer), currentState&#x3D;Empty, members&#x3D;Map())</span><br><span class="line">console-consumer-18364::GroupMetadata(groupId&#x3D;console-consumer-18364, generation&#x3D;1, protocolType&#x3D;Some(consumer), currentState&#x3D;Stable, members&#x3D;Map(consumer-1-6aa558f4-7166-457e-9006-39a5843aa976 -&gt; MemberMetadata(memberId&#x3D;consumer-1-6aa558f4-7166-457e-9006-39a5843aa976, groupInstanceId&#x3D;Some(null), clientId&#x3D;consumer-1, clientHost&#x3D;&#x2F;127.0.0.1, sessionTimeoutMs&#x3D;10000, rebalanceTimeoutMs&#x3D;300000, supportedProtocols&#x3D;List(range), )))</span><br><span class="line">console-consumer-18364::GroupMetadata(groupId&#x3D;console-consumer-18364, generation&#x3D;2, protocolType&#x3D;Some(consumer), currentState&#x3D;Empty, members&#x3D;Map())</span><br><span class="line">console-consumer-6657::NULL</span><br><span class="line">console-consumer-20884::NULL</span><br><span class="line">console-consumer-60618::GroupMetadata(groupId&#x3D;console-consumer-60618, generation&#x3D;1, protocolType&#x3D;Some(consumer), currentState&#x3D;Stable, members&#x3D;Map(consumer-1-da910be4-7520-4187-bb58-f1c060c48749 -&gt; MemberMetadata(memberId&#x3D;consumer-1-da910be4-7520-4187-bb58-f1c060c48749, groupInstanceId&#x3D;Some(null), clientId&#x3D;consumer-1, clientHost&#x3D;&#x2F;127.0.0.1, sessionTimeoutMs&#x3D;10000, rebalanceTimeoutMs&#x3D;300000, supportedProtocols&#x3D;List(range), )))</span><br><span class="line">console-consumer-60618::GroupMetadata(groupId&#x3D;console-consumer-60618, generation&#x3D;2, protocolType&#x3D;Some(consumer), currentState&#x3D;Empty, members&#x3D;Map())</span><br><span class="line">console-consumer-46196::GroupMetadata(groupId&#x3D;console-consumer-46196, generation&#x3D;1, protocolType&#x3D;Some(consumer), currentState&#x3D;Stable, members&#x3D;Map(consumer-1-4091fa6c-3326-4e2c-b860-fe94350c9433 -&gt; MemberMetadata(memberId&#x3D;consumer-1-4091fa6c-3326-4e2c-b860-fe94350c9433, groupInstanceId&#x3D;None, clientId&#x3D;consumer-1, clientHost&#x3D;&#x2F;192.168.11.195, sessionTimeoutMs&#x3D;10000, rebalanceTimeoutMs&#x3D;300000, supportedProtocols&#x3D;List(range), )))</span><br><span class="line">console-consumer-46196::GroupMetadata(groupId&#x3D;console-consumer-46196, generation&#x3D;2, protocolType&#x3D;Some(consumer), currentState&#x3D;Empty, members&#x3D;Map())</span><br><span class="line">console-consumer-46196::NULL</span><br><span class="line">console-consumer-66385::GroupMetadata(groupId&#x3D;console-consumer-66385, generation&#x3D;2, protocolType&#x3D;Some(consumer), currentState&#x3D;Empty, members&#x3D;Map())</span><br><span class="line">console-consumer-41615::NULL</span><br><span class="line">stock::NULL</span><br><span class="line">zhongmingmao::GroupMetadata(groupId&#x3D;zhongmingmao, generation&#x3D;11, protocolType&#x3D;Some(consumer), currentState&#x3D;Empty, members&#x3D;Map())</span><br><span class="line">console-consumer-82389::GroupMetadata(groupId&#x3D;console-consumer-82389, generation&#x3D;1, protocolType&#x3D;Some(consumer), currentState&#x3D;Stable, members&#x3D;Map(consumer-1-354b4b29-df13-456c-80c5-6701e8900828 -&gt; MemberMetadata(memberId&#x3D;consumer-1-354b4b29-df13-456c-80c5-6701e8900828, groupInstanceId&#x3D;Some(null), clientId&#x3D;consumer-1, clientHost&#x3D;&#x2F;192.168.2.1, sessionTimeoutMs&#x3D;10000, rebalanceTimeoutMs&#x3D;300000, supportedProtocols&#x3D;List(range), )))</span><br><span class="line">console-consumer-82389::GroupMetadata(groupId&#x3D;console-consumer-82389, generation&#x3D;2, protocolType&#x3D;Some(consumer), currentState&#x3D;Empty, members&#x3D;Map())</span><br><span class="line">console-consumer-82389::NULL</span><br><span class="line">console-consumer-37711::GroupMetadata(groupId&#x3D;console-consumer-37711, generation&#x3D;1, protocolType&#x3D;Some(consumer), currentState&#x3D;Stable, members&#x3D;Map(consumer-1-b8bc1ccd-5388-4f07-bfcf-0a416c143572 -&gt; MemberMetadata(memberId&#x3D;consumer-1-b8bc1ccd-5388-4f07-bfcf-0a416c143572, groupInstanceId&#x3D;Some(null), clientId&#x3D;consumer-1, clientHost&#x3D;&#x2F;127.0.0.1, sessionTimeoutMs&#x3D;10000, rebalanceTimeoutMs&#x3D;300000, supportedProtocols&#x3D;List(range), )))</span><br><span class="line">console-consumer-37711::GroupMetadata(groupId&#x3D;console-consumer-37711, generation&#x3D;2, protocolType&#x3D;Some(consumer), currentState&#x3D;Empty, members&#x3D;Map())</span><br><span class="line">console-consumer-29492::GroupMetadata(groupId&#x3D;console-consumer-29492, generation&#x3D;2, protocolType&#x3D;Some(consumer), currentState&#x3D;Empty, members&#x3D;Map())</span><br><span class="line">console-consumer-88677::GroupMetadata(groupId&#x3D;console-consumer-88677, generation&#x3D;2, protocolType&#x3D;Some(consumer), currentState&#x3D;Empty, members&#x3D;Map())</span><br><span class="line">console-consumer-3420::GroupMetadata(groupId&#x3D;console-consumer-3420, generation&#x3D;1, protocolType&#x3D;Some(consumer), currentState&#x3D;Stable, members&#x3D;Map(consumer-1-7e402ca2-5b9f-49a0-83e3-262443f148ca -&gt; MemberMetadata(memberId&#x3D;consumer-1-7e402ca2-5b9f-49a0-83e3-262443f148ca, groupInstanceId&#x3D;Some(null), clientId&#x3D;consumer-1, clientHost&#x3D;&#x2F;127.0.0.1, sessionTimeoutMs&#x3D;10000, rebalanceTimeoutMs&#x3D;300000, supportedProtocols&#x3D;List(range), )))</span><br><span class="line">console-consumer-3420::GroupMetadata(groupId&#x3D;console-consumer-3420, generation&#x3D;2, protocolType&#x3D;Some(consumer), currentState&#x3D;Empty, members&#x3D;Map())</span><br><span class="line">bijection::GroupMetadata(groupId&#x3D;bijection, generation&#x3D;2, protocolType&#x3D;Some(consumer), currentState&#x3D;Empty, members&#x3D;Map())</span><br><span class="line">console-consumer-37719::NULL</span><br><span class="line">console-consumer-56242::NULL</span><br><span class="line">console-consumer-51162::GroupMetadata(groupId&#x3D;console-consumer-51162, generation&#x3D;1, protocolType&#x3D;Some(consumer), currentState&#x3D;Stable, members&#x3D;Map(consumer-1-0ae0c268-a22a-425b-be55-30393a02c0ad -&gt; MemberMetadata(memberId&#x3D;consumer-1-0ae0c268-a22a-425b-be55-30393a02c0ad, groupInstanceId&#x3D;Some(null), clientId&#x3D;consumer-1, clientHost&#x3D;&#x2F;192.168.2.1, sessionTimeoutMs&#x3D;10000, rebalanceTimeoutMs&#x3D;300000, supportedProtocols&#x3D;List(range), )))</span><br><span class="line">console-consumer-51162::GroupMetadata(groupId&#x3D;console-consumer-51162, generation&#x3D;2, protocolType&#x3D;Some(consumer), currentState&#x3D;Empty, members&#x3D;Map())</span><br><span class="line">console-consumer-51162::NULL</span><br><span class="line">console-consumer-60394::GroupMetadata(groupId&#x3D;console-consumer-60394, generation&#x3D;2, protocolType&#x3D;Some(consumer), currentState&#x3D;Empty, members&#x3D;Map())</span><br><span class="line">console-consumer-40652::NULL</span><br><span class="line">console-consumer-29492::NULL</span><br><span class="line">console-consumer-88677::NULL</span><br><span class="line">bijection::NULL</span><br><span class="line">console-consumer-85955::GroupMetadata(groupId&#x3D;console-consumer-85955, generation&#x3D;1, protocolType&#x3D;Some(consumer), currentState&#x3D;Stable, members&#x3D;Map(consumer-1-a127b884-0a3a-4fe0-a1ea-8bbee57c668a -&gt; MemberMetadata(memberId&#x3D;consumer-1-a127b884-0a3a-4fe0-a1ea-8bbee57c668a, groupInstanceId&#x3D;Some(null), clientId&#x3D;consumer-1, clientHost&#x3D;&#x2F;127.0.0.1, sessionTimeoutMs&#x3D;10000, rebalanceTimeoutMs&#x3D;300000, supportedProtocols&#x3D;List(range), )))</span><br><span class="line">console-consumer-85955::GroupMetadata(groupId&#x3D;console-consumer-85955, generation&#x3D;2, protocolType&#x3D;Some(consumer), currentState&#x3D;Empty, members&#x3D;Map())</span><br><span class="line">console-consumer-85955::NULL</span><br><span class="line">console-consumer-54404::GroupMetadata(groupId&#x3D;console-consumer-54404, generation&#x3D;1, protocolType&#x3D;Some(consumer), currentState&#x3D;Stable, members&#x3D;Map(consumer-1-5edfac05-7f42-4e4c-b906-b8e26149d527 -&gt; MemberMetadata(memberId&#x3D;consumer-1-5edfac05-7f42-4e4c-b906-b8e26149d527, groupInstanceId&#x3D;Some(null), clientId&#x3D;consumer-1, clientHost&#x3D;&#x2F;127.0.0.1, sessionTimeoutMs&#x3D;10000, rebalanceTimeoutMs&#x3D;300000, supportedProtocols&#x3D;List(range), )))</span><br><span class="line">console-consumer-54404::GroupMetadata(groupId&#x3D;console-consumer-54404, generation&#x3D;2, protocolType&#x3D;Some(consumer), currentState&#x3D;Empty, members&#x3D;Map())</span><br><span class="line">console-consumer-6483::GroupMetadata(groupId&#x3D;console-consumer-6483, generation&#x3D;1, protocolType&#x3D;Some(consumer), currentState&#x3D;Stable, members&#x3D;Map(consumer-1-bfa8f79d-03db-43c5-b9bb-a168849e162e -&gt; MemberMetadata(memberId&#x3D;consumer-1-bfa8f79d-03db-43c5-b9bb-a168849e162e, groupInstanceId&#x3D;Some(null), clientId&#x3D;consumer-1, clientHost&#x3D;&#x2F;127.0.0.1, sessionTimeoutMs&#x3D;10000, rebalanceTimeoutMs&#x3D;300000, supportedProtocols&#x3D;List(range), )))</span><br><span class="line">console-consumer-6483::GroupMetadata(groupId&#x3D;console-consumer-6483, generation&#x3D;2, protocolType&#x3D;Some(consumer), currentState&#x3D;Empty, members&#x3D;Map())</span><br><span class="line">console-consumer-6483::NULL</span><br><span class="line">console-consumer-66385::NULL</span><br><span class="line">console-consumer-60394::NULL</span><br><span class="line">zhongmingmao::NULL</span><br><span class="line">console-consumer-49544::GroupMetadata(groupId&#x3D;console-consumer-49544, generation&#x3D;1, protocolType&#x3D;Some(consumer), currentState&#x3D;Stable, members&#x3D;Map(consumer-1-5629e772-0ef1-4248-b9ed-42f997f54a4a -&gt; MemberMetadata(memberId&#x3D;consumer-1-5629e772-0ef1-4248-b9ed-42f997f54a4a, groupInstanceId&#x3D;Some(null), clientId&#x3D;consumer-1, clientHost&#x3D;&#x2F;127.0.0.1, sessionTimeoutMs&#x3D;10000, rebalanceTimeoutMs&#x3D;300000, supportedProtocols&#x3D;List(range), )))</span><br></pre></td></tr></table></figure></p>
<h3 id="常见主题错误处理"><a href="#常见主题错误处理" class="headerlink" title="常见主题错误处理"></a>常见主题错误处理</h3><h4 id="常见错误-1：主题删除失败。"><a href="#常见错误-1：主题删除失败。" class="headerlink" title="常见错误 1：主题删除失败。"></a>常见错误 1：主题删除失败。</h4><p>删除命令后，很多人发现已删除主题的分区数据依然“躺在”硬盘上，没有被清除。这时该怎么办呢?</p>
<h6 id="最常见的原因有两个："><a href="#最常见的原因有两个：" class="headerlink" title="最常见的原因有两个："></a>最常见的原因有两个：</h6><ul>
<li><p>副本所在的 Broker 宕机了；</p>
<ul>
<li>重启对应的 Broker 之后，删除操作就能自动恢复</li>
</ul>
</li>
<li><p>待删除主题的部分分区依然在执行迁移过程</p>
<ul>
<li><ol>
<li>手动删除 ZooKeeper 节点 /admin/delete_topics 下以待删除主题为名的 znode</li>
</ol>
</li>
<li><ol>
<li>手动删除该主题在磁盘上的分区目录</li>
</ol>
</li>
<li><ol>
<li><p>在 ZooKeeper 中执行 rmr /controller，触发 Controller 重选举，刷新 Controller 缓存</p>
<blockquote>
<p>注意：第三步骤，可能造成大面积的分区 Leader 重选举。事实上，仅仅执行前两步也是可以的，只是 Controller 缓存中没有清空待删除主题罢了，也不影响使用</p>
</blockquote>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="常见错误-2：-consumer-offsets-占用太多的磁盘。"><a href="#常见错误-2：-consumer-offsets-占用太多的磁盘。" class="headerlink" title="常见错误 2：__consumer_offsets 占用太多的磁盘。"></a>常见错误 2：__consumer_offsets 占用太多的磁盘。</h4><p>用<code>jstack</code>命令查看一下 <code>kafka-log-cleaner-thread</code> 前缀的线程状态,如果是该线程挂掉了，无法及时清理此内部主题，只能重启对应的    Broker</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>为什么 Kafka 不允许减少分区数？如果减少分区数，可能会有什么样的问题？</p>
<blockquote>
<p>多个broker节点都冗余有分区的数据，减少分区数需要操作多个broker且需要迁移该分区数据到其他分区。如果是按消息key hash选的分区，那么迁移就不知道迁到哪里了，因为只有业务代码可以决定放在哪</p>
</blockquote>
<p>参考：<a href="http://zhongmingmao.me" target="_blank" rel="noopener">http://zhongmingmao.me</a></p>
]]></content>
      <categories>
        <category>Middleware</category>
        <category>MQ</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Middleware</tag>
        <tag>MQ</tag>
        <tag>Kafka</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka -- 线上部署</title>
    <url>/2019/07/15/kafka-%E7%BA%BF%E4%B8%8A%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>Linux的表现更胜一筹：<strong>IO模型的使用</strong>、<strong>网络传输效率</strong>、<strong>社区支持度</strong></p>
<h3 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h3><ol>
<li>主流的IO模型：阻塞式IO、非阻塞式IO、IO多路复用、信号驱动IO、异步IO，后一种模型比前一种<strong>高级</strong><ul>
<li>Java中的Socket对象的阻塞模式和非阻塞模式，对应阻塞式IO和非阻塞式IO</li>
<li>Linux中的系统调用<strong>select</strong>函数属于<strong>IO多路复用</strong>模型</li>
<li>大名鼎鼎的<strong>epoll</strong>系统调用则介于第三种模型和第四种模型之间</li>
<li>很少有Linux系统支持异步IO，Windows系统提供的IOCP线程模型属于异步IO</li>
</ul>
</li>
<li>Kafka客户端底层使用了Java的<strong>selector</strong>，selector在<strong>Linux</strong>上的实现机制是<strong>epoll</strong>，在<strong>Windows</strong>上是<strong>select</strong><ul>
<li>Kafka部署在Linux上，能够获得<strong>更高效的IO性能</strong></li>
</ul>
</li>
</ol>
<a id="more"></a>
<h3 id="网络传输效率"><a href="#网络传输效率" class="headerlink" title="网络传输效率"></a>网络传输效率</h3><ol>
<li>Kafka生产和消费的消息都是通过网络传输的，而消息是保存在磁盘上的<ul>
<li>因此Kafka需要在<strong>磁盘</strong>和<strong>网络</strong>间进行<strong>大量的数据传输</strong></li>
</ul>
</li>
<li>Linux支持<strong>零拷贝</strong>技术<ul>
<li>当数据在<strong>磁盘</strong>和<strong>网络</strong>进行传输时，<strong>避免昂贵的内核态数据拷贝</strong>，从而实现快速的数据传输</li>
<li>在Windows平台必须等待Java 8 Update 60才能享受到类似Linux零拷贝的福利，而Linux早就支持</li>
</ul>
</li>
</ol>
<h3 id="社区支持度"><a href="#社区支持度" class="headerlink" title="社区支持度"></a>社区支持度</h3><ol>
<li>社区目前对在Windows平台上发现的Bug<strong>不做任何承诺</strong></li>
<li>WIndows平台上部署Kafka只适用于个人测试或用于功能验证，不能应用于生产环境</li>
</ol>
<h2 id="磁盘类型"><a href="#磁盘类型" class="headerlink" title="磁盘类型"></a>磁盘类型</h2><ol>
<li>Kafka大量使用磁盘，但使用的方式多为<strong>顺序读写</strong>操作，一定程度上规避了机械硬盘的最大劣势，<strong>随机IO</strong><ul>
<li>所以SSD并没有太大的性能优势，而且机械硬盘物美价廉</li>
</ul>
</li>
<li>机械硬盘易损坏而造成的<strong>可靠性差</strong>等缺陷，又由Kafka在<strong>软件层面</strong>提供机制来保证，故使用机械硬盘<strong>性价比</strong>很高</li>
<li>RAID的主要优势：提供<strong>冗余的磁盘存储空间</strong>、提供<strong>负载均衡</strong><ul>
<li>Kafka自身实现了<strong>冗余机制</strong>（副本）来提供<strong>高可靠性</strong></li>
<li>Kafka通过<strong>分区</strong>的概念，在<strong>软件层面</strong>实现了<strong>负载均衡</strong></li>
</ul>
</li>
<li>小结<ul>
<li>如果追求性价比，可以不搭建RAID，使用普通磁盘组成存储空间即可</li>
<li>使用机械硬盘完全能胜任Kafka线上环境</li>
</ul>
</li>
</ol>
<h2 id="磁盘容量"><a href="#磁盘容量" class="headerlink" title="磁盘容量"></a>磁盘容量</h2><ol>
<li>场景：每天需要向Kafka集群发送<strong>一亿</strong>条消息，每条消息保存<strong>两份</strong>，默认保存<strong>两周</strong>，消息平均大小为<strong>1KB</strong></li>
<li>100,000,000 <em> 1KB </em> 2 / 1000 / 1000 = 200GB</li>
<li>一般情况下，Kafka集群除了<strong>消息数据</strong>还有其他类型的数据，比如<strong>索引数据</strong>，为这些数据预留10%的磁盘空间，220GB</li>
<li>保存两周，220GB * 14 ≈ 3TB</li>
<li>Kafka支持<strong>数据压缩</strong>，假设压缩比为0.75，3TB * 0.75 = 2.25TB</li>
<li>预留20%的磁盘空间，2.25TB / 0.8 ≈ 2.bTB</li>
<li>考虑的因素<ul>
<li><strong>新增消息数</strong></li>
<li><strong>消息留存时间</strong></li>
<li><strong>平均消息大小</strong></li>
<li><strong>备份数</strong></li>
<li><strong>是否启动压缩</strong></li>
</ul>
</li>
</ol>
<h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><ol>
<li>常见带宽：<strong>1Gbps</strong>（千兆网络，常见配置）、<strong>10Gbps</strong>（万兆网络）</li>
<li>场景：机房环境为<strong>1Gbps</strong>，某个业务的SLA是<strong>一个小时</strong>内处理<strong>1TB</strong>的业务数据</li>
<li>假设每台Kafka服务都部署在专属的机器上，Kafka最多会用到机器上70%的带宽资源（超过70%，可能会<strong>网络丢包</strong>）<ul>
<li>即单台Kafka服务器<strong>最多</strong>能使用700Mbps的带宽资源</li>
</ul>
</li>
<li>通常情况下，需要额外预留2/3的资源，即单台服务器使用带宽为700Mbps / 3 ≈ 240Mbps</li>
<li>需要的服务器数量：1TB / 3600s / 240Mbps ≈ 10，如果备份数量为3，那需要的服务器数量为30</li>
</ol>
<h3 id="转载：-http-zhongmingmao-me-2019-07-15-kafka-deploy-online"><a href="#转载：-http-zhongmingmao-me-2019-07-15-kafka-deploy-online" class="headerlink" title="转载： http://zhongmingmao.me/2019/07/15/kafka-deploy-online/"></a>转载： <a href="http://zhongmingmao.me/2019/07/15/kafka-deploy-online/" target="_blank" rel="noopener">http://zhongmingmao.me/2019/07/15/kafka-deploy-online/</a></h3><!-- indicate-the-source -->]]></content>
      <categories>
        <category>Middleware</category>
        <category>MQ</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Middleware</tag>
        <tag>MQ</tag>
        <tag>Kafka</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka -- 调优</title>
    <url>/2019/09/30/kafka-tuning/</url>
    <content><![CDATA[<h2 id="调优目标"><a href="#调优目标" class="headerlink" title="调优目标"></a>调优目标</h2><ol>
<li>主要目标：<strong>高吞吐量</strong>、<strong>低延时</strong></li>
<li><strong>吞吐量</strong><ul>
<li>即<strong>TPS</strong>，指的是Broker端进程或Client端应用程序每秒能处理的<strong>字节数</strong>或<strong>消息数</strong></li>
</ul>
</li>
<li><strong>延时</strong>，可以有两种理解<ul>
<li>从<strong>Producer发送消息</strong>到<strong>Broker持久化</strong>完成之间的时间间隔</li>
<li><strong>端到端的延时</strong>，即从<strong>Producer发送消息</strong>到<strong>Consumer成功消费该消息</strong>的总时长</li>
</ul>
</li>
</ol>
<a id="more"></a>
<h2 id="优化漏斗"><a href="#优化漏斗" class="headerlink" title="优化漏斗"></a>优化漏斗</h2><p>优化漏斗是调优过程中的分层漏斗，层级越靠上，调优的效果越明显<br><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-tuning-funnel.png" width=800/></p>
<h3 id="操作系统层"><a href="#操作系统层" class="headerlink" title="操作系统层"></a>操作系统层</h3><ol>
<li><code>mount -o noatime</code><ul>
<li>在<strong>挂载</strong>文件系统时禁用<strong>atime</strong>（Access Time）更新，记录的是<strong>文件最后被访问的时间</strong></li>
<li>记录<strong>atime</strong>需要操作系统访问<strong>inode</strong>资源，禁用atime可以<strong>避免inode访问时间的写入操作</strong></li>
</ul>
</li>
<li>文件系统选择<strong>ext4</strong>、<strong>XFS</strong>（最优）、<strong>ZFS</strong></li>
<li>将<strong>swappiness</strong>设置成一个<strong>很小的值</strong>（1~10，默认是60），防止Linux的<code>OOM Killer</code>开启<strong>随机杀掉</strong>进程<ul>
<li><strong>swappiness=0</strong>，并不会禁止对swap的使用，只是<strong>最大限度</strong>地降低使用swap的可能性<ul>
<li>因为一旦设置为0，当物理内存耗尽时，操作系统会触发<strong>OOM Killer</strong></li>
<li>OOM Killer会<strong>随机</strong>挑选一个进程然后kill掉，<strong>不会给出任何预警</strong></li>
</ul>
</li>
<li>swappiness=N，表示内存使用<strong><code>(100-N)%</code></strong>时，开始使用Swap</li>
</ul>
</li>
<li><code>ulimit -n</code>设置大一点，否则可能会出现<strong>Too Many File Open</strong>错误</li>
<li><code>vm.max_map_count</code>也设置大一点（如655360，默认值65530）<ul>
<li>在一个主题数超多的机器上，可能会碰到<strong>OutOfMemoryError：Map failed</strong>错误</li>
</ul>
</li>
<li><strong>页缓存大小</strong><ul>
<li>给Kafka预留的页缓存至少也要容纳一个<strong>日志段</strong>的大小（<code>log.segment.bytes</code>，默认值为<strong>1GB</strong>）</li>
<li>消费者程序在<strong>消费</strong>时能<strong>直接命中</strong>页缓存，从而避免<strong>昂贵的物理磁盘IO操作</strong></li>
</ul>
</li>
</ol>
<h3 id="JVM层"><a href="#JVM层" class="headerlink" title="JVM层"></a>JVM层</h3><ol>
<li>堆大小，经验值为<strong>6~8GB</strong><ul>
<li>如果需要精确调整，关注<strong>Full GC后堆上存活对象的总大小</strong>，然后将堆大小设置为该值的<strong>1.5~2倍</strong></li>
<li><code>jmap -histo:live &lt;pid&gt;</code>可以人为触发Full GC</li>
</ul>
</li>
<li>选择垃圾收集器<ul>
<li>推荐使用<strong>G1</strong>，主要原因是<strong>优化难度比CMS小</strong></li>
<li>如果使用G1后，频繁Full GC，配置<code>-XX:+PrintAdaptiveSizePolicy</code>，查看触发Full GC的原因</li>
<li>使用G1的另一个问题是<strong>大对象</strong>，即<code>too many humongous allocations</code><ul>
<li>大对象一般指的是<strong>至少占用半个Region大小的对象</strong>，大对象会被直接分配在<strong>大对象区</strong></li>
<li>可以适当增大<code>-XX:+G1HeapRegionSize=N</code></li>
</ul>
</li>
</ul>
</li>
<li><em><strong>尽量避免Full GC！！</strong></em></li>
</ol>
<h3 id="框架层"><a href="#框架层" class="headerlink" title="框架层"></a>框架层</h3><p>尽量保持<strong>客户端</strong>版本和<strong>Broker端</strong>版本<strong>一致</strong>，否则可能会丧失很多<strong>性能收益</strong>，如<strong>Zero Copy</strong><br><img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-zero-copy.png" width=1000/></p>
<h3 id="应用程序层"><a href="#应用程序层" class="headerlink" title="应用程序层"></a>应用程序层</h3><ol>
<li><strong>不要频繁创建</strong>Producer和Consumer对象实例，构造这些对象的<strong>开销很大</strong></li>
<li><strong>用完及时关闭</strong><ul>
<li>Producer对象和Consumer对象会创建很多物理资源，如Socket连接、ByteBuffer缓冲区，很容易造成<strong>资源泄露</strong></li>
</ul>
</li>
<li>合理利用<strong>多线程</strong>来改善性能，Kafka的Java Producer是线程安全的，而Java Consumer不是线程安全的</li>
</ol>
<h2 id="性能指标调优"><a href="#性能指标调优" class="headerlink" title="性能指标调优"></a>性能指标调优</h2><h3 id="TPS-1000-Latency-ms"><a href="#TPS-1000-Latency-ms" class="headerlink" title="TPS != 1000 / Latency(ms)**"></a><code>TPS != 1000 / Latency(ms)</code>**</h3><ol>
<li>假设Kafka Producer以2ms的延时来发送消息，如果<strong>每次都只发送一条消息</strong>，那么<code>TPS=500</code></li>
<li>但如果Producer不是每次只发送一条消息，而是在发送前<strong>等待一段时间</strong>，然后<strong>统一发送一批</strong>消息</li>
<li>如Producer每次发送前等待8ms，总共缓存了1000条消息，总延时累加到了10ms，但<code>TPS=100,000</code><ul>
<li>虽然延时增加了4倍，但TPS却增加了200倍，这就是<strong>批次化</strong>或<strong>微批次化</strong>的优势</li>
<li>用户一般愿意用<strong>较小的延时增加</strong>的代价，去换取<strong>TPS的显著提升</strong>，Kafka Producer就是采用了这样的思路</li>
<li>基于的前提：<strong>内存操作</strong>（几百纳秒）和<strong>网络IO操作</strong>（毫秒甚至秒级）的时间量级不同</li>
</ul>
</li>
</ol>
<h3 id="调优吞吐量"><a href="#调优吞吐量" class="headerlink" title="调优吞吐量"></a>调优吞吐量</h3><ol>
<li>Broker端<ul>
<li>适当增加<strong><code>num.replica.fetchers</code></strong>（默认值为1），但<strong>不用超过CPU核数</strong><ul>
<li>生产环境中，配置了<code>acks=all</code>的Producer程序吞吐量被拖累的首要因素，就是<strong>副本同步性能</strong></li>
</ul>
</li>
<li>调优GC参数避免频繁Full GC</li>
</ul>
</li>
<li>Producer端<ul>
<li>适当增加<code>batch.size</code>（默认值为16KB，可以增加到<strong>512KB</strong>或<strong>1MB</strong>）<ul>
<li>增加消息批次的<strong>大小</strong></li>
</ul>
</li>
<li>适当增加<code>linger.ms</code>（默认值为0，可以增加到10~100）<ul>
<li>增加消息批次的<strong>缓存时间</strong></li>
</ul>
</li>
<li>修改<code>compression.type</code>（默认值为none，可以修改为<strong>lz4</strong>或<strong>zstd</strong>，适配最好）</li>
<li>修改<code>acks</code>（默认值为1，可以修改为<strong>0</strong>或<strong>1</strong>）<ul>
<li>优化的目标是吞吐量，不要开启<code>acks=all</code>（引入的<strong>副本同步时间</strong>通常是吞吐量的瓶颈）</li>
</ul>
</li>
<li>修改<code>retries</code>（修改为<strong>0</strong>）<ul>
<li>优化的目标是吞吐量，不要开启重试</li>
</ul>
</li>
<li>如果多线程共享同一个Producer，增加<code>buffer.memory</code>（默认为<code>32MB</code>）<ul>
<li><code>TimeoutException：Failed to allocate memory within the configured max blocking time</code></li>
</ul>
</li>
</ul>
</li>
<li>Consumer端<ul>
<li>采用多Consumer进程或线程<strong>同时消费</strong>数据</li>
<li>适当增加<code>fetch.min.bytes</code>（默认值为1Byte，可以修改为<strong>1KB</strong>或更大）</li>
</ul>
</li>
</ol>
<h3 id="调优延时"><a href="#调优延时" class="headerlink" title="调优延时"></a>调优延时</h3><ol>
<li>Broker端<ul>
<li>适当增加<code>num.replica.fetchers</code></li>
</ul>
</li>
<li>Producer端<ul>
<li>设置<code>linger.ms=0</code></li>
<li>设置<code>compression.type=none</code><ul>
<li>压缩会消耗CPU时间</li>
</ul>
</li>
<li>设置<code>acks=1</code></li>
</ul>
</li>
<li>Consumer端<ul>
<li>设置<code>fetch.min.bytes=1</code></li>
</ul>
</li>
</ol>
<p>参考：<a href="http://zhongmingmao.me" target="_blank" rel="noopener">http://zhongmingmao.me</a></p>
]]></content>
      <categories>
        <category>Middleware</category>
        <category>MQ</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Middleware</tag>
        <tag>MQ</tag>
        <tag>Kafka</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>nc 命令使用</title>
    <url>/2020/05/10/nc%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>什么是nc</p>
<blockquote>
<p>nc是netcat简称</p>
<p>1.实现任意TCP/UDP端口的监听</p>
<p>2.与telnet类似</p>
<p>3.端口的扫描</p>
<p>4.机器之间传输文件</p>
<p>5.机器之间网络测速 </p>
</blockquote>
<p><strong>语法格式：</strong>nc [参数]</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-l: 作为监听，开启一个port监听用户的联机</span><br><span class="line">-u: 不适用tcp而是使用udp作为连接的数据包状态</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install nc</span><br></pre></td></tr></table></figure>
<p>参考实例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 与telnet类似</span></span><br><span class="line">nc localhost 25</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 建立两个联机来传讯</span></span><br><span class="line"><span class="comment"># 终端1中输入：监听tcp端口</span></span><br><span class="line">nc -l localhost 8080</span><br><span class="line"><span class="comment"># 终端2中输入</span></span><br><span class="line">nc localhost 8080</span><br><span class="line"><span class="comment"># 可以进行交互了</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">扫描tcp端口</span><br><span class="line"></span><br><span class="line">nc -vz -w  192.168.1.105 9999</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">接收文件</span><br><span class="line"><span class="comment"># 终端1 192.168.1.105 file.txt 接收的文件名</span></span><br><span class="line">nc -l 9995 &gt;file.txt</span><br><span class="line"><span class="comment"># 终端2 deployment.yml需要发送的文件</span></span><br><span class="line">nc 192.168.1.105 9995 &lt; deployment.yml</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">测速</span><br><span class="line">需要安装yum install -y dstat</span><br><span class="line"><span class="comment"># 终端1（192.168.1.105）  </span></span><br><span class="line">nc -l 9991 &gt;/dev/null</span><br><span class="line"><span class="comment"># 终端2 （192.168.1.106）</span></span><br><span class="line">nc 192.168.1.105 9991 &lt;/dev/zero</span><br><span class="line"><span class="comment"># 终端3（192.168.1.105）</span></span><br><span class="line">dstat</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
        <category>nc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>nc</tag>
      </tags>
  </entry>
  <entry>
    <title>python -- socket编程</title>
    <url>/2019/07/03/python-Socket/</url>
    <content><![CDATA[<h3 id="1-Socket-编程简介"><a href="#1-Socket-编程简介" class="headerlink" title="1. Socket 编程简介"></a>1. Socket 编程简介</h3><p><img src="https://img-blog.csdnimg.cn/20181109233232849.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215b25lbG90dXM=,size_16,color_FFFFFF,t_70" alt=""></p>
<blockquote>
<p>注意，<strong>Socket 编程与 Http 请求不同，Socket 编程当连接完成后，就可以一直给另一方发送数据，只要连接没有断开，就可以一直发送数据。而 Http 请求是连接、发送数据、断开。每次发送数据都需要重复上面的过程，每次都需要连接。</strong>这是非常重要的一点。</p>
</blockquote>
<a id="more"></a>
<h3 id="2-基于-Socket-的简单聊天程序"><a href="#2-基于-Socket-的简单聊天程序" class="headerlink" title="2. 基于 Socket 的简单聊天程序"></a>2. 基于 Socket 的简单聊天程序</h3><h3 id="2-1-服务器端"><a href="#2-1-服务器端" class="headerlink" title="2.1 服务器端"></a>2.1 服务器端</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># socket.AF_INET 可以理解成 IPv4</span></span><br><span class="line"><span class="comment"># socket.AF_INET6 可以理解成 IPv6</span></span><br><span class="line"><span class="comment"># socket.SOCK_STREAM TCP 通信</span></span><br><span class="line"><span class="comment"># socket.SOCK_DGRAM UDP 通信</span></span><br><span class="line">server = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 注意，必须传入一个 tuple</span></span><br><span class="line"><span class="comment"># 这儿不能传入127.0.0.1，要不然就访问不到了</span></span><br><span class="line">server.bind((<span class="string">'0.0.0.0'</span>, <span class="number">8000</span>))</span><br><span class="line">server.listen()</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取从客户端发送的数据</span></span><br><span class="line"><span class="comment">#一次获取1k的数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_sock</span><span class="params">(sock, addr)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = sock.recv(<span class="number">1024</span>)</span><br><span class="line">        data = data.decode(<span class="string">"utf8"</span>)</span><br><span class="line">        <span class="keyword">if</span> data.lower() == <span class="string">'exit'</span> <span class="keyword">or</span> data.lower() == <span class="string">'bye'</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 获取一个服务器端的输入，发送给客户端</span></span><br><span class="line">        re_data = input()</span><br><span class="line">        sock.send(re_data.encode(<span class="string">"utf8"</span>))</span><br><span class="line">    sock.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    sock, addr = server.accept()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用线程去处理新接收的连接(用户)，这样就可以同时接收多个客服端的请求</span></span><br><span class="line">    <span class="comment"># target 传的是函数的名称，不是函数的调用</span></span><br><span class="line">    client_thread = threading.Thread(target=handle_sock, args=(sock, addr))</span><br><span class="line">    client_thread.start()</span><br></pre></td></tr></table></figure>
<h3 id="2-2-客户端"><a href="#2-2-客户端" class="headerlink" title="2.2 客户端"></a>2.2 客户端</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">client = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">client.connect((<span class="string">'127.0.0.1'</span>, <span class="number">8000</span>))</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    re_data = input()</span><br><span class="line">    client.send(re_data.encode(<span class="string">"utf8"</span>))</span><br><span class="line">    data = client.recv(<span class="number">1024</span>)</span><br><span class="line">    print(data.decode(<span class="string">"utf8"</span>))</span><br></pre></td></tr></table></figure>
<h3 id="3-使用-Socket-模拟-Http-请求"><a href="#3-使用-Socket-模拟-Http-请求" class="headerlink" title="3. 使用 Socket 模拟 Http 请求"></a>3. 使用 Socket 模拟 Http 请求</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># requests -&gt; urlib -&gt; socket</span><br><span class="line">import socket</span><br><span class="line">from urllib.parse import urlparse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_url(url):</span><br><span class="line">    # 通过socket请求html</span><br><span class="line">    url &#x3D; urlparse(url)</span><br><span class="line">    # 获取主机名</span><br><span class="line">    host &#x3D; url.netloc</span><br><span class="line">    # 请求路径</span><br><span class="line">    path &#x3D; url.path</span><br><span class="line">    # 当请求为空时，特殊处理</span><br><span class="line">    if path &#x3D;&#x3D; &quot;&quot;:</span><br><span class="line">        path &#x3D; &quot;&#x2F;&quot;</span><br><span class="line"></span><br><span class="line">    # 建立socket连接</span><br><span class="line">    client &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    # client.setblocking(False)</span><br><span class="line">    client.connect((host, 80))  # 阻塞不会消耗cpu</span><br><span class="line"></span><br><span class="line">    # 不停的询问连接是否建立好， 需要while循环不停的去检查状态</span><br><span class="line">    # 做计算任务或者再次发起其他的连接请求</span><br><span class="line"></span><br><span class="line">    # 注意这儿的编码</span><br><span class="line">    client.send(</span><br><span class="line">        &quot;GET &#123;&#125; HTTP&#x2F;1.1\r\nHost:&#123;&#125;\r\nConnection:close\r\n\r\n&quot;.format(path, host).encode(&quot;utf8&quot;))</span><br><span class="line"></span><br><span class="line">    # 注意这儿是 byte 类型</span><br><span class="line">    data &#x3D; b&quot;&quot;</span><br><span class="line">    while True:</span><br><span class="line">        d &#x3D; client.recv(1024)</span><br><span class="line">        if d:</span><br><span class="line">            data +&#x3D; d</span><br><span class="line">        else:</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line">    data &#x3D; data.decode(&quot;utf8&quot;)</span><br><span class="line">    # 只保留 HTML 内容，去除头部内容</span><br><span class="line">    html_data &#x3D; data.split(&quot;\r\n\r\n&quot;)[1]</span><br><span class="line">    print(html_data)</span><br><span class="line">    client.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    import time</span><br><span class="line">    start_time &#x3D; time.time()</span><br><span class="line">    for url in range(20):</span><br><span class="line">        url &#x3D; &quot;http:&#x2F;&#x2F;shop.projectsedu.com&#x2F;goods&#x2F;&#123;&#125;&#x2F;&quot;.format(url)</span><br><span class="line">        get_url(url)</span><br><span class="line">    print(time.time()-start_time)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>No module named &#39;_bz2&#39;</title>
    <url>/2018/11/09/python-bz2/</url>
    <content><![CDATA[<h4 id="ModuleNotFoundError-No-module-named-‘-bz2’"><a href="#ModuleNotFoundError-No-module-named-‘-bz2’" class="headerlink" title="ModuleNotFoundError: No module named ‘_bz2’"></a>ModuleNotFoundError: No module named ‘_bz2’</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install bzip2-devel </span><br><span class="line"><span class="comment"># 进入python3的安装目录,重新编译python3 cd /usr/local/Python3</span></span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>bz2</tag>
      </tags>
  </entry>
  <entry>
    <title>python -- asyncio</title>
    <url>/2019/07/06/python-asyncio/</url>
    <content><![CDATA[<h3 id="1-asyncio-简介"><a href="#1-asyncio-简介" class="headerlink" title="1. asyncio 简介"></a>1. asyncio 简介</h3><p><img src="https://img-blog.csdnimg.cn/20181222184931518.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215b25lbG90dXM=,size_16,color_FFFFFF,t_70" alt=""></p>
<a id="more"></a>
<h3 id="1-1-协程与-asyncio"><a href="#1-1-协程与-asyncio" class="headerlink" title="1.1 协程与 asyncio"></a>1.1 协程与 asyncio</h3><blockquote>
<p>协程编写的三个组成部分：1. 事件循环， 2. 回调(驱动生成器)， 3. epoll（IO 多路复用）<br><strong>asyncio 是 python 用于解决异步 IO 编程的一整套解决方案。</strong>基于 asyncio 的框架有: tornado、gevent、twisted（scrapy， django channels）。<br>django channels 用于 HTTP 2.0 开发；torando (实现 web 服务器)， 如果使用 django ，通常使用 django + flask (uwsgi, gunicorn+nginx) 的搭配方式；tornado 可以直接部署， 通常使用 nginx + tornado 的搭配方式。<br>asyncio 不能和 requests 库结合使用<br><a href="http://www.imooc.com/article/24759" target="_blank" rel="noopener">http://www.imooc.com/article/24759</a></p>
</blockquote>
<h3 id="2-asyncio-的使用"><a href="#2-asyncio-的使用" class="headerlink" title="2 asyncio 的使用"></a>2 asyncio 的使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">"start get url"</span>)</span><br><span class="line">    <span class="comment"># 这里不能使用 time.sleep(2) 模拟 HTTP 请求，因为这是一个同步阻塞的方式</span></span><br><span class="line">    <span class="comment"># 这个地方必须加 await</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"end get url"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    <span class="comment"># 相当于之前例子中的 loop 函数</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    tasks = [get_html(<span class="string">"http://www.imooc.com"</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">    <span class="comment"># loop.run_until_complete(get_html("http://www.imooc.com"))</span></span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    print(time.time()-start_time)</span><br></pre></td></tr></table></figure>
<h3 id="2-2-获取-asyncio-的返回值"><a href="#2-2-获取-asyncio-的返回值" class="headerlink" title="2.2 获取 asyncio 的返回值"></a>2.2 获取 asyncio 的返回值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取协程的返回值</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">"start get url"</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"bobby"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    <span class="comment"># 方式一：</span></span><br><span class="line">    <span class="comment"># get_future = asyncio.ensure_future(get_html("http://www.imooc.com"))</span></span><br><span class="line">    <span class="comment"># loop.run_until_complete(get_future)</span></span><br><span class="line">    <span class="comment"># print(get_future.result())</span></span><br><span class="line">    <span class="comment"># 方式一中会产生一个疑惑？即：</span></span><br><span class="line">    <span class="comment"># 使用 asyncio 模块，传入的参数中没有传入 Event loop，</span></span><br><span class="line">    <span class="comment"># 那么上面的 get_html("http://www.imooc.com") 事件是如何被注入到 loop 中的呢？</span></span><br><span class="line">    <span class="comment"># 答案不是在 loop.run_until_complete(get_future) 中完成的，而是在 ensure_future 中完成的，</span></span><br><span class="line">    <span class="comment"># 在这个方法中获取 Event loop，这个 loop 和我们自己创建的 loop 是同一个 loop。具体可以参考 ensure_future 源码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方式二：</span></span><br><span class="line">    <span class="comment"># task 是 Future 的一个子类</span></span><br><span class="line">    task = loop.create_task(get_html(<span class="string">"http://www.imooc.com"</span>))</span><br><span class="line">    loop.run_until_complete(task)</span><br><span class="line">    print(task.result())</span><br></pre></td></tr></table></figure>
<h3 id="2-3-call-back"><a href="#2-3-call-back" class="headerlink" title="2.3 call back"></a>2.3 call back</h3><blockquote>
<p>使用 call back 可以完成某些回调需求，比如完成某个任务，发送一封邮件；或者某个抓取线程耗时过长，通知你一下。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">"start get url"</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"bobby"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意，这里必须有一个 future 参数，这个 Future 就是下面的 task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(future)</span>:</span></span><br><span class="line">    print(<span class="string">"send email to bobby"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    task = loop.create_task(get_html(<span class="string">"http://www.imooc.com"</span>))</span><br><span class="line">    task.add_done_callback(callback)</span><br><span class="line">    loop.run_until_complete(task)</span><br><span class="line">    print(task.result())</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当 call back 有参数的时候，使用 from functools import partial 包装 callback。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">"start get url"</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"bobby"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意，这里必须有一个 Future 参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(url, future)</span>:</span></span><br><span class="line">    print(url)</span><br><span class="line">    print(<span class="string">"send email to bobby"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    task = loop.create_task(get_html(<span class="string">"http://www.imooc.com"</span>))</span><br><span class="line">    task.add_done_callback(partial(callback, <span class="string">"http://www.imooc.com"</span>))</span><br><span class="line">    loop.run_until_complete(task)</span><br><span class="line">    print(task.result())</span><br></pre></td></tr></table></figure>
<h3 id="2-4-wait-和-gather"><a href="#2-4-wait-和-gather" class="headerlink" title="2.4 wait 和 gather"></a>2.4 wait 和 gather</h3><h3 id="2-4-1-wait"><a href="#2-4-1-wait" class="headerlink" title="2.4.1 wait"></a>2.4.1 wait</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">"start get url"</span>)</span><br><span class="line">    <span class="comment"># 这里不能使用 time.sleep(2) 模拟 HTTP 请求，因为这是一个同步阻塞的方式</span></span><br><span class="line">    <span class="comment"># 这个地方必须加 await</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"end get url"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    tasks = [get_html(<span class="string">"http://www.imooc.com"</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">    <span class="comment"># wait 一次性完成多个任务的时候使用</span></span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    print(time.time()-start_time)</span><br></pre></td></tr></table></figure>
<h3 id="2-4-2-gather"><a href="#2-4-2-gather" class="headerlink" title="2.4.2 gather"></a>2.4.2 gather</h3><blockquote>
<p>gather 是比 wait 更加高一层的功能抽象。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">"start get url"</span>)</span><br><span class="line">    <span class="comment"># 这里不能使用 time.sleep(2) 模拟 HTTP 请求，因为这是一个同步阻塞的方式</span></span><br><span class="line">    <span class="comment"># 这个地方必须加 await</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"end get url"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    tasks = [get_html(<span class="string">"http://www.imooc.com"</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">    <span class="comment"># 这儿使用 gather 的时候，需要加一个星号，会将列表中的元素传进去</span></span><br><span class="line">    loop.run_until_complete(asyncio.gather(*tasks))</span><br><span class="line">    print(time.time()-start_time)</span><br></pre></td></tr></table></figure>
<h3 id="2-4-3-wait-与-gather-中的区别"><a href="#2-4-3-wait-与-gather-中的区别" class="headerlink" title="2.4.3 wait 与 gather 中的区别"></a>2.4.3 wait 与 gather 中的区别</h3><blockquote>
<p>gather 比 wait 更加高层。gather 可以将任务分组，一般优先使用 gather。在某些定制化任务需求的时候，会使用 wait。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例子一</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">"start get url"</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"end get url"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    tasks = [get_html(<span class="string">"http://www.imooc.com"</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">    group1 = [get_html(<span class="string">"http://projectsedu.com"</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">    group2 = [get_html(<span class="string">"http://www.imooc.com"</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">    </span><br><span class="line">    loop.run_until_complete(asyncio.gather(*group1, *group2))</span><br><span class="line">    print(time.time() - start_time)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例子二</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">"start get url"</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"end get url"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    tasks = [get_html(<span class="string">"http://www.imooc.com"</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">    group1 = [get_html(<span class="string">"http://projectsedu.com"</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">    group2 = [get_html(<span class="string">"http://www.imooc.com"</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">    group1 = asyncio.gather(*group1)</span><br><span class="line">    group2 = asyncio.gather(*group2)</span><br><span class="line">    </span><br><span class="line">    loop.run_until_complete(asyncio.gather(group1, group2))</span><br><span class="line">    print(time.time() - start_time)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例子三：成批的取消任务</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">"start get url"</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"end get url"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    tasks = [get_html(<span class="string">"http://www.imooc.com"</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">    group1 = [get_html(<span class="string">"http://projectsedu.com"</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">    group2 = [get_html(<span class="string">"http://www.imooc.com"</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">    group1 = asyncio.gather(*group1)</span><br><span class="line">    group2 = asyncio.gather(*group2)</span><br><span class="line">    group2.cancel()</span><br><span class="line">    loop.run_until_complete(asyncio.gather(group1, group2))</span><br><span class="line">    print(time.time() - start_time)</span><br></pre></td></tr></table></figure>
<h3 id="2-5-run-until-complete-实现的原理"><a href="#2-5-run-until-complete-实现的原理" class="headerlink" title="2.5 run_until_complete 实现的原理"></a>2.5 run_until_complete 实现的原理</h3><blockquote>
<p>loop.run_forever() 会让线程一直运行。loop.run_until_complete() 借助了 run_forever 方法。<br>在 run_until_complete 的实现中，调用了 future.add_done_callback(_run_until_complete_cb)。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_until_complete</span><span class="params">(self, future)</span>:</span></span><br><span class="line">       <span class="string">"""Run until the Future is done.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       If the argument is a coroutine, it is wrapped in a Task.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       WARNING: It would be disastrous to call run_until_complete()</span></span><br><span class="line"><span class="string">       with the same coroutine twice -- it would wrap it in two</span></span><br><span class="line"><span class="string">       different Tasks and that can't be good.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       Return the Future's result, or raise its exception.</span></span><br><span class="line"><span class="string">       """</span></span><br><span class="line">       self._check_closed()</span><br><span class="line"></span><br><span class="line">       new_task = <span class="keyword">not</span> futures.isfuture(future)</span><br><span class="line">       future = tasks.ensure_future(future, loop=self)</span><br><span class="line">       <span class="keyword">if</span> new_task:</span><br><span class="line">           <span class="comment"># An exception is raised if the future didn't complete, so there</span></span><br><span class="line">           <span class="comment"># is no need to log the "destroy pending task" message</span></span><br><span class="line">           future._log_destroy_pending = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">       future.add_done_callback(_run_until_complete_cb)</span><br><span class="line">       <span class="keyword">try</span>:</span><br><span class="line">           self.run_forever()</span><br><span class="line">       <span class="keyword">except</span>:</span><br><span class="line">           <span class="keyword">if</span> new_task <span class="keyword">and</span> future.done() <span class="keyword">and</span> <span class="keyword">not</span> future.cancelled():</span><br><span class="line">               <span class="comment"># The coroutine raised a BaseException. Consume the exception</span></span><br><span class="line">               <span class="comment"># to not log a warning, the caller doesn't have access to the</span></span><br><span class="line">               <span class="comment"># local task.</span></span><br><span class="line">               future.exception()</span><br><span class="line">           <span class="keyword">raise</span></span><br><span class="line">       <span class="keyword">finally</span>:</span><br><span class="line">           future.remove_done_callback(_run_until_complete_cb)</span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> future.done():</span><br><span class="line">           <span class="keyword">raise</span> RuntimeError(<span class="string">'Event loop stopped before Future completed.'</span>)</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> future.result()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 _run_until_complete_cb 方法中，在运行指定的任务后，停止掉。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_run_until_complete_cb</span><span class="params">(fut)</span>:</span></span><br><span class="line">    exc = fut._exception</span><br><span class="line">    <span class="keyword">if</span> (isinstance(exc, BaseException)</span><br><span class="line">    <span class="keyword">and</span> <span class="keyword">not</span> isinstance(exc, Exception)):</span><br><span class="line">        <span class="comment"># Issue #22429: run_forever() already finished, no need to</span></span><br><span class="line">        <span class="comment"># stop it.</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    fut._loop.stop()</span><br></pre></td></tr></table></figure>
<h3 id="2-6-取消任务"><a href="#2-6-取消任务" class="headerlink" title="2.6 取消任务"></a>2.6 取消任务</h3><blockquote>
<p>这个需求非常常用。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(sleep_times)</span>:</span></span><br><span class="line">    print(<span class="string">"waiting"</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(sleep_times)</span><br><span class="line">    print(<span class="string">"done after &#123;&#125;s"</span>.format(sleep_times))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    task1 = get_html(<span class="number">2</span>)</span><br><span class="line">    task2 = get_html(<span class="number">3</span>)</span><br><span class="line">    task3 = get_html(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    tasks = [task1, task2, task3]</span><br><span class="line"></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt <span class="keyword">as</span> e:</span><br><span class="line">        all_tasks = asyncio.Task.all_tasks()</span><br><span class="line">        <span class="keyword">for</span> task <span class="keyword">in</span> all_tasks:</span><br><span class="line">            print(<span class="string">"cancel task"</span>)</span><br><span class="line">            print(task.cancel())</span><br><span class="line">        loop.stop()</span><br><span class="line">        <span class="comment"># stop 调用之后，需要调用 run_forever，不然会报错</span></span><br><span class="line">        loop.run_forever()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        loop.close()</span><br></pre></td></tr></table></figure>
<h3 id="3-协程中嵌套协程，子协程"><a href="#3-协程中嵌套协程，子协程" class="headerlink" title="3 协程中嵌套协程，子协程"></a>3 协程中嵌套协程，子协程</h3><blockquote>
<p><a href="https://docs.python.org/3.6/library/asyncio-task.html" target="_blank" rel="noopener">https://docs.python.org/3.6/library/asyncio-task.html</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这个例子，参考上面链接的序列图理解。</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">compute</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    print(<span class="string">"Compute %s + %s ..."</span> % (x, y))</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1.0</span>)</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">print_sum</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    result = <span class="keyword">await</span> compute(x, y)</span><br><span class="line">    print(<span class="string">"%s + %s = %s"</span> % (x, y, result))</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(print_sum(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>
<h3 id="4-asyncio-中的几个函数"><a href="#4-asyncio-中的几个函数" class="headerlink" title="4. asyncio 中的几个函数"></a>4. asyncio 中的几个函数</h3><h3 id="4-1-call-soon"><a href="#4-1-call-soon" class="headerlink" title="4.1 call soon"></a>4.1 call soon</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这儿定义的是函数，不是协程</span></span><br><span class="line"><span class="comment"># 因为在很多时候，我们希望在 loop 当中，也就是循环体系当中，插入一个函数，可以让函数立即执行</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(sleep_times)</span>:</span></span><br><span class="line">    print(<span class="string">"success time &#123;&#125;"</span>.format(sleep_times))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stoploop</span><span class="params">(loop)</span>:</span></span><br><span class="line">    loop.stop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#call_soon</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.call_soon(callback, <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 通过定义 stoploop 函数，停止 run_forever 循环</span></span><br><span class="line">    <span class="comment"># 注意这里的参数，是传入的 loop</span></span><br><span class="line">    loop.call_soon(stoploop, loop)</span><br><span class="line">    <span class="comment"># 启动，这儿不是使用 run_until_complete，因为 callback 不是协程。</span></span><br><span class="line">    loop.run_forever()</span><br></pre></td></tr></table></figure>
<h2 id="4-2-call-later"><a href="#4-2-call-later" class="headerlink" title="4.2 call later"></a>4.2 call later</h2><blockquote>
<p>call_later 中执行顺序并不是添加顺序，会根据延迟调用时间确定一个先后顺序。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(sleep_times)</span>:</span></span><br><span class="line">    print(<span class="string">"success time &#123;&#125;"</span>.format(sleep_times))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stoploop</span><span class="params">(loop)</span>:</span></span><br><span class="line">    loop.stop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#call_later, call_at</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    <span class="comment"># 执行顺序并不是添加顺序，会根据延迟调用时间确定一个先后顺序</span></span><br><span class="line">    loop.call_later(<span class="number">2</span>, callback, <span class="number">2</span>)</span><br><span class="line">    loop.call_later(<span class="number">1</span>, callback, <span class="number">1</span>)</span><br><span class="line">    loop.call_later(<span class="number">3</span>, callback, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动，这儿不是使用 run_until_complete，因为 callback 不是协程。</span></span><br><span class="line">    loop.run_forever()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当 call_soon 和 call_later 同时出现的时候，会先执行 call_soon。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(sleep_times)</span>:</span></span><br><span class="line">    print(<span class="string">"success time &#123;&#125;"</span>.format(sleep_times))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stoploop</span><span class="params">(loop)</span>:</span></span><br><span class="line">    loop.stop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#call_later</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    <span class="comment"># 执行顺序并不是添加顺序，会根据延迟调用时间确定一个先后顺序</span></span><br><span class="line">    loop.call_later(<span class="number">2</span>, callback, <span class="number">2</span>)</span><br><span class="line">    loop.call_later(<span class="number">1</span>, callback, <span class="number">1</span>)</span><br><span class="line">    loop.call_later(<span class="number">3</span>, callback, <span class="number">3</span>)</span><br><span class="line">    loop.call_soon(callback, <span class="number">4</span>)</span><br><span class="line">    <span class="comment"># 这儿不能加入call_soon stoploop 函数，call soon 会立即执行，call_later 就不会再执行了。</span></span><br><span class="line">    <span class="comment"># loop.call_soon(stoploop, loop)</span></span><br><span class="line">    <span class="comment"># 启动，这儿不是使用 run_until_complete，因为 callback 不是协程。</span></span><br><span class="line">    loop.run_forever()</span><br></pre></td></tr></table></figure>
<h3 id="4-4-call-soon-threadsafe"><a href="#4-4-call-soon-threadsafe" class="headerlink" title="4.4 call_soon_threadsafe"></a>4.4 call_soon_threadsafe</h3><blockquote>
<p>这个方法用于解决对互斥资源访问的问题。如果有对互斥资源访问，需要使用这个方法。使用方法和上面的 call_soon 相同。</p>
</blockquote>
<h3 id="5-线程池与-asyncio-结合起来"><a href="#5-线程池与-asyncio-结合起来" class="headerlink" title="5. 线程池与 asyncio 结合起来"></a>5. 线程池与 asyncio 结合起来</h3><blockquote>
<p>asyncio 是异步 IO 的解决方案。异步 IO 包括了多线程、协程、进程。<br>协程里面不能加入阻塞 IO，但是某些库只能提供阻塞 IO 接口，那么这个时候就需要将协程放到线程中。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用多线程：在协程中集成阻塞io</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_url</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="comment"># 通过socket请求html</span></span><br><span class="line">    url = urlparse(url)</span><br><span class="line">    host = url.netloc</span><br><span class="line">    path = url.path</span><br><span class="line">    <span class="keyword">if</span> path == <span class="string">""</span>:</span><br><span class="line">        path = <span class="string">"/"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 建立socket连接</span></span><br><span class="line">    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    <span class="comment"># client.setblocking(False)</span></span><br><span class="line">    client.connect((host, <span class="number">80</span>))  <span class="comment"># 阻塞不会消耗cpu</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 不停的询问连接是否建立好， 需要while循环不停的去检查状态</span></span><br><span class="line">    <span class="comment"># 做计算任务或者再次发起其他的连接请求</span></span><br><span class="line"></span><br><span class="line">    client.send(</span><br><span class="line">        <span class="string">"GET &#123;&#125; HTTP/1.1\r\nHost:&#123;&#125;\r\nConnection:close\r\n\r\n"</span>.format(path, host).encode(<span class="string">"utf8"</span>))</span><br><span class="line"></span><br><span class="line">    data = <span class="string">b""</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        d = client.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> d:</span><br><span class="line">            data += d</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    data = data.decode(<span class="string">"utf8"</span>)</span><br><span class="line">    html_data = data.split(<span class="string">"\r\n\r\n"</span>)[<span class="number">1</span>]</span><br><span class="line">    print(html_data)</span><br><span class="line">    client.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    executor = ThreadPoolExecutor(<span class="number">3</span>)</span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        url = <span class="string">"http://shop.projectsedu.com/goods/&#123;&#125;/"</span>.format(url)</span><br><span class="line">        <span class="comment"># 返回 task</span></span><br><span class="line">        task = loop.run_in_executor(executor, get_url, url)</span><br><span class="line">        tasks.append(task)</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    print(<span class="string">"last time:&#123;&#125;"</span>.format(time.time()-start_time))</span><br></pre></td></tr></table></figure>
<h3 id="5-1-使用-asyncio-模拟-HTTP-请求"><a href="#5-1-使用-asyncio-模拟-HTTP-请求" class="headerlink" title="5.1 使用 asyncio 模拟 HTTP 请求"></a>5.1 使用 asyncio 模拟 HTTP 请求</h3><blockquote>
<p>asyncio 目前为止没有提供 HTTP 协议接口，只提供了 UDP 和 TCP 接口，也许以后会提供。可以使用 aiohttp 完成这个功能。现在，我们使用原生的底层接口实现 HTTP 请求。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># asyncio 没有提供http协议的接口</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 改成使用协程</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_url</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="comment">#通过socket请求html</span></span><br><span class="line">    url = urlparse(url)</span><br><span class="line">    host = url.netloc</span><br><span class="line">    path = url.path</span><br><span class="line">    <span class="keyword">if</span> path == <span class="string">""</span>:</span><br><span class="line">        path = <span class="string">"/"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#建立socket连接</span></span><br><span class="line">    <span class="comment"># open_connection 源码中调用了 yield from loop.create_connection 。这里实现的功能完成了 register 和 unregister</span></span><br><span class="line">    reader, writer = <span class="keyword">await</span> asyncio.open_connection(host,<span class="number">80</span>)</span><br><span class="line">    <span class="comment"># write 方法完成 register 和 unregister</span></span><br><span class="line">    writer.write(<span class="string">"GET &#123;&#125; HTTP/1.1\r\nHost:&#123;&#125;\r\nConnection:close\r\n\r\n"</span>.format(path, host).encode(<span class="string">"utf8"</span>))</span><br><span class="line">    all_lines = []</span><br><span class="line">    <span class="comment"># async for 语法，可以将读数据的方式异步化。</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">for</span> raw_line <span class="keyword">in</span> reader:</span><br><span class="line">        data = raw_line.decode(<span class="string">"utf8"</span>)</span><br><span class="line">        all_lines.append(data)</span><br><span class="line">    html = <span class="string">"\n"</span>.join(all_lines)</span><br><span class="line">    <span class="keyword">return</span> html</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 使用 tasks 放置 future 对象</span></span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        url = <span class="string">"http://shop.projectsedu.com/goods/&#123;&#125;/"</span>.format(url)</span><br><span class="line">        <span class="comment"># 使用 asyncio.ensure_future 包装协程，变成 Future 对象，从而获得协程的结果</span></span><br><span class="line">        tasks.append(asyncio.ensure_future(get_url(url)))</span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> asyncio.as_completed(tasks):</span><br><span class="line">        <span class="comment"># 这儿需要使用 await，因为返回的是一个协程，需要使用 await 关键字修饰</span></span><br><span class="line">        result = <span class="keyword">await</span> task</span><br><span class="line">        print(result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    <span class="comment"># 这儿重新定义了一个函数 main，从而实现 as_completed，即完成一个 task，打印一个 task</span></span><br><span class="line">    <span class="comment"># 在 main 中使用了 asyncio.as_completed，这和线程池中的 as_completed 效果一样</span></span><br><span class="line">    loop.run_until_complete(main())</span><br><span class="line">    print(<span class="string">'last time:&#123;&#125;'</span>.format(time.time()-start_time))</span><br></pre></td></tr></table></figure>
<h3 id="6-asuncio-中的-future-和-task"><a href="#6-asuncio-中的-future-和-task" class="headerlink" title="6. asuncio 中的 future 和 task"></a>6. asuncio 中的 future 和 task</h3><blockquote>
<p>future 是一个结果容器，将运行结果放到 Future 中。task 是协程和 Future 的桥梁。<br>我们之前的章节说过，线程是由操作系统调用的，协程是由程序员自己调用的，在定义一个协程之后， 在驱动这个协程之前，需要调用 next 或者 send(None)，是协程生效。task 的 init 方法中有 self._loop.call_soon(self._step)，在 step 方法中有 result = coro.send(None) 激活协程，通过这行语句解决协程启动的问题。并且，在 step 方法中，如果抛出 StopIteration，会执行 self.set_result(exc.value)。exc.value 表示异常中的值，正如之前章节说的，这个值也是协程中的 return 值。通过这个我们可以看出，task 不管启动了协程，还将最后 StopIteration 中的值做了处理。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_step</span><span class="params">(self, exc=None)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="keyword">not</span> self.done(), \</span><br><span class="line">        <span class="string">'_step(): already done: &#123;!r&#125;, &#123;!r&#125;'</span>.format(self, exc)</span><br><span class="line">    <span class="keyword">if</span> self._must_cancel:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(exc, futures.CancelledError):</span><br><span class="line">            exc = futures.CancelledError()</span><br><span class="line">        self._must_cancel = <span class="literal">False</span></span><br><span class="line">    coro = self._coro</span><br><span class="line">    self._fut_waiter = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    self.__class__._current_tasks[self._loop] = self</span><br><span class="line">    <span class="comment"># Call either coro.throw(exc) or coro.send(None).</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> exc <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># We use the `send` method directly, because coroutines</span></span><br><span class="line">            <span class="comment"># don't have `__iter__` and `__next__` methods.</span></span><br><span class="line">            result = coro.send(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result = coro.throw(exc)</span><br><span class="line">    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> exc:</span><br><span class="line">        <span class="keyword">if</span> self._must_cancel:</span><br><span class="line">            <span class="comment"># Task is cancelled right before coro stops.</span></span><br><span class="line">            self._must_cancel = <span class="literal">False</span></span><br><span class="line">            self.set_exception(futures.CancelledError())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.set_result(exc.value)</span><br><span class="line">    <span class="keyword">except</span> futures.CancelledError:</span><br><span class="line">        super().cancel()  <span class="comment"># I.e., Future.cancel(self).</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">        self.set_exception(exc)</span><br><span class="line">    <span class="keyword">except</span> BaseException <span class="keyword">as</span> exc:</span><br><span class="line">        self.set_exception(exc)</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        blocking = getattr(result, <span class="string">'_asyncio_future_blocking'</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> blocking <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># Yielded Future must come from Future.__iter__().</span></span><br><span class="line">            <span class="keyword">if</span> result._loop <span class="keyword">is</span> <span class="keyword">not</span> self._loop:</span><br><span class="line">                self._loop.call_soon(</span><br><span class="line">                    self._step,</span><br><span class="line">                    RuntimeError(</span><br><span class="line">                        <span class="string">'Task &#123;!r&#125; got Future &#123;!r&#125; attached to a '</span></span><br><span class="line">                        <span class="string">'different loop'</span>.format(self, result)))</span><br><span class="line">            <span class="keyword">elif</span> blocking:</span><br><span class="line">                <span class="keyword">if</span> result <span class="keyword">is</span> self:</span><br><span class="line">                    self._loop.call_soon(</span><br><span class="line">                        self._step,</span><br><span class="line">                        RuntimeError(</span><br><span class="line">                            <span class="string">'Task cannot await on itself: &#123;!r&#125;'</span>.format(</span><br><span class="line">                                self)))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    result._asyncio_future_blocking = <span class="literal">False</span></span><br><span class="line">                    result.add_done_callback(self._wakeup)</span><br><span class="line">                    self._fut_waiter = result</span><br><span class="line">                    <span class="keyword">if</span> self._must_cancel:</span><br><span class="line">                        <span class="keyword">if</span> self._fut_waiter.cancel():</span><br><span class="line">                            self._must_cancel = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self._loop.call_soon(</span><br><span class="line">                    self._step,</span><br><span class="line">                    RuntimeError(</span><br><span class="line">                        <span class="string">'yield was used instead of yield from '</span></span><br><span class="line">                        <span class="string">'in task &#123;!r&#125; with &#123;!r&#125;'</span>.format(self, result)))</span><br><span class="line">        <span class="keyword">elif</span> result <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># Bare yield relinquishes control for one event loop iteration.</span></span><br><span class="line">            self._loop.call_soon(self._step)</span><br><span class="line">        <span class="keyword">elif</span> inspect.isgenerator(result):</span><br><span class="line">            <span class="comment"># Yielding a generator is just wrong.</span></span><br><span class="line">            self._loop.call_soon(</span><br><span class="line">                self._step,</span><br><span class="line">                RuntimeError(</span><br><span class="line">                    <span class="string">'yield was used instead of yield from for '</span></span><br><span class="line">                    <span class="string">'generator in task &#123;!r&#125; with &#123;&#125;'</span>.format(</span><br><span class="line">                        self, result)))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># Yielding something else is an error.</span></span><br><span class="line">            self._loop.call_soon(</span><br><span class="line">                self._step,</span><br><span class="line">                RuntimeError(</span><br><span class="line">                    <span class="string">'Task got bad yield: &#123;!r&#125;'</span>.format(result)))</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        self.__class__._current_tasks.pop(self._loop)</span><br><span class="line">        self = <span class="literal">None</span>  <span class="comment"># Needed to break cycles when an exception occurs.</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>从系统设计的角度看，asyncio 模块尽量保持与线程池中的接口一致，为了达到这个目的，就设计了 task，用于解决线程和协程之间不一样的地方。</p>
</blockquote>
<h3 id="7-asyncio-同步和通信"><a href="#7-asyncio-同步和通信" class="headerlink" title="7. asyncio 同步和通信"></a>7. asyncio 同步和通信</h3><blockquote>
<p>asyncio 实际上是基于单线程做的，而且，asyncio 是不需要锁的。那我们为什么还会谈到 asyncio 的同步呢？<br>首先，我们来看一下，使用 asyncio 做单线程是不需要锁的。<br>下面的例子，不管执行多少次都是0，说明：凡是不涉及到 IO，或者不涉及到 await，都会执行完了，再执行另一段代码，这是为什么结果始终为 0 的本质。例子中，add 中的 for i in range(1000000) 运行完了，才会运行 desc 中的 for 循环。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 1. dosomething1</span></span><br><span class="line">    <span class="comment"># 2. io操作</span></span><br><span class="line">    <span class="comment"># 1. dosomething3</span></span><br><span class="line">    <span class="keyword">global</span> total</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        total += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">desc</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> total</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        total -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> asyncio</span><br><span class="line">    tasks = [add(), desc()]</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    print(total)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的例子已经说明了不需要设置锁。但是，在某种情况下，还是需要设置锁的，具体看下面的例子：<br>在 parse_stuff 和 use_stuff 中都会调用 get_stuff。有可能出现：缓存中没有某个 URL，两个协程 parse_stuff 和 use_stuff 运行的时候，可能都会发起 get_stuff 中的 await aiohttp.request。这个时候，就会发起两次请求，并且，这两个请求都是非常耗时的。并且，某些网站后台会进行反爬虫处理。如果有锁的话，就可以避免重复请求的情况。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> asyncio <span class="keyword">import</span> Lock, Queue</span><br><span class="line"></span><br><span class="line">lock = Lock()</span><br><span class="line">cache = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 URL 的返回值</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_stuff</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> url <span class="keyword">in</span> cache:</span><br><span class="line">        <span class="keyword">return</span> cache[url]</span><br><span class="line">    stuff = <span class="keyword">await</span> aiohttp.request(<span class="string">'GET'</span>,url)</span><br><span class="line">    cache[url] = stuff</span><br><span class="line">    <span class="keyword">return</span> stuff</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">parse_stuff</span><span class="params">()</span>:</span></span><br><span class="line">    stuff = <span class="keyword">await</span> get_stuff()</span><br><span class="line">    <span class="comment"># do some parsing</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">use_stuff</span><span class="params">()</span>:</span></span><br><span class="line">    stuff = <span class="keyword">await</span> get_stuff()</span><br><span class="line">    <span class="comment"># use stuff to do something interesting</span></span><br><span class="line"></span><br><span class="line">tasks = [parse_stuff(), use_stuff()]</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用锁之后，代码如下：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="comment"># 这里使用的是 asyncio 中的 Lock</span></span><br><span class="line"><span class="comment"># 这个 Lock 调用系统的锁，是程序员级别的锁，因为协程本身不涉及，正如我们之前说过的，协程是一个单线程。</span></span><br><span class="line"><span class="comment"># 通过自己定义的 self._locked 完成互斥执行一段代码</span></span><br><span class="line"><span class="comment"># 我们之前说过调用 acquire 这些方法的时候，一定不能是阻塞的。在 Lock 的 acquire 方法中，首先创建了 Future，然后 yield from fut</span></span><br><span class="line"><span class="keyword">from</span> asyncio <span class="keyword">import</span> Lock, Queue</span><br><span class="line"></span><br><span class="line">lock = Lock()</span><br><span class="line">cache = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 URL 的返回值</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_stuff</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="comment"># 第一个知识点：</span></span><br><span class="line">    <span class="comment"># 不使用 with 语句的时候，可以使用 await lock.acquire() 和 lock.release()。</span></span><br><span class="line">    <span class="comment"># 除了使用 with，还可以使用 async with 方式。</span></span><br><span class="line">    <span class="comment"># with await lock:</span></span><br><span class="line">    <span class="comment"># 说到 Lock，Condition 的 asyncio 的用法也是一样的，用途和之前也是一样。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第二个知识点：</span></span><br><span class="line">    <span class="comment"># async with 调用的不是 __enter__ 和 __exit__，而是 __await__ 和 __aenter__。</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> lock:</span><br><span class="line">        <span class="keyword">if</span> url <span class="keyword">in</span> cache:</span><br><span class="line">            <span class="keyword">return</span> cache[url]</span><br><span class="line">        stuff = <span class="keyword">await</span> aiohttp.request(<span class="string">'GET'</span>,url)</span><br><span class="line">        cache[url] = stuff</span><br><span class="line">        <span class="keyword">return</span> stuff</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">parse_stuff</span><span class="params">()</span>:</span></span><br><span class="line">    stuff = <span class="keyword">await</span> get_stuff()</span><br><span class="line">    <span class="comment"># do some parsing</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">use_stuff</span><span class="params">()</span>:</span></span><br><span class="line">    stuff = <span class="keyword">await</span> get_stuff()</span><br><span class="line">    <span class="comment"># use stuff to do something interesting</span></span><br><span class="line"></span><br><span class="line">tasks = [parse_stuff(), use_stuff()]</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure>
<h3 id="7-1-asyncio-模块中的-Lock-源码分析"><a href="#7-1-asyncio-模块中的-Lock-源码分析" class="headerlink" title="7.1 asyncio 模块中的 Lock 源码分析"></a>7.1 asyncio 模块中的 Lock 源码分析</h3><blockquote>
<p>这个 Lock 调用系统的锁，是程序员级别的锁，因为协程本身不涉及，正如我们之前说过的，协程是一个单线程。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># asyncio 模块中的 Lock 通过自己定义的 self._locked 完成互斥执行一段代码</span></span><br><span class="line"><span class="comment"># 我们之前说过调用 acquire 这些方法的时候，一定不能是阻塞的。</span></span><br><span class="line"><span class="comment"># 在 Lock 的 acquire 方法中，首先创建了 Future，然后将 future 对象放到一个双端队列中，然后执行 yield from fut，之后这个协程会暂停。不理解暂停的需要补充 yield from 的知识。</span></span><br><span class="line"><span class="comment"># 那么问题来了，暂停之后，谁来完成任务的驱动呢？答案是在 release 中。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">acquire</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Acquire a lock.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This method blocks until the lock is unlocked, then sets it to</span></span><br><span class="line"><span class="string">    locked and returns True.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self._locked <span class="keyword">and</span> all(w.cancelled() <span class="keyword">for</span> w <span class="keyword">in</span> self._waiters):</span><br><span class="line">        self._locked = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    fut = self._loop.create_future()</span><br><span class="line">    self._waiters.append(fut)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> fut</span><br><span class="line">        self._locked = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> futures.CancelledError:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._locked:</span><br><span class="line">            self._wake_up_first()</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        self._waiters.remove(fut)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行 acquire 之后，另一个协程在执行 release 方法的时候，会执行 _wake_up_first()。</span></span><br><span class="line"><span class="comment"># 在 _wake_up_first() 会从队列中取出一个 future，也就是从 self._waiters 中取出一个 future，判断这个 future 有没有 done，没有 done 的话，就会直接 set_result。我们之前说过 set_result 会驱动向下执行。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">release</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Release a lock.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    When the lock is locked, reset it to unlocked, and return.</span></span><br><span class="line"><span class="string">    If any other coroutines are blocked waiting for the lock to become</span></span><br><span class="line"><span class="string">    unlocked, allow exactly one of them to proceed.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    When invoked on an unlocked lock, a RuntimeError is raised.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    There is no return value.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> self._locked:</span><br><span class="line">        self._locked = <span class="literal">False</span></span><br><span class="line">        self._wake_up_first()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">'Lock is not acquired.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_wake_up_first</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Wake up the first waiter who isn't cancelled."""</span></span><br><span class="line">    <span class="keyword">for</span> fut <span class="keyword">in</span> self._waiters:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> fut.done():</span><br><span class="line">            fut.set_result(<span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<h3 id="7-2-asyncio-中的-Queue"><a href="#7-2-asyncio-中的-Queue" class="headerlink" title="7.2 asyncio 中的 Queue"></a>7.2 asyncio 中的 Queue</h3><blockquote>
<p>这个 Queue 和多线程中的 Queue 接口一样，<strong>使用 get 和 put 函数的时候，需要在前面加 await</strong>。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, item)</span>:</span></span><br><span class="line">    <span class="string">"""Put an item into the queue.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Put an item into the queue. If the queue is full, wait until a free</span></span><br><span class="line"><span class="string">    slot is available before adding item.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This method is a coroutine.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 判断消息队列是否已满</span></span><br><span class="line">    <span class="comment"># 如果已满，则进入循环</span></span><br><span class="line">    <span class="keyword">while</span> self.full():</span><br><span class="line">        putter = self._loop.create_future()</span><br><span class="line">        <span class="comment"># 将 future 放到队列中</span></span><br><span class="line">        self._putters.append(putter)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 队列已满，执行 yield from</span></span><br><span class="line">            <span class="comment"># 那么暂停了，谁来驱动后面的代码？答案是：有数据取了不为空的 future，看 get 函数。</span></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> putter</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            putter.cancel()  <span class="comment"># Just in case putter is not done yet.</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.full() <span class="keyword">and</span> <span class="keyword">not</span> putter.cancelled():</span><br><span class="line">                <span class="comment"># We were woken up by get_nowait(), but can't take</span></span><br><span class="line">                <span class="comment"># the call.  Wake up the next in line.</span></span><br><span class="line">                self._wakeup_next(self._putters)</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">return</span> self.put_nowait(item)</span><br><span class="line"></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Remove and return an item from the queue.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If queue is empty, wait until an item is available.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This method is a coroutine.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">while</span> self.empty():</span><br><span class="line">        getter = self._loop.create_future()</span><br><span class="line">        self._getters.append(getter)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> getter</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            getter.cancel()  <span class="comment"># Just in case getter is not done yet.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self._getters.remove(getter)</span><br><span class="line">            <span class="keyword">except</span> ValueError:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.empty() <span class="keyword">and</span> <span class="keyword">not</span> getter.cancelled():</span><br><span class="line">                <span class="comment"># We were woken up by put_nowait(), but can't take</span></span><br><span class="line">                <span class="comment"># the call.  Wake up the next in line.</span></span><br><span class="line">                self._wakeup_next(self._getters)</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">    <span class="comment"># 调用 get_nowait</span></span><br><span class="line">    <span class="keyword">return</span> self.get_nowait()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_nowait</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Remove and return an item from the queue.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Return an item if one is immediately available, else raise QueueEmpty.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> self.empty():</span><br><span class="line">        <span class="keyword">raise</span> QueueEmpty</span><br><span class="line">    item = self._get()</span><br><span class="line">    <span class="comment"># 这里的 _wakeup_next 和 Lock 中的类似</span></span><br><span class="line">    <span class="comment"># _putters 是一个队列</span></span><br><span class="line">    self._wakeup_next(self._putters)</span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里的 waiters 就是 _putters，里面放的是 future 对象</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_wakeup_next</span><span class="params">(self, waiters)</span>:</span></span><br><span class="line">    <span class="comment"># Wake up the next waiter (if any) that isn't cancelled.</span></span><br><span class="line">    <span class="keyword">while</span> waiters:</span><br><span class="line">        waiter = waiters.popleft()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> waiter.done():</span><br><span class="line">            <span class="comment"># set_result 会驱动协程的运行，也就是 waiter，而 waiter 就是 putters，putters 也就是前面 def put(self, item) 中的 putter，也就驱动 yield from putter，之后代码会跑到 return self.put_nowait(item)。在 put_nowait 中，将 item 放到 _put 中，之后再驱动 self._wakeup_next(self._getters)。</span></span><br><span class="line">            waiter.set_result(<span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们自己生成一个全局变量 queue 也能达到消息通信的目的，因为协程是一个单线程。但是 asyncio 中的 Queue 实现了 maxsize，当我们想限制流量的时候，这个时候就发挥了作用。如果不需要限流的功能，可以不需要使用 asyncio 中的 Queue。</p>
</blockquote>
<h3 id="aiohttp-简单使用"><a href="#aiohttp-简单使用" class="headerlink" title="aiohttp 简单使用"></a>aiohttp 简单使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(session, url)</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> response.text()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        html = <span class="keyword">await</span> fetch(session, <span class="string">'http://httpbin.org/headers'</span>)</span><br><span class="line">        print(html)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(main())</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># server example</span></span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(request)</span>:</span></span><br><span class="line">    name = request.match_info.get(<span class="string">'name'</span>, <span class="string">"Anonymous"</span>)</span><br><span class="line">    text = <span class="string">"Hello, "</span> + name</span><br><span class="line">    <span class="keyword">return</span> web.Response(text=text)</span><br><span class="line"></span><br><span class="line">app = web.Application()</span><br><span class="line">app.add_routes([web.get(<span class="string">'/'</span>, handle),</span><br><span class="line">                web.get(<span class="string">'/&#123;name&#125;'</span>, handle)])</span><br><span class="line"></span><br><span class="line">web.run_app(app)</span><br></pre></td></tr></table></figure>
<h3 id="8-使用-aiohttp-实现高并发爬虫"><a href="#8-使用-aiohttp-实现高并发爬虫" class="headerlink" title="8. 使用 aiohttp 实现高并发爬虫"></a>8. 使用 aiohttp 实现高并发爬虫</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># asyncio爬虫.去重.入库</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> aiomysql</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery</span><br><span class="line"></span><br><span class="line">start_url = <span class="string">"http://www.jobbole.com/"</span></span><br><span class="line"><span class="comment"># 可是使用 list 做通信，也可以使用 asyncio 中的 Queue 做通信都可以</span></span><br><span class="line">waitting_urls = []</span><br><span class="line"><span class="comment"># 这里使用的 set 做去重。真实的场景不可能使用 set 做去重过滤器的，比如上亿条数据，需要使用布隆过滤器</span></span><br><span class="line">seen_urls = set()</span><br><span class="line">stopping = <span class="literal">False</span></span><br><span class="line"><span class="comment">#限制并发数量</span></span><br><span class="line">sem = asyncio.Semaphore(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(url, session)</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> sem:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> resp:</span><br><span class="line">                print(<span class="string">"url status: &#123;&#125;"</span>.format(resp.status))</span><br><span class="line">                <span class="keyword">if</span> resp.status <span class="keyword">in</span> [<span class="number">200</span>,<span class="number">201</span>]:</span><br><span class="line">                    data = <span class="keyword">await</span> resp.text()</span><br><span class="line">                    <span class="keyword">return</span> data</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_urls</span><span class="params">(html)</span>:</span></span><br><span class="line">    urls = []</span><br><span class="line">    pq = PyQuery(html)</span><br><span class="line">    <span class="keyword">for</span> link <span class="keyword">in</span> pq.items(<span class="string">"a"</span>):</span><br><span class="line">        url = link.attr(<span class="string">"href"</span>)</span><br><span class="line">        <span class="keyword">if</span> url <span class="keyword">and</span> url.startswith(<span class="string">"http"</span>) <span class="keyword">and</span> url <span class="keyword">not</span> <span class="keyword">in</span> seen_urls:</span><br><span class="line">            urls.append(url)</span><br><span class="line">            waitting_urls.append(url)</span><br><span class="line">    <span class="keyword">return</span> urls</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">init_urls</span><span class="params">(url, session)</span>:</span></span><br><span class="line">    html = <span class="keyword">await</span> fetch(url, session)</span><br><span class="line">    seen_urls.add(url)</span><br><span class="line">    extract_urls(html)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">article_handler</span><span class="params">(url, session, pool)</span>:</span></span><br><span class="line">    <span class="comment"># 获取文章详情并解析入库</span></span><br><span class="line">    html = <span class="keyword">await</span> fetch(url, session)</span><br><span class="line">    seen_urls.add(url)</span><br><span class="line">    extract_urls(html)</span><br><span class="line">    pq = PyQuery(html)</span><br><span class="line">    title = pq(<span class="string">"title"</span>).text()</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> pool.acquire() <span class="keyword">as</span> conn:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cur:</span><br><span class="line">            <span class="keyword">await</span> cur.execute(<span class="string">"SELECT 42;"</span>)</span><br><span class="line">            insert_sql = <span class="string">"insert into article_test(title) values('&#123;&#125;')"</span>.format(title)</span><br><span class="line">            <span class="keyword">await</span> cur.execute(insert_sql)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(pool)</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> stopping:</span><br><span class="line">            <span class="keyword">if</span> len(waitting_urls) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">await</span> asyncio.sleep(<span class="number">0.5</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            url = waitting_urls.pop()</span><br><span class="line">            print(<span class="string">"start get url: &#123;&#125;"</span>.format(url))</span><br><span class="line">            <span class="keyword">if</span> re.match(<span class="string">"http://.*?jobbole.com/\d+/"</span>, url):</span><br><span class="line">                <span class="keyword">if</span> url <span class="keyword">not</span> <span class="keyword">in</span> seen_urls:</span><br><span class="line">                    asyncio.ensure_future(article_handler(url, session, pool))</span><br><span class="line">                    <span class="keyword">await</span> asyncio.sleep(<span class="number">30</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> url <span class="keyword">not</span> <span class="keyword">in</span> seen_urls:</span><br><span class="line">                    asyncio.ensure_future(init_urls(url, session))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(loop)</span>:</span></span><br><span class="line">    <span class="comment">#等待连接mysql</span></span><br><span class="line">    <span class="comment"># charset='utf8' 如果不设置，在插入中文的时候，不会报错，但是库中没有数据</span></span><br><span class="line">    <span class="comment"># autocommit=True 需要设置，否则库中没有数据</span></span><br><span class="line">    pool = <span class="keyword">await</span> aiomysql.create_pool(host=<span class="string">"127.0.0.1"</span>, port=<span class="number">3306</span>,</span><br><span class="line">                                      user=<span class="string">'root'</span>,password=<span class="string">'jinhua2018'</span>,</span><br><span class="line">                                      db=<span class="string">'mysql'</span>,loop=loop,</span><br><span class="line">                                      charset=<span class="string">'utf8'</span>,autocommit=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        html = <span class="keyword">await</span> fetch(start_url, session)</span><br><span class="line">        seen_urls.add(start_url)</span><br><span class="line">        extract_urls(html)</span><br><span class="line">    asyncio.ensure_future(consumer(pool))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    asyncio.ensure_future(main(loop))</span><br><span class="line">    loop.run_forever()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>asyncio</tag>
      </tags>
  </entry>
  <entry>
    <title>python 内建模块 datetime</title>
    <url>/2017/06/01/python-datetime-time/</url>
    <content><![CDATA[<h4 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">now = datetime.now() <span class="comment"># 获取当前datetime</span></span><br><span class="line">print(now) <span class="comment"># 2020-05-20 22:07:36.825986</span></span><br><span class="line">print(type(now))  <span class="comment"># &lt;class 'datetime.datetime'&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>datetime.now()</code>返回当前日期和时间，其类型是<code>datetime</code></p>
</blockquote>
<a id="more"></a>
<h4 id="str—-gt-datetime-类型"><a href="#str—-gt-datetime-类型" class="headerlink" title="str—&gt; datetime 类型"></a>str—&gt; datetime 类型</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dt = datetime.strptime(<span class="string">"2017-06-01 11:11:40"</span>, <span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br><span class="line">print(dt) <span class="comment"># 2017-06-01 11:11:40</span></span><br><span class="line">print(type(dt)) <span class="comment"># &lt;class 'datetime.datetime'&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="datetime-—-gt-str"><a href="#datetime-—-gt-str" class="headerlink" title="datetime —&gt; str"></a>datetime —&gt; str</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line">now = datetime.now()</span><br><span class="line">print(now.strftime(<span class="string">'%a, %b %d %H:%M'</span>))  <span class="comment"># Wed, May 20 22:23</span></span><br><span class="line">print(now.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>)) <span class="comment"># 2020-05-20 22:23:46</span></span><br></pre></td></tr></table></figure>
<h4 id="datetime类型—-gt-timestamp类型"><a href="#datetime类型—-gt-timestamp类型" class="headerlink" title="datetime类型—&gt; timestamp类型"></a>datetime类型—&gt; timestamp类型</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dt = datetime.strptime(<span class="string">"2018-11-15 15:32:12"</span>, <span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br><span class="line">print(dt) <span class="comment"># 2018-11-15 15:32:12</span></span><br><span class="line">print(type(dt)) <span class="comment"># &lt;class 'datetime.datetime'&gt;</span></span><br><span class="line">print(dt.timestamp())  <span class="comment"># 1542267132.0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意Python的timestamp是一个浮点数。如果有小数位，小数位表示毫秒数</p>
</blockquote>
<h4 id="timestamp类型—-gt-datetime类型"><a href="#timestamp类型—-gt-datetime类型" class="headerlink" title="timestamp类型—&gt;datetime类型"></a>timestamp类型—&gt;datetime类型</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line">t = <span class="number">1542267132.0</span></span><br><span class="line">print(datetime.fromtimestamp(t))  <span class="comment"># 本地时间</span></span><br><span class="line">print(datetime.utcfromtimestamp(t)) <span class="comment"># UTC时间</span></span><br></pre></td></tr></table></figure>
<h4 id="datetime加减"><a href="#datetime加减" class="headerlink" title="datetime加减"></a>datetime加减</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime,timedelta</span><br><span class="line">now = datetime.now()</span><br><span class="line">print(now + timedelta(hours=<span class="number">10</span>))</span><br><span class="line">print(now - timedelta(days=<span class="number">1</span>)) </span><br><span class="line">print(now + timedelta(days=<span class="number">2</span>, hours=<span class="number">12</span>))</span><br><span class="line">print((now - timedelta(days=<span class="number">1</span>)).strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用<code>timedelta</code>你可以很容易地算出前几天和后几天的时刻</p>
</blockquote>
<h4 id="时区转换"><a href="#时区转换" class="headerlink" title="时区转换"></a>时区转换</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta, timezone</span><br><span class="line">utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc) <span class="comment"># 拿到UTC时间，并强制设置时区为UTC+0:00:</span></span><br><span class="line">print(datetime.utcnow())</span><br><span class="line">print(utc_dt)</span><br><span class="line">bj_dt = utc_dt.astimezone(timezone(timedelta(hours=<span class="number">8</span>)))  <span class="comment">#  astimezone()将转换时区为北京时间:</span></span><br><span class="line">print(bj_dt)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>datetime</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>datetime</tag>
      </tags>
  </entry>
  <entry>
    <title>python -- 类和对象</title>
    <url>/2019/06/10/python-class-object-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h3 id="1-类"><a href="#1-类" class="headerlink" title="1. 类"></a>1. 类</h3><blockquote>
<p>和 Java 一样，所有类都默认继承 object，object 是最顶层的父类。</p>
</blockquote>
<h3 id="1-1-实例属性和类属性"><a href="#1-1-实例属性和类属性" class="headerlink" title="1.1 实例属性和类属性"></a>1.1 实例属性和类属性</h3><blockquote>
<p>实例属性通过 self 关键字定义，类属性没有 self 修饰，直接写在类中。<strong>类属性一定要通过类名调用，不要使用对象名调用。</strong>例子如下：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    aa = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">a = A(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">A.aa = <span class="number">11</span></span><br><span class="line">a.aa = <span class="number">100</span></span><br><span class="line">print(a.x, a.y, a.aa)</span><br><span class="line">print(A.aa)</span><br><span class="line"></span><br><span class="line">b = A(<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line">print(b.aa)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="1-2-私有属性和私有方法"><a href="#1-2-私有属性和私有方法" class="headerlink" title="1.2 私有属性和私有方法"></a>1.2 私有属性和私有方法</h3><blockquote>
<p>Python 中没有 private 关键字，属性或方法的私有都是通过双下划线完成的。定义为私有的属性和方法不能被子类继承。<br>题外话，Python 中会将双下划线修饰的属性变形为 <em>类名_</em>属性名 这种命名方式，如果主动使用这种方式也可以调用到想要的属性，但是开发中不要这样做，调用私有属性需要通过提供的 getter 和 setter 方法</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> class_method <span class="keyword">import</span> Date</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, birthday)</span>:</span></span><br><span class="line">        self.__birthday = birthday</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#返回年龄</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2018</span> - self.__birthday.year</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    user = User(Date(<span class="number">1990</span>,<span class="number">2</span>,<span class="number">1</span>))</span><br><span class="line">    print(user._User__birthday)</span><br><span class="line">    print(user.get_age())</span><br></pre></td></tr></table></figure>
<h3 id="1-3-构造函数"><a href="#1-3-构造函数" class="headerlink" title="1.3 构造函数"></a>1.3 构造函数</h3><blockquote>
<p>构造函数通过 <strong>init</strong> 方法定义。例子如下：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>:</span></span><br><span class="line">    <span class="comment"># 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, year, month, day)</span>:</span></span><br><span class="line">        self.year = year</span><br><span class="line">        self.month = month</span><br><span class="line">        self.day = day</span><br></pre></td></tr></table></figure>
<h2 id="1-4-获取类或者对象的内部结构"><a href="#1-4-获取类或者对象的内部结构" class="headerlink" title="1.4 获取类或者对象的内部结构"></a>1.4 获取类或者对象的内部结构</h2><ol>
<li>方法一：<strong>dict</strong> 能够获取类或者对象的内部结构。</li>
<li>方法二：使用 dir 内置函数，这种方式更加强大。</li>
</ol>
<blockquote>
<p>例子如下：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>:</span></span><br><span class="line">    <span class="comment"># 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, year, month, day)</span>:</span></span><br><span class="line">        self.year = year</span><br><span class="line">        self.month = month</span><br><span class="line">        self.day = day</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, birthday)</span>:</span></span><br><span class="line">        self.__birthday = birthday</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#返回年龄</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2018</span> - self.__birthday.year</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(Date(<span class="number">1990</span>,<span class="number">2</span>,<span class="number">1</span>))</span><br><span class="line">    user = User(Date(<span class="number">1990</span>,<span class="number">2</span>,<span class="number">1</span>))</span><br><span class="line">    print(user._User__birthday)</span><br><span class="line">    print(user.get_age())</span><br></pre></td></tr></table></figure>
<h3 id="1-5-判断一个对象是否具有某个属性"><a href="#1-5-判断一个对象是否具有某个属性" class="headerlink" title="1.5 判断一个对象是否具有某个属性"></a>1.5 判断一个对象是否具有某个属性</h3><blockquote>
<p>hasattr 方法</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#我们去检查某个类是否有某种方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, employee_list)</span>:</span></span><br><span class="line">        self.employee = employee_list</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.employee)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">com = Company([<span class="string">"bobby1"</span>,<span class="string">"bobby2"</span>])</span><br><span class="line">print(hasattr(com, <span class="string">"__len__"</span>))</span><br></pre></td></tr></table></figure>
<h3 id="静态方法、类方法、对象方法以及参数"><a href="#静态方法、类方法、对象方法以及参数" class="headerlink" title="静态方法、类方法、对象方法以及参数"></a>静态方法、类方法、对象方法以及参数</h3><ul>
<li>静态方法：<ul>
<li>格式：在方法上面添加 @staticmethod</li>
<li>参数：静态方法可以有参数也可以无参数</li>
<li>应用场景：一般用于和类对象以及实例对象无关的代码。</li>
<li>使用方式： 类名.类方法名(或者对象名.类方法名)。</li>
</ul>
</li>
<li>类方法：<ul>
<li>在方法上面添加@classmethod</li>
<li>方法的参数为 cls 也可以是其他名称，但是一般默认为cls</li>
<li>cls 指向 类对象</li>
<li>应用场景：当一个方法中只涉及到静态属性的时候可以使用类方法(类方法用来修改类属性)。</li>
<li>使用可以是 对象名.类方法名。或者是 类名.类方法名</li>
</ul>
</li>
<li>实例方法：又叫对象方法，指类中定义的普通方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>:</span></span><br><span class="line">    <span class="comment"># 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, year, month, day)</span>:</span></span><br><span class="line">        self.year = year</span><br><span class="line">        self.month = month</span><br><span class="line">        self.day = day</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tomorrow</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.day += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_from_string</span><span class="params">(date_str)</span>:</span></span><br><span class="line">        year, month, day = tuple(date_str.split(<span class="string">"-"</span>))</span><br><span class="line">        <span class="keyword">return</span> Date(int(year), int(month), int(day))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">valid_str</span><span class="params">(date_str)</span>:</span></span><br><span class="line">        year, month, day = tuple(date_str.split(<span class="string">"-"</span>))</span><br><span class="line">        <span class="keyword">if</span> int(year) &gt; <span class="number">0</span> <span class="keyword">and</span> (int(month) &gt; <span class="number">0</span> <span class="keyword">and</span> int(month) &lt;= <span class="number">12</span>) <span class="keyword">and</span> (int(day) &gt; <span class="number">0</span> <span class="keyword">and</span> int(day) &lt;= <span class="number">31</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_string</span><span class="params">(cls, date_str)</span>:</span></span><br><span class="line">        year, month, day = tuple(date_str.split(<span class="string">"-"</span>))</span><br><span class="line">        <span class="keyword">return</span> cls(int(year), int(month), int(day))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;year&#125;/&#123;month&#125;/&#123;day&#125;"</span>.format(year=self.year, month=self.month, day=self.day)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    new_day = Date(<span class="number">2018</span>, <span class="number">12</span>, <span class="number">31</span>)</span><br><span class="line">    new_day.tomorrow()</span><br><span class="line">    print(new_day)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2018-12-31</span></span><br><span class="line">    date_str = <span class="string">"2018-12-31"</span></span><br><span class="line">    year, month, day = tuple(date_str.split(<span class="string">"-"</span>))</span><br><span class="line">    new_day = Date(int(year), int(month), int(day))</span><br><span class="line">    print(new_day)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用staticmethod完成初始化</span></span><br><span class="line">    new_day = Date.parse_from_string(date_str)</span><br><span class="line">    print(new_day)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用classmethod完成初始化</span></span><br><span class="line">    new_day = Date.from_string(date_str)</span><br><span class="line">    print(new_day)</span><br><span class="line"></span><br><span class="line">    print(Date.valid_str(<span class="string">"2018-12-32"</span>))</span><br></pre></td></tr></table></figure>
<h3 id="2-继承-inheritance"><a href="#2-继承-inheritance" class="headerlink" title="2. 继承 inheritance"></a>2. 继承 inheritance</h3><h3 id="2-1-继承的实现"><a href="#2-1-继承的实现" class="headerlink" title="2.1 继承的实现"></a>2.1 继承的实现</h3><blockquote>
<p>Python 的继承不需要关键字，只需要在类名后面直接添加父类名称即可。例子如下：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"A"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"B"</span>)</span><br><span class="line">        super().__init__()</span><br></pre></td></tr></table></figure>
<h3 id="2-2-判断对象是否是一个类的实例"><a href="#2-2-判断对象是否是一个类的实例" class="headerlink" title="2.2 判断对象是否是一个类的实例"></a>2.2 判断对象是否是一个类的实例</h3><blockquote>
<p>Python 中提供了 isinstance 关键字完成这一需求，类似于 Java 中 instanceof 关键字。不要使用 type 配合 is 关键字的方式。 isintance 会查找继承链，而 is 不会，is 只判断对象是否指向同一个内存地址。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">b = B()</span><br><span class="line"></span><br><span class="line">print(isinstance(b, B))</span><br><span class="line">print(isinstance(b, A))</span><br><span class="line"></span><br><span class="line">print(type(b) <span class="keyword">is</span> A)</span><br></pre></td></tr></table></figure>
<h3 id="2-3-super-真的是调用父类吗？（重点）"><a href="#2-3-super-真的是调用父类吗？（重点）" class="headerlink" title="2.3 super 真的是调用父类吗？（重点）"></a>2.3 super 真的是调用父类吗？（重点）</h3><blockquote>
<p>答案：不是，super 调用的是 <strong>mro</strong> 函数的下一个类的构造函数。MRO 全称 Method Resolution Order。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"B"</span>)</span><br><span class="line">        super().__init__()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"C"</span>)</span><br><span class="line">        super().__init__()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B, C)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"D"</span>)</span><br><span class="line">        super(D, self).__init__()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(D.__mro__)</span><br><span class="line">    d = D()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于 Python 允许多继承，多继承会存在菱形继承问题，会出现如下两种类型：<br>类型一：</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20190508113158612.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215b25lbG90dXM=,size_16,color_FFFFFF,t_70" alt=""></p>
<blockquote>
<p>上图中，A 同时继承 B 和 C，B 和 C 又都继承 D，假设 C 覆盖了 D 中的某个方法，记该方法为 M。在 Python 2 的非常早期版本中使用的是 DFS 方法搜索类的方法继承关系，使用 DFS 方法将导致 A 类的对象始终无法调用 C 类中重写的方法 M，调用的始终是 D 类中原始的方法 M。为了解决这个问题，Python 后来将 DFS 算法更新为 BFS 算法，广度优先搜索算法虽然能解决类型一的继承问题，但是却解决不了类型二这种情形。<br>类型二：</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20190508113648949.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215b25lbG90dXM=,size_16,color_FFFFFF,t_70" alt=""></p>
<blockquote>
<p>上图中，A 同时继承类 B 和 C，B 和 C 又分别继承 D 和 E 类，假设 D 类和 C 类中有同名方法 M。如果使用 BFS 方法会导致 A 类的对象依然会调用 C 类中的 M 方法，而这就导致了错误调用。正确的调用应该是 D 类中的 M 方法，因为 A 首先继承 B 类，B 类中存在它从 D 类中继承过来的方法 M，应该返回的调用方法是 B 类从 D 类继承而来的方法，而不是 C 类中的方法 M。<br>Python 现在的算法采用的是 C3 算法，解决了上述的两种菱形继承问题。</p>
</blockquote>
<h3 id="2-4-mixin-模式"><a href="#2-4-mixin-模式" class="headerlink" title="2.4 mixin 模式"></a>2.4 mixin 模式</h3><p>django rest framework中对多继承使用的经验</p>
<blockquote>
<p>尽管 Python 支持多继承，但是通常都不建议使用多继承方式。如果有多继承需求，通常采用 mixin 模式解决。<br>mixin模式特点:</p>
</blockquote>
<ol>
<li>Mixin类功能单一</li>
<li>不和基类关联，可以和任意基类组合，基类可以不和mixin关联就能初始化成功</li>
<li>在mixin中不要使用super这种用法</li>
<li>使用<strong>bases</strong>将需要继承的类组合在一起</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mixin</span><span class="params">(pyClass, pyMixinClass, key=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> key:</span><br><span class="line">        pyClass.__bases__ = (pyMixinClass,) + pyClass.__bases__</span><br><span class="line">    <span class="keyword">elif</span> pyMixinClass <span class="keyword">not</span> <span class="keyword">in</span> pyClass.__bases__:</span><br><span class="line">        pyClass.__bases__ += (pyMixinClass,)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test1</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'In the test1 class!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testMixin</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'In the testMixin class!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test2</span><span class="params">(test1, testMixin)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'In the test2 class!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test0</span><span class="params">(test1)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(test0.__mro__)  <span class="comment"># 继承了test1，object</span></span><br><span class="line">    test_0 = test0()</span><br><span class="line">    test_0.test()  <span class="comment"># 调用test1的方法</span></span><br><span class="line">    mixin(test0, testMixin, <span class="number">1</span>)  <span class="comment"># 优先继承testMixin类</span></span><br><span class="line">    test__0 = test0()</span><br><span class="line">    test__0.test()  <span class="comment"># 由于优先继承了testMixin类，所以调用testMixin类的方法</span></span><br><span class="line">    print(test0.__mro__)</span><br><span class="line"></span><br><span class="line">    print(test2.__mro__)</span><br><span class="line">    mixin(test2, testMixin)     <span class="comment"># test2中已经继承了testMixin</span></span><br><span class="line">    print(test2.__mro__)</span><br></pre></td></tr></table></figure>
<h3 id="11-python中的with语句"><a href="#11-python中的with语句" class="headerlink" title="11.python中的with语句"></a>11.python中的with语句</h3><p>普通的try…finally语句的调用流程：</p>
<ul>
<li>如果无异常：try-&gt;else-&gt;finally<ul>
<li>finally中有return，则调用finally中的return</li>
<li>finally中无return<ul>
<li>try中有return，则调用try中return</li>
<li>try中无return，则调用else中的return</li>
</ul>
</li>
</ul>
</li>
<li>如果有异常：try-&gt;except-&gt;finally<ul>
<li>finally中有return，则调用finally中的return</li>
<li>finally中无return，则调用except中的return</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># try except finally</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exe_try</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(<span class="string">"code started"</span>)</span><br><span class="line">        <span class="comment"># raise KeyError</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">except</span> KeyError <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"key error"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"other error"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        print(<span class="string">"finally"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    result = exe_try()   </span><br><span class="line">    print(result)　　<span class="comment"># 4</span></span><br></pre></td></tr></table></figure>
<p>上下文管理器协议：with</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">上下文管理器协议：<span class="keyword">with</span></span><br><span class="line">两个魔法函数：__enter__、__exit__</span><br><span class="line">    __enter__：进入时执行，用于获取资源</span><br><span class="line">    __exit__：结束时执行，用于释放资源</span><br><span class="line"><span class="comment"># 上下文管理器协议</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"enter"</span>)</span><br><span class="line">        <span class="comment"># 获取资源</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">        <span class="comment"># 释放资源</span></span><br><span class="line">        print(<span class="string">"exit"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_something</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"doing something"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Sample() <span class="keyword">as</span> sample:</span><br><span class="line">    sample.do_something()   <span class="comment"># enter, doing something, exit</span></span><br></pre></td></tr></table></figure>
<h3 id="contextlib简化上下文管理器"><a href="#contextlib简化上下文管理器" class="headerlink" title="contextlib简化上下文管理器"></a>contextlib简化上下文管理器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>将__enter__、__exit__以及中间处理函数都整合到一个函数中</span><br><span class="line"><span class="number">2.</span><span class="keyword">yield</span>：中间处理函数</span><br><span class="line"><span class="number">3.</span>使用装饰器：@contextlib.contextmanager</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextlib.contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file_open</span><span class="params">(file_name)</span>:</span></span><br><span class="line">    print(<span class="string">"file open"</span>)</span><br><span class="line">    <span class="keyword">yield</span> &#123;&#125;</span><br><span class="line">    print(<span class="string">"file end"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> file_open(<span class="string">"bobby.txt"</span>) <span class="keyword">as</span> f_opened:</span><br><span class="line">    print(<span class="string">"file processing"</span>)  <span class="comment"># file open, file processing, file end</span></span><br></pre></td></tr></table></figure>
<h3 id="3-多态-polymorphism"><a href="#3-多态-polymorphism" class="headerlink" title="3. 多态 polymorphism"></a>3. 多态 polymorphism</h3><h3 id="3-1-多态"><a href="#3-1-多态" class="headerlink" title="3.1 多态"></a>3.1 多态</h3><blockquote>
<p>在 Java 语言中，多态的实现是类之间必须继承关系，将子类实例化的对象赋值给父类，从而实现多态。而在 Python 语言中，不需要继承关系，<strong>类之间只需要有共同的方法</strong>即可，也就是所谓的鸭子类型。注意仔细体会下面的例子：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"i am a cat"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"i am a fish"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"i am a duck"</span>)</span><br><span class="line"></span><br><span class="line">animal_list = [Cat, Dog, Duck]</span><br><span class="line"><span class="keyword">for</span> animal <span class="keyword">in</span> animal_list:</span><br><span class="line">    animal().say()</span><br></pre></td></tr></table></figure>
<h3 id="3-2-鸭子类型（在定义一个类时-有共同的方法）"><a href="#3-2-鸭子类型（在定义一个类时-有共同的方法）" class="headerlink" title="3.2 鸭子类型（在定义一个类时 有共同的方法）"></a>3.2 鸭子类型（在定义一个类时 有共同的方法）</h3><blockquote>
<p>理解了上面的例子，我们来进一步理解鸭子类型。鸭子类型贯穿了 Python 语言的始终，关系到整个语言面向对象的设计理念。当我们定义了一个类之后，只要实现了魔法函数（以双下划线开始和结束的方法）， Python 就可以识别出来，进而产生多态。下面的 Company 类实现了 getitem 和 len，故而可以被当做是一个 iteratable 类型。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"cat"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"dog"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"duck"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">animal_list = [Cat, Dog, Duck]</span><br><span class="line"><span class="keyword">for</span> animal <span class="keyword">in</span> animal_list:</span><br><span class="line">    animal().say()      <span class="comment"># cat dog duck，具有多态性</span></span><br><span class="line">a = [<span class="string">"bobby1"</span>, <span class="string">"bobby2"</span>]</span><br><span class="line"></span><br><span class="line">b = [<span class="string">"bobby2"</span>, <span class="string">"bobby"</span>]</span><br><span class="line">name_tuple = [<span class="string">"bobby3"</span>, <span class="string">"bobby4"</span>]</span><br><span class="line">name_set = set()</span><br><span class="line">name_set.add(<span class="string">"bobby5"</span>)</span><br><span class="line">name_set.add(<span class="string">"bobby6"</span>)</span><br><span class="line">a.extend(name_set) <span class="comment"># 由于extend 中可以接收iterable类型，所以传递name_tuple，name_set，b都是可以的，这些都是iterable类型</span></span><br><span class="line">print(a)</span><br><span class="line">---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, employee_list)</span>:</span></span><br><span class="line">        self.employee = employee_list</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.employee[item]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.employee)</span><br><span class="line"></span><br><span class="line">company = Company([<span class="string">"tom"</span>, <span class="string">"bob"</span>, <span class="string">"jane"</span>])</span><br><span class="line"></span><br><span class="line">dog = Dog()</span><br><span class="line">a = [<span class="string">"bobby1"</span>, <span class="string">"bobby2"</span>]</span><br><span class="line"></span><br><span class="line">b = [<span class="string">"bobby2"</span>, <span class="string">"bobby"</span>]</span><br><span class="line">name_tuple = [<span class="string">"bobby3"</span>, <span class="string">"bobby4"</span>]</span><br><span class="line">name_set = set()</span><br><span class="line">name_set.add(<span class="string">"bobby5"</span>)</span><br><span class="line">name_set.add(<span class="string">"bobby6"</span>)</span><br><span class="line">a.extend(company) <span class="comment"># 。。。。。</span></span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<h3 id="4-抽象基类"><a href="#4-抽象基类" class="headerlink" title="4. 抽象基类"></a>4. 抽象基类</h3><blockquote>
<p>通过前面的学习，我们知道 Python 语言的多态都是围绕鸭子类型设计的，并不需要继承某一父类，只需要实现特定的方法即可，那么为什么还会有抽象基类这一概念呢？这一问题的答案，我们通过两个需求来说明。</p>
</blockquote>
<ol>
<li>判断一个对象是否是一个类的实例</li>
<li>强制某个子类必须实现某些方法</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#我们去检查某个类是否有某种方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, employee_list)</span>:</span></span><br><span class="line">        self.employee = employee_list</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.employee)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">com = Company([<span class="string">"bobby1"</span>,<span class="string">"bobby2"</span>])</span><br><span class="line">print(hasattr(com, <span class="string">"__len__"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#我们在某些情况之下希望判定某个对象的类型</span></span><br><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Sized</span><br><span class="line">isinstance(com, Sized)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当子类调用 set 方法时，就会报错。<strong>但是，这种方式的缺点是必须调用时才会报错。</strong>如果想实例化时，没有实现特定的方法就报错呢？此时就需要使用 Python 的 abc 模块。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CacheBase</span><span class="params">(metaclass=abc.ABCMeta)</span>:</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisCache</span><span class="params">(CacheBase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        print(<span class="string">"get"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        print(<span class="string">"set"</span>)</span><br><span class="line"></span><br><span class="line">redis_cache = RedisCache()</span><br><span class="line">redis_cache.set(<span class="string">"name"</span>, <span class="string">"wzh"</span>)  <span class="comment"># set</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>class object</tag>
      </tags>
  </entry>
  <entry>
    <title>pyminizip -- 压缩加密文件 简单使用</title>
    <url>/2020/05/09/python-compress-file/</url>
    <content><![CDATA[<h3 id="使用pyminizip压缩加密文件"><a href="#使用pyminizip压缩加密文件" class="headerlink" title="使用pyminizip压缩加密文件"></a>使用pyminizip压缩加密文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyminizip</span><br><span class="line"><span class="comment"># 压缩</span></span><br><span class="line">compression_level = <span class="number">5</span> <span class="comment"># 1-9</span></span><br><span class="line">pyminizip.compress(<span class="string">"record.db"</span>, <span class="literal">None</span>, <span class="string">"dst.zip"</span>, <span class="string">"password"</span>, compression_level)</span><br><span class="line"><span class="comment"># 解压缩</span></span><br><span class="line"><span class="keyword">import</span> pyminizip</span><br><span class="line">pyminizip.uncompress(<span class="string">"dst.zip"</span>, <span class="string">"password"</span>, <span class="string">"./"</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考：</p>
<p><a href="https://github.com/smihica/pyminizip" target="_blank" rel="noopener">https://github.com/smihica/pyminizip</a></p>
<p><a href="https://stackoverflow.com/questions/17250/create-an-encrypted-zip-file-in-python/40164739" target="_blank" rel="noopener">https://stackoverflow.com/questions/17250/create-an-encrypted-zip-file-in-python/40164739</a></p>
<p><a href="https://stackoverflow.com/questions/59437912/how-do-i-create-a-temporary-zip-in-python-3-x-using-pyminizip" target="_blank" rel="noopener">https://stackoverflow.com/questions/59437912/how-do-i-create-a-temporary-zip-in-python-3-x-using-pyminizip</a></p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
        <category>pyminizip</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pyminizip</tag>
      </tags>
  </entry>
  <entry>
    <title>python -- 序列类</title>
    <url>/2019/06/12/python-kafka/</url>
    <content><![CDATA[<h4 id="kafka-python的安装"><a href="#kafka-python的安装" class="headerlink" title="kafka-python的安装"></a>kafka-python的安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 -m pip install kafka-python</span><br><span class="line">pipenv install kafka-python</span><br></pre></td></tr></table></figure>
<h4 id="kafka-python的基本使用"><a href="#kafka-python的基本使用" class="headerlink" title="kafka-python的基本使用"></a>kafka-python的基本使用</h4><h2 id="KafkaConsumer"><a href="#KafkaConsumer" class="headerlink" title="KafkaConsumer"></a>KafkaConsumer</h2><h5 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaConsumer</span><br><span class="line"></span><br><span class="line">consumer = KafkaConsumer(<span class="string">"first"</span>, bootstrap_servers=[<span class="string">'192.168.1.86:9092'</span>,<span class="string">'192.168.1.86:9093'</span>,<span class="string">'192.168.1.86:9094'</span>], consumer_timeout_ms=<span class="number">1000</span>)  <span class="comment"># 连接kafka</span></span><br><span class="line"><span class="keyword">for</span> msg <span class="keyword">in</span> consumer:</span><br><span class="line">    print(msg)</span><br><span class="line"><span class="comment"># consumer_timeout_ms（ms毫秒）(非必选)</span></span><br><span class="line"><span class="comment"># 默认会一直等待，若指定则超时返回，不在等待</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h5 id="消费端-加入消费者组"><a href="#消费端-加入消费者组" class="headerlink" title="消费端-加入消费者组"></a>消费端-加入消费者组</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaConsumer</span><br><span class="line"></span><br><span class="line">consumer = KafkaConsumer(<span class="string">'first'</span>, group_id= <span class="string">'group1'</span>, bootstrap_servers= [[<span class="string">'192.168.1.86:9092'</span>,<span class="string">'192.168.1.86:9093'</span>,<span class="string">'192.168.1.86:9094'</span>])</span><br><span class="line"><span class="keyword">for</span> msg <span class="keyword">in</span> consumer:</span><br><span class="line">    print(msg)</span><br></pre></td></tr></table></figure>
<h5 id="消费者-手动分配分区"><a href="#消费者-手动分配分区" class="headerlink" title="消费者-手动分配分区"></a>消费者-手动分配分区</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaConsumer</span><br><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> TopicPartition</span><br><span class="line"></span><br><span class="line">consumer = KafkaConsumer(group_id= <span class="string">'group1'</span>, bootstrap_servers= [<span class="string">'192.168.1.86:9092'</span>,<span class="string">'192.168.1.86:9093'</span>,<span class="string">'192.168.1.86:9094'</span>])</span><br><span class="line">consumer.assign([TopicPartition(topic= <span class="string">'first'</span>, partition= <span class="number">2</span>)])</span><br><span class="line"><span class="keyword">for</span> msg <span class="keyword">in</span> consumer:</span><br><span class="line">    print(msg)</span><br></pre></td></tr></table></figure>
<h5 id="消费者-订阅多个topic"><a href="#消费者-订阅多个topic" class="headerlink" title="消费者-订阅多个topic"></a>消费者-订阅多个topic</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaConsumer</span><br><span class="line"></span><br><span class="line">consumer = KafkaConsumer(group_id= <span class="string">'group1'</span>, bootstrap_servers= [<span class="string">'192.168.1.86:9092'</span>,<span class="string">'192.168.1.86:9093'</span>,<span class="string">'192.168.1.86:9094'</span>])</span><br><span class="line">consumer.subscribe(topics= [<span class="string">'my_topic'</span>, <span class="string">'topic_1'</span>])</span><br><span class="line"><span class="comment"># 或者使用正则</span></span><br><span class="line"><span class="comment"># consumer.subscribe(pattern= '^my.*')</span></span><br><span class="line"><span class="keyword">for</span> msg <span class="keyword">in</span> consumer:</span><br><span class="line">    print(msg)</span><br></pre></td></tr></table></figure>
<h5 id="消费者-msgpack消息"><a href="#消费者-msgpack消息" class="headerlink" title="消费者-msgpack消息"></a>消费者-msgpack消息</h5><blockquote>
<p>MessagePack 是一个二进制序列化格式，多语言间数据转换</p>
<p>比json快，序列化结果比json小</p>
<p><a href="https://msgpack.org/" target="_blank" rel="noopener">https://msgpack.org/</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaConsumer</span><br><span class="line">consumer = KafkaConsumer(<span class="string">'first'</span>, group_id= <span class="string">'group1'</span>, bootstrap_servers= [[<span class="string">'192.168.1.86:9092'</span>,<span class="string">'192.168.1.86:9093'</span>,<span class="string">'192.168.1.86:9094'</span>],value_deserializer=msgpack.loads)</span><br><span class="line">consumer.subscribe([<span class="string">'msgpackfoo'</span>])</span><br><span class="line"><span class="keyword">for</span> msg <span class="keyword">in</span> consumer:</span><br><span class="line">    print(msg)</span><br></pre></td></tr></table></figure>
<h5 id="消费者-earliest和latest"><a href="#消费者-earliest和latest" class="headerlink" title="消费者-earliest和latest"></a>消费者-earliest和latest</h5><blockquote>
<p><code>auto_offset_reset</code>这个参数，只有在一个<code>group</code>第一次运行的时候才有作用，从第二次运行开始，这个参数就失效了。</p>
<p>假设现在你的 Topic 里面有100个数据，你设置了一个全新的 group_id 为<code>test2</code>。<code>auto_offset_reset</code>设置为 <code>earliest</code>。那么当你的消费者运行的时候，Kafka 会先把你的 offset 设置为0，然后让你从头开始消费的。</p>
<p>假设现在你的 Topic 里面有100个数据，你设置了一个全新的 group_id 为<code>test3</code>。<code>auto_offset_reset</code>设置为 <code>latest</code>。那么当你的消费者运行的时候，Kafka 不会给你返回任何数据，消费者看起来就像卡住了一样，但是 Kafka 会直接强制把前100条数据的状态设置为已经被你消费的状态。所以当前你的 offset 就直接是99了。直到生产者插入了一条新的数据，此时消费者才能读取到。这条新的数据对应的 offset 就变成了100。</p>
<p>假设现在你的 Topic 里面有100个数据，你设置了一个全新的 group_id 为<code>test4</code>。<code>auto_offset_reset</code>设置为 <code>earliest</code>。那么当你的消费者运行的时候，Kafka 会先把你的 offset 设置为0，然后让你从头开始消费的。等消费到第50条数据时，你把消费者程序关了，把<code>auto_offset_reset</code>设置为<code>latest</code>，再重新运行。此时消费者依然会接着从第51条数据开始读取。不会跳过剩下的50条数据。</p>
<p>所以，auto_offset_reset的作用，是在你的 group 第一次运行，还没有 offset 的时候，给你设定初始的 offset。而一旦你这个 group 已经有 offset 了，那么auto_offset_reset这个参数就不会再起作用了。</p>
<p>以上注解为：公众号:未闻Code 如何使用Python读写Kafka？</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaConsumer</span><br><span class="line"></span><br><span class="line">consumer = KafkaConsumer(<span class="string">"first"</span>, bootstrap_servers=[<span class="string">'192.168.1.86:9092'</span>,<span class="string">'192.168.1.86:9093'</span>,<span class="string">'192.168.1.86:9094'</span>],group_id=<span class="string">'test'</span>,auto_offset_reset=<span class="string">'earliest'</span>)  </span><br><span class="line"><span class="comment"># 默认为latest</span></span><br><span class="line"><span class="keyword">for</span> msg <span class="keyword">in</span> consumer:</span><br><span class="line">    print(msg)</span><br></pre></td></tr></table></figure>
<h2 id="KafkaProducer"><a href="#KafkaProducer" class="headerlink" title="KafkaProducer"></a>KafkaProducer</h2><h5 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaProducer</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">SERVER = [<span class="string">'192.168.1.86:9092'</span>, <span class="string">'192.168.1.86:9093'</span>, <span class="string">'192.168.1.86:9094'</span>]</span><br><span class="line">TOPIC = <span class="string">'first'</span></span><br><span class="line">producer = KafkaProducer(bootstrap_servers=SERVER)</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    producer.send(<span class="string">'foobar'</span>, <span class="string">b'some_message_bytes'</span>)</span><br></pre></td></tr></table></figure>
<h5 id="生产者-Block直到单条消息发送完成（或超时）"><a href="#生产者-Block直到单条消息发送完成（或超时）" class="headerlink" title="生产者- Block直到单条消息发送完成（或超时）"></a>生产者- Block直到单条消息发送完成（或超时）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">future &#x3D; producer.send(&#39;foobar&#39;, b&#39;another_message&#39;)</span><br><span class="line">result &#x3D; future.get(timeout&#x3D;60)</span><br></pre></td></tr></table></figure>
<h5 id="生产者-Block直到所有阻塞的消息发送到网络"><a href="#生产者-Block直到所有阻塞的消息发送到网络" class="headerlink" title="生产者-Block直到所有阻塞的消息发送到网络"></a>生产者-<em>Block直到所有阻塞的消息发送到网络</em></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">producer.flush()</span><br></pre></td></tr></table></figure>
<h5 id="生产者-json数据"><a href="#生产者-json数据" class="headerlink" title="生产者-json数据"></a>生产者-json数据</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaProducer</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">SERVER = [<span class="string">'192.168.1.86:9092'</span>, <span class="string">'192.168.1.86:9093'</span>, <span class="string">'192.168.1.86:9094'</span>]</span><br><span class="line">TOPIC = <span class="string">'first'</span></span><br><span class="line">producer = KafkaProducer(bootstrap_servers=SERVER</span><br><span class="line">                         ,value_serializer=<span class="keyword">lambda</span> v: json.dumps(v).encode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    data = &#123;<span class="string">'num'</span>: i, <span class="string">'tims'</span>: datetime.datetime.now().strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>)&#125;</span><br><span class="line">    producer.send(<span class="string">"first"</span>, data)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h5 id="生产者-序列化字符串keys"><a href="#生产者-序列化字符串keys" class="headerlink" title="生产者-序列化字符串keys"></a>生产者-序列化字符串keys</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">producer = KafkaProducer(key_serializer=str.encode)</span><br><span class="line">producer.send(<span class="string">'flipflap'</span>, key=<span class="string">'ping'</span>, value=<span class="string">b'1234'</span>)</span><br></pre></td></tr></table></figure>
<h5 id="生产者-发送压缩消息"><a href="#生产者-发送压缩消息" class="headerlink" title="生产者-发送压缩消息"></a>生产者-<em>发送压缩消息</em></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaProducer</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">SERVER = [<span class="string">'192.168.1.86:9092'</span>, <span class="string">'192.168.1.86:9093'</span>, <span class="string">'192.168.1.86:9094'</span>]</span><br><span class="line">TOPIC = <span class="string">'first'</span></span><br><span class="line">producer = KafkaProducer(bootstrap_servers=SERVER</span><br><span class="line">                         ,value_serializer=<span class="keyword">lambda</span> v: json.dumps(v).encode(<span class="string">'utf-8'</span>), compression_type=<span class="string">'lz4'</span>)  <span class="comment"># 连接kafka</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    data = &#123;<span class="string">'num'</span>: i, <span class="string">'tims'</span>: datetime.datetime.now().strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>)&#125;</span><br><span class="line">    producer.send(<span class="string">"first"</span>, data)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h5 id="生产者-消息记录携带header"><a href="#生产者-消息记录携带header" class="headerlink" title="生产者-消息记录携带header"></a>生产者-<em>消息记录携带header</em></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">producer.send(<span class="string">'foobar'</span>, value=<span class="string">b'c29tZSB2YWx1ZQ=='</span>, headers=[(<span class="string">'content-encoding'</span>, <span class="string">b'base64'</span>)])</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考文章：</p>
<p><a href="https://github.com/dpkp/kafka-python" target="_blank" rel="noopener">https://github.com/dpkp/kafka-python</a></p>
<p><a href="https://kafka-python.readthedocs.io/en/master/index.html" target="_blank" rel="noopener">https://kafka-python.readthedocs.io/en/master/index.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>kafka-python</tag>
      </tags>
  </entry>
  <entry>
    <title>python -- 魔法函数</title>
    <url>/2019/05/10/python-magic-function-%E9%AD%94%E6%B3%95%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h4 id="1-什么是魔法函数"><a href="#1-什么是魔法函数" class="headerlink" title="1.什么是魔法函数"></a>1.什么是魔法函数</h4><ul>
<li>魔法函数是以上下划线开头和双下划线结尾的函数：<strong>init</strong>(self){…}</li>
<li>魔法函数是python帮我们定义过的不需要自己定义</li>
<li>python可以帮我们自动（隐式）调用魔法函数，不需要自己调用：例如调用<strong>getitem</strong>(self,item)就具有了迭代器属性可以放入for in 循环中遍历</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, employee_list)</span>:</span></span><br><span class="line">        self.employee = employee_list</span><br><span class="line"></span><br><span class="line">    <span class="comment"># python编译器自动调用，使得可以在for in循环中使用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.employee[item]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">company = Company([<span class="string">"tom"</span>, <span class="string">"bob"</span>, <span class="string">"jane"</span>])</span><br><span class="line"><span class="keyword">for</span> em <span class="keyword">in</span> company:</span><br><span class="line">    print(em)       <span class="comment"># tom bob jane</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="2-python的数据模型以及数据模型对python的影响"><a href="#2-python的数据模型以及数据模型对python的影响" class="headerlink" title="2.python的数据模型以及数据模型对python的影响"></a>2.python的数据模型以及数据模型对python的影响</h4><ul>
<li>此处的数据模型也就是常说的魔法函数</li>
<li>如果自己没有实现类中的一些数据模型可能会对python中的遍历，切片等语法产生影响</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, employee_list)</span>:</span></span><br><span class="line">        self.employee = employee_list</span><br><span class="line"></span><br><span class="line">    <span class="comment"># python编译器自动调用，使得可以在for in循环中使用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.employee[item]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># python编译器自动调用，获得长度</span></span><br><span class="line">    <span class="comment"># def __len__(self):</span></span><br><span class="line">    <span class="comment">#     return len(self.employee)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">company = Company([<span class="string">"tom"</span>, <span class="string">"bob"</span>, <span class="string">"jane"</span>])</span><br><span class="line"><span class="keyword">for</span> em <span class="keyword">in</span> company:</span><br><span class="line">    print(em)       <span class="comment"># tom bob jane</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># __getitem__处理切片的数据可以得到len，不可以处理没有切片的数据</span></span><br><span class="line">company1 = company[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤：</span></span><br><span class="line"><span class="comment"># 1.查找否有__len__</span></span><br><span class="line"><span class="comment"># 2.没有__len__再查看数据是否切片并且是否有__getitem__</span></span><br><span class="line"><span class="comment"># 3.有则可以获得len，如果数据没有切片则会报错</span></span><br><span class="line">print(len(company1))    <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>
<h4 id="3-魔法函数一览表"><a href="#3-魔法函数一览表" class="headerlink" title="3.魔法函数一览表"></a>3.魔法函数一览表</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">非数学运算</span><br><span class="line">字符串：</span><br><span class="line">__repr__</span><br><span class="line">__str__</span><br><span class="line">集合、序列相关</span><br><span class="line">__len__</span><br><span class="line">__getitem__</span><br><span class="line">__setitem__</span><br><span class="line">__delitem__</span><br><span class="line">__contains__</span><br><span class="line">迭代相关</span><br><span class="line">__iter__</span><br><span class="line">__next__</span><br><span class="line">可调用</span><br><span class="line">__call__</span><br><span class="line"><span class="keyword">with</span>上下文管理器</span><br><span class="line">__enter__</span><br><span class="line">__exit__</span><br><span class="line">数值转换</span><br><span class="line">__abs__</span><br><span class="line">__bool__</span><br><span class="line">__int__</span><br><span class="line">__float__</span><br><span class="line">__hash__</span><br><span class="line">__index__</span><br><span class="line">元类相关</span><br><span class="line">__new__</span><br><span class="line">__init__</span><br><span class="line">属性相关</span><br><span class="line">__getattr__、__setattr__</span><br><span class="line">__getattribute__、setattribute__</span><br><span class="line">__dir__</span><br><span class="line">属性描述符</span><br><span class="line">__get__</span><br><span class="line">__set__</span><br><span class="line">__delete__</span><br><span class="line">协程</span><br><span class="line">__await__</span><br><span class="line">__aiter__</span><br><span class="line">__anext__</span><br><span class="line">__aenter__</span><br><span class="line">__aexit__</span><br><span class="line">数学运算</span><br><span class="line">一元运算符</span><br><span class="line">__neg__(-)、__pos__(+)、__abs__</span><br><span class="line">二元运算符</span><br><span class="line">__lt__(&lt;)、__le__(&lt;=)、__eq__(==)、__ne__(!=)、__gt__(&gt;)、__ge__(&gt;=)</span><br><span class="line">__add__(+)、__sub__(-)、__mul__(*)、__truediv__(/)、__floordiv__(//)、</span><br><span class="line">算术运算符</span><br><span class="line">反向算术运算符</span><br><span class="line">增量赋值算数运算符</span><br><span class="line">位运算符</span><br><span class="line">反向位运算符</span><br><span class="line">增量赋值位运算符</span><br></pre></td></tr></table></figure>
<h4 id="编写str、repr方法"><a href="#编写str、repr方法" class="headerlink" title="编写str、repr方法"></a>编写<strong>str</strong>、<strong>repr</strong>方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, employee_list)</span>:</span></span><br><span class="line">        self.employee = employee_list</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在对象格式化时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">","</span>.join(self.employee)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在开发模式下调用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">","</span>.join(self.employee)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">company = Company([<span class="string">"tom"</span>, <span class="string">"bob"</span>, <span class="string">"jane"</span>])</span><br><span class="line"><span class="comment"># 对象格式化</span></span><br><span class="line">print(company)  <span class="comment"># tom,bob,jane</span></span><br><span class="line"><span class="comment"># 开发模式:cmd或notebook中调用</span></span><br><span class="line">company     <span class="comment"># tom,bob,jane</span></span><br></pre></td></tr></table></figure>
<h4 id="编写add方法"><a href="#编写add方法" class="headerlink" title="编写add方法"></a>编写<strong>add</strong>方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyVector</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        re_vector = MyVector(self.x + other.x, self.y + other.y)</span><br><span class="line">        <span class="keyword">return</span> re_vector</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"x:&#123;x&#125;,y:&#123;y&#125;"</span>.format(x=self.x, y=self.y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vec1 = MyVector(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">vec2 = MyVector(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">print(vec1 + vec2)  <span class="comment"># x:4,y:6</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>魔法函数</tag>
      </tags>
  </entry>
  <entry>
    <title>python -- 元类编程</title>
    <url>/2019/06/25/python-mateclass-%E5%85%83%E7%B1%BB%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="1-property-动态属性"><a href="#1-property-动态属性" class="headerlink" title="1. property 动态属性"></a>1. property 动态属性</h3><blockquote>
<p>使用 property 注解，可以将某个方法装饰属性描述符，将取函数变成取属性的方式。那么，什么时候会用到呢？ 以下面的代码为例，假设项目早期的版本代码中有 age 这个属性，随着项目的迭代，age 这个属性后期被移除了，添加了新的计算逻辑，那么之前的代码中通过 self.age 这种方式都需要被修改。此时，通过 property 注解，就可以将新写的 age 函数变成属性，之前的代码旧代码旧不用修改了。<br>通过 property 可以向属性一样获取值，那么如何设置值呢？答案是使用 setter 装饰器。</p>
</blockquote>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date, datetime</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, birthday)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.birthday = birthday</span><br><span class="line">        <span class="comment"># self.age = 0</span></span><br><span class="line">        self._age = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> datetime.now().year - self.birthday.year</span><br><span class="line"></span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._age = value</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    user = User(<span class="string">"bobby"</span>, date(year=<span class="number">1987</span>, month=<span class="number">1</span>, day=<span class="number">1</span>))</span><br><span class="line">    <span class="comment"># 通过 setter 方式设置值</span></span><br><span class="line">    user.age = <span class="number">30</span></span><br><span class="line">    <span class="keyword">print</span> (user._age)</span><br><span class="line">    <span class="comment"># 通过 property 方式获取 age 函数返回的值</span></span><br><span class="line">    print(user.age)</span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">from</span> werkzeug.security <span class="keyword">import</span> check_password_hash, generate_password_hash</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProcessPwd</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.password_hash = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">password</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> AttributeError(<span class="string">"当前属性不允许读取"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @password.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">password</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.password_hash = generate_password_hash(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_password</span><span class="params">(self, pwd_hash, password)</span>:</span></span><br><span class="line">        <span class="string">"""校验密码"""</span></span><br><span class="line">        <span class="keyword">return</span> check_password_hash(pwd_hash, password)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pwd = ProcessPwd()</span><br><span class="line">    pwd.password = <span class="string">"123456"</span></span><br><span class="line">    print(pwd.password_hash)</span><br><span class="line">    print(check_password_hash(pwd.password_hash, <span class="string">"123456"</span>))</span><br></pre></td></tr></table></figure>
<h3 id="2-getattr-和-getattribute"><a href="#2-getattr-和-getattribute" class="headerlink" title="2. getattr 和 getattribute"></a>2. <strong>getattr</strong> 和 <strong>getattribute</strong></h3><blockquote>
<p>当调用某个不存在的属性是，Python 会调用 <strong>getattr</strong> 函数。<br>当调用任何一个属性时，Python 都会调用 <strong>getattribute</strong> 函数。<strong>通常不建议重写该方法</strong>，该方法把持了所有调用属性的入口，如果重写的不好，可能会弄巧成拙。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, birthday)</span>:</span></span><br><span class="line">        <span class="comment"># self.name = name</span></span><br><span class="line">        self.birthday = birthday</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当查找不到这个属性的时候会调用__getattr__</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"not attr"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 所有属性的入口</span></span><br><span class="line">    <span class="comment"># def __getattribute__(self, item):</span></span><br><span class="line">    <span class="comment">#     return "bobby"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    user = User(<span class="string">"he"</span>, date(year=<span class="number">1999</span>, month=<span class="number">1</span>, day=<span class="number">1</span>))</span><br><span class="line">    print(user.name)</span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,info=&#123;&#125;)</span>:</span></span><br><span class="line">        self.info = info</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.info[item]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"bobby"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    user = User(info=&#123;<span class="string">"company_name"</span>:<span class="string">"imooc"</span>, <span class="string">"name"</span>:<span class="string">"bobby"</span>&#125;)</span><br><span class="line">    print(user.test)</span><br></pre></td></tr></table></figure>
<h3 id="3-属性描述符"><a href="#3-属性描述符" class="headerlink" title="3. 属性描述符"></a>3. 属性描述符</h3><blockquote>
<p>一个项目中往往包含几十张表，每个表里面都会有非常多的字段，所以类中就会包含大量 property 和 setter 这种代码，导致大量重复代码，那么，怎么解决复用问题呢？这时就需要属性描述符了。属性描述符类需要实现：<strong>get</strong>, <strong>set</strong>, <strong>delete</strong> 三个方法。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date, datetime</span><br><span class="line"><span class="keyword">import</span> numbers</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntField</span>:</span></span><br><span class="line">    <span class="comment">#数据描述符</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, numbers.Integral):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"int value need"</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"positive value need"</span>)</span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(self, instance)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonDataIntField</span>:</span></span><br><span class="line">    <span class="comment">#非数据属性描述符</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>:</span></span><br><span class="line">    age = IntField()</span><br><span class="line">    <span class="comment"># age = NonDataIntField()</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">如果user是某个类的实例，那么user.age（以及等价的getattr(user,’age’)）</span></span><br><span class="line"><span class="string">首先调用__getattribute__。如果类定义了__getattr__方法，</span></span><br><span class="line"><span class="string">那么在__getattribute__抛出 AttributeError 的时候就会调用到__getattr__，</span></span><br><span class="line"><span class="string">而对于描述符(__get__）的调用，则是发生在__getattribute__内部的。</span></span><br><span class="line"><span class="string">user = User(), 那么user.age 顺序如下：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">（1）如果“age”是出现在User或其基类的__dict__中， 且age是data descriptor， 那么调用其__get__方法, 否则</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">（2）如果“age”出现在user的__dict__中， 那么直接返回 obj.__dict__[‘age’]， 否则</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">（3）如果“age”出现在User或其基类的__dict__中</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">（3.1）如果age是non-data descriptor，那么调用其__get__方法， 否则</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">（3.2）返回 __dict__[‘age’]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">（4）如果User有__getattr__方法，调用__getattr__方法，否则</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">（5）抛出AttributeError</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># class User:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     def __init__(self, name, email, birthday):</span></span><br><span class="line"><span class="comment">#         self.name = name</span></span><br><span class="line"><span class="comment">#         self.email = email</span></span><br><span class="line"><span class="comment">#         self.birthday = birthday</span></span><br><span class="line"><span class="comment">#         self._age = 0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     # def get_age(self):</span></span><br><span class="line"><span class="comment">#     #     return datetime.now().year - self.birthday.year</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     @property</span></span><br><span class="line"><span class="comment">#     def age(self):</span></span><br><span class="line"><span class="comment">#         return datetime.now().year - self.birthday.year</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     @age.setter</span></span><br><span class="line"><span class="comment">#     def age(self, value):</span></span><br><span class="line"><span class="comment">#         #检查是否是字符串类型</span></span><br><span class="line"><span class="comment">#         self._age = value</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    user = User()</span><br><span class="line">    user.__dict__[<span class="string">"age"</span>] = <span class="string">"abc"</span></span><br><span class="line">    <span class="keyword">print</span> (user.__dict__)</span><br><span class="line">    <span class="keyword">print</span> (user.age)</span><br><span class="line">    <span class="comment"># print (getattr(user, 'age'))</span></span><br><span class="line">    <span class="comment"># user = User("bobby", date(year=1987, month=1, day=1))</span></span><br><span class="line">    <span class="comment"># user.age = 30</span></span><br><span class="line">    <span class="comment"># print (user._age)</span></span><br><span class="line">    <span class="comment"># print(user.age)</span></span><br></pre></td></tr></table></figure>
<h3 id="4-new和init的区别"><a href="#4-new和init的区别" class="headerlink" title="4. new和init的区别"></a>4. <strong>new</strong>和<strong>init</strong>的区别</h3><ol>
<li>new 是用来控制对象的生成过程， 在对象生成之前。<ol>
<li>new 为对象分配内存空间，返回对象的引用</li>
<li>init 对象初始化，定义实例属性</li>
</ol>
</li>
<li>init 是用来完善对象的。</li>
<li>如果 new 方法不返回对象， 则不会调用 init 函数。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>:</span></span><br><span class="line">	<span class="comment"># 第一个参数使 cls</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">" in new "</span>)</span><br><span class="line">        <span class="keyword">return</span> super().__new__(cls)</span><br><span class="line">    <span class="comment"># 第一个参数使 self</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">" in init"</span>)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">a = int()</span><br><span class="line"><span class="comment">#new 是用来控制对象的生成过程， 在对象生成之前</span></span><br><span class="line"><span class="comment">#init是用来完善对象的</span></span><br><span class="line"><span class="comment">#如果new方法不返回对象， 则不会调用init函数</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    user = User(name=<span class="string">"bobby"</span>)</span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># 单例模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MusicPlayer</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 记录第一个被创建对象的引用</span></span><br><span class="line">    instance = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 记录是否执行过初始化动作</span></span><br><span class="line">    init_flag = <span class="literal">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 1. 判断类属性是否是空对象</span></span><br><span class="line">        <span class="keyword">if</span> cls.instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 2. 调用父类的方法，为第一个对象分配空间</span></span><br><span class="line">            cls.instance = super().__new__(cls)</span><br><span class="line">        <span class="comment"># 3. 返回类属性保存的对象引用</span></span><br><span class="line">        <span class="keyword">return</span> cls.instance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> MusicPlayer.init_flag:</span><br><span class="line">            print(<span class="string">"初始化音乐播放器"</span>)</span><br><span class="line"></span><br><span class="line">            MusicPlayer.init_flag = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建多个对象</span></span><br><span class="line">player1 = MusicPlayer()</span><br><span class="line">print(player1)</span><br><span class="line"></span><br><span class="line">player2 = MusicPlayer()</span><br><span class="line">print(player2)</span><br></pre></td></tr></table></figure>
<h3 id="5-动态创建类"><a href="#5-动态创建类" class="headerlink" title="5. 动态创建类"></a>5. 动态创建类</h3><h3 id="5-1-使用工厂模式创建类"><a href="#5-1-使用工厂模式创建类" class="headerlink" title="5.1 使用工厂模式创建类"></a>5.1 使用工厂模式创建类</h3><blockquote>
<p>通过手工预先编写预置类的方式创建动态类</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_class</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">"user"</span>:</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">User</span>:</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">"user"</span></span><br><span class="line">        <span class="keyword">return</span> User</span><br><span class="line">    <span class="keyword">elif</span> name == <span class="string">"company"</span>:</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Company</span>:</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">"company"</span></span><br><span class="line">        <span class="keyword">return</span> Company</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 通过 user 参数，创建了 User 类</span></span><br><span class="line">    MyClass = create_class(<span class="string">"user"</span>)</span><br><span class="line">    my_obj = MyClass()</span><br><span class="line">    print(type(my_obj))</span><br></pre></td></tr></table></figure>
<h3 id="5-2-使用-type-动态创建类"><a href="#5-2-使用-type-动态创建类" class="headerlink" title="5.2 使用 type 动态创建类"></a>5.2 使用 type 动态创建类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#type动态创建类</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态方法必须接受 self 参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"i am user"</span></span><br><span class="line">    <span class="comment"># return self.name</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">answer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"i am baseclass"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">	<span class="comment"># 第一个参数：类的名称；</span></span><br><span class="line">	<span class="comment"># 第二个参数：基类名；</span></span><br><span class="line">	<span class="comment"># 第三个参数：属性名及其对应值，或者方法名及其对应的方法逻辑</span></span><br><span class="line">	<span class="comment"># 注意下面一行中，第二个 say 不要写成 say(), 尽管这是一个方法，也不要写成 say()</span></span><br><span class="line">    User = type(<span class="string">"User"</span>, (BaseClass, ), &#123;<span class="string">"name"</span>: <span class="string">"user"</span>, <span class="string">"say"</span>: say&#125;)</span><br><span class="line">    my_obj = User()</span><br><span class="line">    print(type(my_obj))</span><br><span class="line">    print(my_obj.name)</span><br></pre></td></tr></table></figure>
<h3 id="5-3-元类方式动态创建类"><a href="#5-3-元类方式动态创建类" class="headerlink" title="5.3 元类方式动态创建类"></a>5.3 元类方式动态创建类</h3><blockquote>
<p>首先，我们需要弄明白什么是元类。元类是创建类的类，也就是 type。type 创建了 class，class 创建了对象。即，类也是一种类。懂 Java 反射机制的同学非常容易理解这些内容。</p>
</blockquote>
<h3 id="5-3-1-只有-metaclass-时"><a href="#5-3-1-只有-metaclass-时" class="headerlink" title="5.3.1 只有 metaclass 时"></a>5.3.1 只有 metaclass 时</h3><blockquote>
<p>当只有 metaclass 时，创建过程：type —&gt; class(对象) —&gt; 对象</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MetaClass</span><span class="params">(type)</span>:</span></span><br><span class="line">	<span class="comment"># 在 metaclass 时，需要将 *args, **kwargs 向上传递，否则会报错</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> super().__new__(cls, *args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 什么是元类， 元类是创建类的类。</span></span><br><span class="line"><span class="comment"># 创建过程：type --&gt; class(对象) --&gt; 对象 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(metaclass=MetaClass)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"user"</span></span><br><span class="line"><span class="comment"># python中类的实例化过程，会首先寻找metaclass，通过metaclass去创建user类</span></span><br><span class="line"><span class="comment"># type 去创建类对象，实例</span></span><br></pre></td></tr></table></figure>
<h3 id="5-3-2-当既有基类又有-metaclass-时"><a href="#5-3-2-当既有基类又有-metaclass-时" class="headerlink" title="5.3.2 当既有基类又有 metaclass 时"></a>5.3.2 当既有基类又有 metaclass 时</h3><blockquote>
<p>当既有基类又有 metaclass 时，会首先找 metaclass，现在当前的类中找 metaclass，如果找不带， 就在 BaseClass 中找 metaclass，如果还找不到，就在模块中找 metaclass。如果都找不到就调用 type 创建。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">answer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"i am baseclass"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MetaClass</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> super().__new__(cls, *args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 什么是元类， 元类是创建类的类。</span></span><br><span class="line"><span class="comment"># 创建过程：type --&gt; class(对象) --&gt; 对象 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(BaseClass, metaclass=MetaClass)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"user"</span></span><br></pre></td></tr></table></figure>
<h2 id="6-装饰器"><a href="#6-装饰器" class="headerlink" title="6. 装饰器"></a>6. 装饰器</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(func)</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">       <span class="keyword">print</span> <span class="string">"[DEBUG]: enter &#123;&#125;()"</span>.format(func.__name__)        </span><br><span class="line">       <span class="keyword">return</span> func()    </span><br><span class="line">   <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@debug</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">()</span>:</span></span><br><span class="line">   <span class="keyword">print</span> <span class="string">"hello!"</span></span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(func)</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span>  <span class="comment"># 指定宇宙无敌参数</span></span><br><span class="line">       <span class="keyword">print</span> <span class="string">"[DEBUG]: enter &#123;&#125;()"</span>.format(func.__name__)        </span><br><span class="line">       <span class="keyword">print</span> <span class="string">'Prepare and say...'</span>,        </span><br><span class="line">       <span class="keyword">return</span> func(*args, **kwargs)    </span><br><span class="line">   <span class="keyword">return</span> wrapper  <span class="comment"># 返回</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@debug</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(something)</span>:</span></span><br><span class="line">   <span class="keyword">print</span> <span class="string">"hello &#123;&#125;!"</span>.format(something)</span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logging</span><span class="params">(level)</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">inner_wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">           <span class="keyword">print</span> <span class="string">"[&#123;level&#125;]: enter function &#123;func&#125;()"</span>.format(</span><br><span class="line">               level=level,</span><br><span class="line">               func=func.__name__)            </span><br><span class="line">           <span class="keyword">return</span> func(*args, **kwargs)        </span><br><span class="line">       <span class="keyword">return</span> inner_wrapper    </span><br><span class="line">   <span class="keyword">return</span> wrapper</span><br><span class="line">   </span><br><span class="line"><span class="meta">@logging(level='INFO')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(something)</span>:</span></span><br><span class="line">   <span class="keyword">print</span> <span class="string">"say &#123;&#125;!"</span>.format(something)</span><br><span class="line"></span><br><span class="line"><span class="meta">@logging(level='DEBUG')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do</span><span class="params">(something)</span>:</span></span><br><span class="line">   <span class="keyword">print</span> <span class="string">"do &#123;&#125;..."</span>.format(something)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">   say(<span class="string">'hello'</span>)</span><br><span class="line">   do(<span class="string">"my work"</span>)</span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">logging</span><span class="params">(object)</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">       self.func = func    </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">       <span class="keyword">print</span> <span class="string">"[DEBUG]: enter function &#123;func&#125;()"</span>.format(</span><br><span class="line">           func=self.func.__name__)        </span><br><span class="line">       <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">@logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(something)</span>:</span></span><br><span class="line">   <span class="keyword">print</span> <span class="string">"say &#123;&#125;!"</span>.format(something)</span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">logging</span><span class="params">(object)</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, level=<span class="string">'INFO'</span>)</span>:</span></span><br><span class="line">       self.level = level    </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, func)</span>:</span>  <span class="comment"># 接受函数</span></span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">           <span class="keyword">print</span> <span class="string">"[&#123;level&#125;]: enter function &#123;func&#125;()"</span>.format(</span><br><span class="line">               level=self.level,</span><br><span class="line">               func=func.__name__)</span><br><span class="line">           func(*args, **kwargs)        </span><br><span class="line">       <span class="keyword">return</span> wrapper  <span class="comment"># 返回函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@logging(level='INFO')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(something)</span>:</span></span><br><span class="line">   <span class="keyword">print</span> <span class="string">"say &#123;&#125;!"</span>.format(something)</span><br><span class="line">————————————————</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>property</tag>
        <tag>getattr</tag>
        <tag>getattribute</tag>
        <tag>mateclass</tag>
      </tags>
  </entry>
  <entry>
    <title>python -- set dict</title>
    <url>/2019/06/15/python-set-dict/</url>
    <content><![CDATA[<h3 id="1-collections中的abc"><a href="#1-collections中的abc" class="headerlink" title="1.collections中的abc"></a>1.collections中的abc</h3><ul>
<li>MutableMapping是Mapping的子类</li>
<li>Mapping是Collection的子类</li>
<li>Collection是Sized，Iterable，Container的子类</li>
<li>dict被注册到MutableMapping中拥有了MutableMapping的方法，dict是鸭子类型，相当于MutableMapping的子类。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> MutableMapping</span><br><span class="line"></span><br><span class="line"><span class="comment"># dict属于MutableMapping类型</span></span><br><span class="line"></span><br><span class="line">a = &#123;&#125;</span><br><span class="line">print(isinstance(a, MutableMapping))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="2-dict的常见用法"><a href="#2-dict的常见用法" class="headerlink" title="2.dict的常见用法"></a>2.dict的常见用法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">"1"</span>:&#123;<span class="string">"a"</span>:<span class="string">"aa"</span>&#125;,</span><br><span class="line">     <span class="string">"2"</span>:&#123;<span class="string">"b"</span>:<span class="string">"bb"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空字典</span></span><br><span class="line">a.clear()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 浅拷贝字典 浅拷贝虽然可以正常赋值，但是如果 my_dopy_dict 中的值进行了改变，则 a 中的值也会进行对应的改变</span></span><br><span class="line">my_dopy_dict = a.copy()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 深拷贝 深拷贝则是实实在在的在内存当中声明了一个新的变量</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">new_dict = copy.deepcopy(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get函数 dict.get(要查找的key,如果没找到对应key的内容返回的数据)</span></span><br><span class="line">print(a.get(<span class="string">"3"</span>,&#123;<span class="number">1</span>:<span class="string">"3"</span>&#125;)) <span class="comment"># &#123;1: '3'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dict.fromkeys() 函数用于创建一个新字典，以序列 seq 中元素做字典的键 seq可以是可迭代的，value 为字典所有键对应的初始值。</span></span><br><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">my_new_dict = dict.fromkeys(my_list, &#123;<span class="string">"222"</span>:<span class="string">"3434"</span>&#125;) <span class="comment">#&#123;1: &#123;'222': '3434'&#125;, 2: &#123;'222': '3434'&#125;, 3: &#123;'222': '3434'&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># setdefault() 函数和 get()方法 类似,</span></span><br><span class="line"><span class="comment"># 如果键不存在于字典中，将会添加键并将值设为默认值。</span></span><br><span class="line"><span class="comment"># 如果存在，则将会返回该key对应的value</span></span><br><span class="line">a.setdefault(<span class="string">"3"</span>, <span class="string">"cc"</span>) <span class="comment"># a= &#123;'1': &#123;'a': 'aa'&#125;, '2': &#123;'b': 'bb'&#125;, '3': 'cc'&#125;</span></span><br><span class="line">print(a.setdefault(<span class="string">"2"</span>, <span class="string">"cc"</span>)) <span class="comment"># 返回&#123;'b': 'bb'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># update() 函数是合并两个字典：把字典dict2的键/值对更新到dict里。</span></span><br><span class="line"><span class="comment"># 如果字典b中有与a相同的key，则会把a中的key对应的value进行更新</span></span><br><span class="line"><span class="comment"># 如果字典b中有a中没有的key，则a会将未有的key与value添加进去</span></span><br><span class="line">b = &#123;<span class="string">"3"</span>: <span class="string">"cc"</span>, <span class="string">"2"</span>: <span class="string">"dd"</span>&#125;</span><br><span class="line">a.update(b)</span><br><span class="line">print(a) <span class="comment"># &#123;'1': &#123;'a': 'aa'&#125;, '2': 'dd', '3': 'cc'&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-dict的子类"><a href="#3-dict的子类" class="headerlink" title="3.dict的子类"></a>3.dict的子类</h3><ul>
<li>不可以去继承dict类，由于dict实现方式是C语言实现（没有重写方法的概念），所以重写dict中的方法是无效的</li>
<li>可以去继承UserDict类，UserDict类是由python语言自己实现的可以重写</li>
<li>我们也可以不去继承dict类而是去使用dict的子类defaultdict，由于defaultdict构造函数需要传入一个工厂所以我们传入dict来构造defaultdict</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mydict</span><span class="params">(dict)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        super().__setitem__(key, value * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_dict = Mydict(one=<span class="number">1</span>)</span><br><span class="line">print(my_dict)  <span class="comment"># &#123;'one': 1&#125; 不可以修改</span></span><br><span class="line">my_dict[<span class="string">"one"</span>] = <span class="number">1</span></span><br><span class="line">print(my_dict)   <span class="comment"># &#123;'one': 2&#125; 可以像C语言一样修改</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> UserDict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mydict</span><span class="params">(UserDict)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        super().__setitem__(key, value * <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_dict = Mydict(one=<span class="number">3</span>)</span><br><span class="line">print(my_dict)  <span class="comment"># &#123;'one': 15&#125; 调用重写的__setitem__</span></span><br><span class="line">my_dict[<span class="string">"one"</span>] = <span class="number">4</span></span><br><span class="line">print(my_dict)  <span class="comment"># &#123;'one': 20&#125; 调用重写的__setitem__</span></span><br></pre></td></tr></table></figure>
<h3 id="set和frozenset"><a href="#set和frozenset" class="headerlink" title="set和frozenset"></a>set和frozenset</h3><ul>
<li>set：无序，不重复，可修改集合</li>
<li><p>frozenset：无序，不重复，不可修改集合</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = set(<span class="string">'abcdee'</span>)</span><br><span class="line">a.add(<span class="string">'f'</span>)</span><br><span class="line">print(a)    <span class="comment"># &#123;'a', 'd', 'c', 'b', 'e', 'f'&#125;</span></span><br><span class="line">another_set = set(<span class="string">'defgh'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3></li>
</ul>
<p>a.update(another_set)<br>print(a)    # {‘a’, ‘d’, ‘c’, ‘b’, ‘e’, ‘g’, ‘f’, ‘h’}</p>
<h3 id="集合的差集"><a href="#集合的差集" class="headerlink" title="集合的差集"></a>集合的差集</h3><p>re_set = a.difference(another_set)</p>
<h3 id="减法实现于ior魔法函数"><a href="#减法实现于ior魔法函数" class="headerlink" title="减法实现于ior魔法函数"></a>减法实现于<strong>ior</strong>魔法函数</h3><p>re_set2 = a - another_set</p>
<h3 id="集合的交集-amp"><a href="#集合的交集-amp" class="headerlink" title="集合的交集&amp;"></a>集合的交集&amp;</h3><p>re_set3 = a &amp; another_set</p>
<h3 id="集合的并集"><a href="#集合的并集" class="headerlink" title="集合的并集|"></a>集合的并集|</h3><p>re_set4 = a | another_set<br>print(re_set)   # {‘c’, ‘a’, ‘b’}<br>print(re_set2)  # {‘c’, ‘a’, ‘b’}<br>print(re_set3)  # {‘d’, ‘e’, ‘g’, ‘f’, ‘h’}<br>print(re_set4)  # {‘a’, ‘d’, ‘c’, ‘b’, ‘e’, ‘g’, ‘f’, ‘h’}</p>
<h3 id="也可以用if-in判断（实现于contains魔法函数）"><a href="#也可以用if-in判断（实现于contains魔法函数）" class="headerlink" title="也可以用if in判断（实现于contains魔法函数）"></a>也可以用if in判断（实现于<strong>contains</strong>魔法函数）</h3><p>if ‘a’ in re_set:<br>    print(‘a in re_set’)    # a in re_set<br>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">### dict和set实现原理</span></span><br><span class="line"></span><br><span class="line">- set和dict的查询性能远远好于list</span><br><span class="line">- list会随数据量的增大而增大，set和dict不会</span><br><span class="line"></span><br><span class="line">  dist和set使用哈希表存储：</span><br><span class="line"></span><br><span class="line">![](https://img2018.cnblogs.com/blog/<span class="number">842724</span>/<span class="number">201912</span>/<span class="number">842724</span><span class="number">-20191221153146795</span><span class="number">-406100300.</span>png)</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> dict的key以及set的value都必须是可以hash的</span><br><span class="line"><span class="number">2.</span> 什么是可以hash：不可变对象：str,frozenset,tuple以及自己实现了__hash__的类</span><br><span class="line"><span class="number">3.</span> dict的内存花销大，但查询速度快，自定义的对象或python内部的对象都是用dict包装的</span><br><span class="line"><span class="number">4.</span> dict的存储顺序和元素添加顺序有关</span><br><span class="line"><span class="number">5.</span> dict在添加数据时可能改变已有数据的顺序</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>dict</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title>python -- 对象引用-可变性-垃圾回收</title>
    <url>/2019/06/20/python-%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8-%E5%8F%AF%E5%8F%98%E6%80%A7-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<h3 id="python中的数据类型"><a href="#python中的数据类型" class="headerlink" title="python中的数据类型"></a>python中的数据类型</h3><h3 id="（1）python3中有六个标准的数据类型"><a href="#（1）python3中有六个标准的数据类型" class="headerlink" title="（1）python3中有六个标准的数据类型"></a>（1）python3中有六个标准的数据类型</h3><ul>
<li><p>Number（数值）：int、float、bool、complex</p>
</li>
<li><p>String（字符串）： str = ‘Runoob’ </p>
</li>
<li><p>List（列表）： list = [ ‘abcd’, 786 , 2.23, ‘runoob’, 70.2 ] </p>
</li>
<li><p>Tuple（元组）： tuple = ( ‘abcd’, 786 , 2.23, ‘runoob’, 70.2 ) </p>
</li>
<li><p>Set（集合）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#39;Mary&#39;, &#39;Jim&#39;, &#39;Rose&#39;, &#39;Jack&#39;, &#39;Tom&#39;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Dictionary（字典）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tinydict &#x3D; &#123;&#39;name&#39;: &#39;runoob&#39;,&#39;code&#39;:1, &#39;site&#39;: &#39;www.runoob.com&#39;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<h3 id="python中的可变类型和不可变类型："><a href="#python中的可变类型和不可变类型：" class="headerlink" title="python中的可变类型和不可变类型："></a>python中的可变类型和不可变类型：</h3><div class="table-container">
<table>
<thead>
<tr>
<th>不可变类型</th>
<th>可变类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>Number（数字）</td>
<td>List（列表）</td>
</tr>
<tr>
<td>String（字符串）</td>
<td>Dic（字典）</td>
</tr>
<tr>
<td>Tuple（元组）</td>
<td>Sets（集合）</td>
</tr>
</tbody>
</table>
</div>
<p> 注：python的参数传递：</p>
<ul>
<li>不可变对象：传值</li>
<li>可变对象：传引用</li>
</ul>
<h1 id="1-python变量是什么"><a href="#1-python变量是什么" class="headerlink" title="1.python变量是什么"></a>1.python变量是什么</h1><ul>
<li>python的变量<strong>实质是一个指针</strong>，而java普通变量是一个容器直接存入值。</li>
</ul>
<p>为什么b也变了呢，由于a，b同时指向同一个地址，导致a指向的内容改变也会让b改变，id()获得对象所指向的内存中的地址，如果是对象本身的地址的话a,b应该是不相同的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; [1, 2, 3]</span><br><span class="line">b &#x3D; a</span><br><span class="line"># a和b实质是指针都指向同一个地址，修改a同时会修改b</span><br><span class="line">print(id(a), id(b))  # 54866344 54866344</span><br><span class="line">print(a is b)   # True</span><br><span class="line"></span><br><span class="line">a.append(2)</span><br><span class="line">print(a, b)  # [1, 2, 3, 2] [1, 2, 3, 2]</span><br></pre></td></tr></table></figure>
<h3 id="注：python变量生成步骤"><a href="#注：python变量生成步骤" class="headerlink" title="注：python变量生成步骤"></a>注：python变量生成步骤</h3><ul>
<li>先建立对象[1,2,3,4] 赋值一个地址：19333544</li>
<li>让a指向这个19333544地址</li>
<li>再建立对象[1,2,3,4] 赋值一个地址：193335480</li>
<li>让b指向这个193335480地址</li>
<li>让c指向与a指向相同的地址</li>
</ul>
<p>a和b指向不同的对象，c和a指向相同对象</p>
<p>a和b指向不同的对象，c和a指向相同对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 a &#x3D; [1, 2, 3, 4]</span><br><span class="line">2 b &#x3D; [1, 2, 3, 4]</span><br><span class="line">3 c &#x3D; a</span><br><span class="line">4 print(id(a), id(b), id(c))  # 19333544 19333480 19333544</span><br></pre></td></tr></table></figure>
<p><strong>关键点：</strong></p>
<p><strong>对于不可变类型都指向同一个地址，可变类型都指向不同地址</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; 1</span><br><span class="line">b &#x3D; 1</span><br><span class="line">c &#x3D; a</span><br><span class="line">print(id(a), id(b), id(c))  # 1399769008 1399769008 1399769008</span><br><span class="line"></span><br><span class="line">a &#x3D; &quot;abc&quot;</span><br><span class="line">b &#x3D; &quot;abc&quot;</span><br><span class="line">c &#x3D; a</span><br><span class="line">print(id(a), id(b), id(c))  # 24048032 24048032 24048032</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>1.== 和 is 的区别</li>
<li>2.垃圾回收</li>
<li>3.一个经典的参数引用错误</li>
</ul>
<h3 id="1-和-is-的区别"><a href="#1-和-is-的区别" class="headerlink" title="1. == 和 is 的区别"></a>1. == 和 is 的区别</h3><blockquote>
<p>== 判断符是调用类的 <strong>eq</strong> 方法，is 是调用 id() 判断 id 是否相等。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">person = People()</span><br><span class="line"><span class="comment"># 也可以用 isinstance</span></span><br><span class="line"><span class="keyword">if</span> type(person) <span class="keyword">is</span> People:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"yes"</span>)</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line">print(a == b)</span><br><span class="line"><span class="comment"># id 不同</span></span><br><span class="line"><span class="keyword">print</span> (id(a), id(b))</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="keyword">print</span> (a <span class="keyword">is</span> b)</span><br></pre></td></tr></table></figure>
<h3 id="2-垃圾回收"><a href="#2-垃圾回收" class="headerlink" title="2. 垃圾回收"></a>2. 垃圾回收</h3><blockquote>
<p>在 C++ 语言中，delete 关键字直接将一个变量回收了，但是在 Python 中，<strong>del 关键字是将一个变量的引用计数器减一，当减到0的时候，就会回收该变量。</strong>对于自定义类，del 关键字是调用类中的 <strong>del</strong> 方法。</p>
<ul>
<li>CPython使用垃圾回收算法是引用计数的方式</li>
</ul>
<p>先建立a，让b，c同时指向a所指向的内存此时引用计数值为3，del a之后引用计数为2，最后程序结束删除对象</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        print(<span class="string">"init:"</span> + name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"del:"</span> + self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A(<span class="string">"a"</span>)  <span class="comment"># init:a</span></span><br><span class="line">b = a</span><br><span class="line">c = a</span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line">c.name = <span class="string">"c"</span></span><br><span class="line">print(b.name)  <span class="comment"># c</span></span><br><span class="line">b.name = <span class="string">"b"</span></span><br><span class="line">print(b.name)  <span class="comment"># b  </span></span><br><span class="line">最后执行<span class="keyword">del</span>:b</span><br></pre></td></tr></table></figure>
<h3 id="3-一个经典的参数引用错误"><a href="#3-一个经典的参数引用错误" class="headerlink" title="3. 一个经典的参数引用错误"></a>3. 一个经典的参数引用错误</h3><blockquote>
<p>下面的例子诠释了传递 list 导致的对象成员值相互污染。解决办法是：传递 tuple。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, staffs=[])</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.staffs = staffs</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, staff_name)</span>:</span></span><br><span class="line">        self.staffs.append(staff_name)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, staff_name)</span>:</span></span><br><span class="line">        self.staffs.remove(staff_name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    com1 = Company(<span class="string">"com1"</span>, [<span class="string">"bobby1"</span>, <span class="string">"bobby2"</span>])</span><br><span class="line">    com1.add(<span class="string">"bobby3"</span>)</span><br><span class="line">    com1.remove(<span class="string">"bobby1"</span>)</span><br><span class="line">    <span class="keyword">print</span> (com1.staffs)</span><br><span class="line"></span><br><span class="line">    com2 = Company(<span class="string">"com2"</span>)</span><br><span class="line">    com2.add(<span class="string">"bobby"</span>)</span><br><span class="line">    print(com2.staffs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> (Company.__init__.__defaults__)</span><br><span class="line"></span><br><span class="line">    com3 = Company(<span class="string">"com3"</span>)</span><br><span class="line">    com3.add(<span class="string">"bobby5"</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment"># 下面会发现 com2 和 com3 的 staffs 成员值一样，这是由于 list 是可变对象的缘故</span></span><br><span class="line">    <span class="keyword">print</span> (com2.staffs)</span><br><span class="line">    <span class="keyword">print</span> (com3.staffs)</span><br><span class="line">    <span class="keyword">print</span> (com2.staffs <span class="keyword">is</span> com3.staffs)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>gc</tag>
      </tags>
  </entry>
  <entry>
    <title>python -- 协程和异步</title>
    <url>/2019/07/05/python-%E5%8D%8F%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5/</url>
    <content><![CDATA[<h4 id="1-并发、并行、同步、异步、阻塞、非阻塞"><a href="#1-并发、并行、同步、异步、阻塞、非阻塞" class="headerlink" title="1. 并发、并行、同步、异步、阻塞、非阻塞"></a>1. 并发、并行、同步、异步、阻塞、非阻塞</h4><blockquote>
<p>并发：一个时间段内，有几个程序在同一个 CPU 上运行，但是任意时刻只有一个程序在 CPU 上运行。<br>并行：在任意时刻点上，有多个程序同时运行在<strong>多个 CPU </strong>上。如果 CPU 有个四颗，那么并行最多只有四个。<br>基于以上，我们都说高并发，不说高并行。<br>同步：指代码调用 IO 操作时，必须等待 IO 操作完成才返回的调用方式。<br>异步：指代码调用 IO 操作时，不必等 IO 操作完成就返回的调用方式。<br>阻塞：指调用函数时，当前线程被挂起。<br>非阻塞：指调用函数时，当前线程不会被挂起，而是立即返回。<br>阻塞和非阻塞是说的函数调用的一种机制。</p>
</blockquote>
<a id="more"></a>
<h3 id="C10k问题："><a href="#C10k问题：" class="headerlink" title="C10k问题："></a>C10k问题：</h3><blockquote>
<p>何如在一颗1Ghz CPU，2G内存，1gbps网络环境下，让单台服务器为1万个客户端提供FTP服务</p>
<p>处理用户的并发可以使用threading线程，模式来完成，但是一个线程只能处理一个socket,一个线程处理一个用户，几乎不可能完成上万用户的，如何在服务器上处理多个用户请求</p>
</blockquote>
<h3 id="2-IO-多路复用"><a href="#2-IO-多路复用" class="headerlink" title="2. IO 多路复用"></a>2. IO 多路复用</h3><h3 id="2-1-Unix-下的五种-IO-模型"><a href="#2-1-Unix-下的五种-IO-模型" class="headerlink" title="2.1 Unix 下的五种 IO 模型"></a>2.1 Unix 下的五种 IO 模型</h3><ol>
<li>阻塞式 IO</li>
<li>非阻塞式 IO</li>
<li>IO 复用</li>
<li>信号驱动式 IO</li>
<li>异步 IO （POSIX 的 aio 系列函数）</li>
</ol>
<h3 id="2-2-阻塞式-IO"><a href="#2-2-阻塞式-IO" class="headerlink" title="2.2 阻塞式 IO"></a>2.2 阻塞式 IO</h3><p><img src="https://img-blog.csdnimg.cn/20181220170934897.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215b25lbG90dXM=,size_16,color_FFFFFF,t_70" alt=""></p>
<blockquote>
<p>在发起 IO 请求后，当前线程会阻塞，直到响应请求。当前线程阻塞后，就会造成 CPU 等待，造成 CPU 资源浪费。</p>
</blockquote>
<h3 id="2-3-非阻塞式-IO"><a href="#2-3-非阻塞式-IO" class="headerlink" title="2.3 非阻塞式 IO"></a>2.3 非阻塞式 IO</h3><p><img src="https://img-blog.csdnimg.cn/20181220171045861.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215b25lbG90dXM=,size_16,color_FFFFFF,t_70" alt=""></p>
<blockquote>
<p>当发起 IO 请求后，需要不停的发起请求询问是否完成响应，通常这种询问是放在 while 循环里面完成的，但是，while 循环是非常耗费 CPU 的。而之前的阻塞式 IO 是不需要耗费 CPU，它只是当前线程被阻塞了而已。由此可知，并不是非阻塞式 IO 就比阻塞式 IO 好，实际开发中需要根据实际情况做具体分析。<br>阻塞和非阻塞 IO 方式都是调用系统级的recvfrom函数。同时，这两种模型都需要将系统地址空间中的数据报拷贝到用户地址空间。不懂的同学需要补充操作系统知识。</p>
</blockquote>
<h3 id="2-4-复用-IO"><a href="#2-4-复用-IO" class="headerlink" title="2.4 复用 IO"></a>2.4 复用 IO</h3><p><img src="https://img-blog.csdnimg.cn/20181220170809848.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215b25lbG90dXM=,size_16,color_FFFFFF,t_70" alt=""></p>
<blockquote>
<p>复用 IO 模型克服了非阻塞式 IO 的缺点，避免了不停发请求造成的 CPU 资源浪费。这里调用的是系统级别的 select函数，等响应完成后通知发起请求的线程。select 是一个阻塞方法，在发起请求后阻塞当前线程。 select 和使用 while 循环方式的一个很大的不同点在于：select 可以监听多个请求线程句柄。一旦其中某个线程句柄状态发生变化，就可以立即处理这个响应完成的线程。<br>但是，这种模式依然需要将数据报从系统地址空间拷贝到用户地址空间，这也需要时间。<br>这种方式使用的非常广泛。</p>
</blockquote>
<h3 id="2-5-信号驱动式-IO"><a href="#2-5-信号驱动式-IO" class="headerlink" title="2.5 信号驱动式 IO"></a>2.5 信号驱动式 IO</h3><p><img src="https://img-blog.csdnimg.cn/2018122017244488.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215b25lbG90dXM=,size_16,color_FFFFFF,t_70" alt=""></p>
<blockquote>
<blockquote>
<p>这种方式是基于信号处理的，目前使用很少。</p>
</blockquote>
</blockquote>
<h3 id="2-6-异步-IO"><a href="#2-6-异步-IO" class="headerlink" title="2.6 异步 IO"></a>2.6 异步 IO</h3><p><img src="https://img-blog.csdnimg.cn/20181220172710413.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215b25lbG90dXM=,size_16,color_FFFFFF,t_70" alt=""></p>
<blockquote>
<p>这种方式才是真正的异步 IO，但是这种方式并没有大规模应用，很多高并发框架也都没有采用这种方式，复用 IO 方式比较成熟，也比较稳定。并且，异步 IO 在实际使用过程中，aio_read 并没有发现有多大的提升。此外，这种方式编程难度比复用 IO 方式难。<br>这种方式省略了通知准备好数据报请求的时间。</p>
</blockquote>
<h3 id="2-7-select-poll-epoll-系统函数"><a href="#2-7-select-poll-epoll-系统函数" class="headerlink" title="2.7 select, poll, epoll 系统函数"></a>2.7 select, poll, epoll 系统函数</h3><p><img src="https://img-blog.csdnimg.cn/20181220173540552.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215b25lbG90dXM=,size_16,color_FFFFFF,t_70" alt=""></p>
<p><img src="https://img-blog.csdnimg.cn/2018122017370667.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215b25lbG90dXM=,size_16,color_FFFFFF,t_70" alt=""></p>
<p><img src="https://img-blog.csdnimg.cn/20181220173915308.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215b25lbG90dXM=,size_16,color_FFFFFF,t_70" alt=""></p>
<blockquote>
<blockquote>
<p>poll 和 select 一样，都需要轮询。</p>
</blockquote>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20181220174055959.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215b25lbG90dXM=,size_16,color_FFFFFF,t_70" alt=""></p>
<blockquote>
<p>epoll 只能在 Linux 中使用。epoll 使用红黑树这种数据结构进行查询，效率比较高。<br><strong>但是，并不表示 epoll 一定就比 select 好。</strong> 在并发高的情况下，连接活跃度不是很高， epoll比select好。并发性不高，同时连接很活跃， select比epoll好</p>
</blockquote>
<h3 id="3-使用非阻塞-IO-方式建立-HTTP-请求"><a href="#3-使用非阻塞-IO-方式建立-HTTP-请求" class="headerlink" title="3. 使用非阻塞 IO 方式建立 HTTP 请求"></a>3. 使用非阻塞 IO 方式建立 HTTP 请求</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#通过非阻塞io实现http请求</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用非阻塞io完成http请求</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_url</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="comment">#通过socket请求html</span></span><br><span class="line">    url = urlparse(url)</span><br><span class="line">    host = url.netloc</span><br><span class="line">    path = url.path</span><br><span class="line">    <span class="keyword">if</span> path == <span class="string">""</span>:</span><br><span class="line">        path = <span class="string">"/"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#建立socket连接</span></span><br><span class="line">    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    <span class="comment"># 这一句非常重要，设置非阻塞方式，不管有没有数据准备好都是返回的</span></span><br><span class="line">    client.setblocking(<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        client.connect((host, <span class="number">80</span>)) <span class="comment">#阻塞不会消耗cpu</span></span><br><span class="line">    <span class="keyword">except</span> BlockingIOError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#不停的询问连接是否建立好， 需要while循环不停的去检查状态</span></span><br><span class="line">    <span class="comment">#做计算任务或者再次发起其他的连接请求</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            client.send(<span class="string">"GET &#123;&#125; HTTP/1.1\r\nHost:&#123;&#125;\r\nConnection:close\r\n\r\n"</span>.format(path, host).encode(<span class="string">"utf8"</span>))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> OSError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    data = <span class="string">b""</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            d = client.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">except</span> BlockingIOError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> d:</span><br><span class="line">            data += d</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    data = data.decode(<span class="string">"utf8"</span>)</span><br><span class="line">    html_data = data.split(<span class="string">"\r\n\r\n"</span>)[<span class="number">1</span>]</span><br><span class="line">    print(html_data)</span><br><span class="line">    client.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    get_url(<span class="string">"http://www.baidu.com"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="4-使用多路复用-IO-方式建立网络请求"><a href="#4-使用多路复用-IO-方式建立网络请求" class="headerlink" title="4. 使用多路复用 IO 方式建立网络请求"></a>4. 使用多路复用 IO 方式建立网络请求</h3><p>&gt;</p>
<blockquote>
<p>  下面这种方式的好处是并发性高，重点掌握。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过多路复用 IO 实现http请求</span></span><br><span class="line"><span class="comment"># 实现方式：select + 回调 + 事件循环</span></span><br><span class="line"><span class="comment"># 好处是：并发性高</span></span><br><span class="line"><span class="comment"># 使用单线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"><span class="comment"># 通常不实用  import select，而是使用 from selectors</span></span><br><span class="line"><span class="comment"># selectors 进行了封装。DefaultSelector 封装的更好用，调用 select 方法的时候，会根据平台选择使用 epoll 还是 select。避免了 epoll 在 Windows 下不能使用的情况。</span></span><br><span class="line"><span class="comment"># 在 Linux 下使用 epoll，在 Windows 下使用 select 方法</span></span><br><span class="line"><span class="keyword">from</span> selectors <span class="keyword">import</span> DefaultSelector, EVENT_READ, EVENT_WRITE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">selector = DefaultSelector()</span><br><span class="line"><span class="comment"># 使用select完成http请求</span></span><br><span class="line">urls = []</span><br><span class="line">stop = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fetcher</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connected</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="comment"># 在 send 之前，需要取消注册。</span></span><br><span class="line">        <span class="comment"># key.kd 就是 self.client.fileno() 的返回值</span></span><br><span class="line">        selector.unregister(key.fd)</span><br><span class="line">        <span class="comment"># 在这里不需要再 try/catch，因为 connected 函数在调用的时候就已经表示时间就绪了</span></span><br><span class="line">        self.client.send(<span class="string">"GET &#123;&#125; HTTP/1.1\r\nHost:&#123;&#125;\r\nConnection:close\r\n\r\n"</span>.format(</span><br><span class="line">            self.path, self.host).encode(<span class="string">"utf8"</span>))</span><br><span class="line">        <span class="comment"># 已经发送了数据，等到响应返回，故应该是读事件</span></span><br><span class="line">        <span class="comment"># 这里是 self.readable，不是 self.readable()</span></span><br><span class="line">        selector.register(self.client.fileno(), EVENT_READ, self.readable)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">readable</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="comment"># 这里读数据没有放在 While True 中</span></span><br><span class="line">        <span class="comment"># readable 函数在每次可读的时候，会被自动调用，不再需要自己不停的读</span></span><br><span class="line">        <span class="comment"># 将读完的数据放到一个外部的变量中 self.data</span></span><br><span class="line">        d = self.client.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> d:</span><br><span class="line">            self.data += d</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            selector.unregister(key.fd)</span><br><span class="line">            data = self.data.decode(<span class="string">"utf8"</span>)</span><br><span class="line">            html_data = data.split(<span class="string">"\r\n\r\n"</span>)[<span class="number">1</span>]</span><br><span class="line">            print(html_data)</span><br><span class="line">            self.client.close()</span><br><span class="line">            urls.remove(self.spider_url)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> urls:</span><br><span class="line">                <span class="keyword">global</span> stop</span><br><span class="line">                stop = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_url</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        self.spider_url = url</span><br><span class="line">        url = urlparse(url)</span><br><span class="line">        self.host = url.netloc</span><br><span class="line">        self.path = url.path</span><br><span class="line">        self.data = <span class="string">b""</span></span><br><span class="line">        <span class="keyword">if</span> self.path == <span class="string">""</span>:</span><br><span class="line">            self.path = <span class="string">"/"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 建立socket连接</span></span><br><span class="line">        <span class="comment"># 这里将 client 设置为 self，因为回调函数会用到</span></span><br><span class="line">        self.client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        self.client.setblocking(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.client.connect((self.host, <span class="number">80</span>))</span><br><span class="line">        <span class="keyword">except</span> BlockingIOError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 注册</span></span><br><span class="line">        <span class="comment"># 第一个参数：文件描述符；第二个参数：事件；第三个：回调函数，即当事件可写的时候，执行什么函数逻辑</span></span><br><span class="line">        selector.register(self.client.fileno(), EVENT_WRITE, self.connected)</span><br><span class="line"></span><br><span class="line"><span class="comment"># loop 函数是实现的核心</span></span><br><span class="line"><span class="comment"># 回调是需要自己来做的，并不是操作系统调用回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 事件循环，不停的请求socket的状态并调用对应的回调函数</span></span><br><span class="line">    <span class="comment"># 事件循环这种模式在使用 IO 多路复用方式时会大量存在。</span></span><br><span class="line">    <span class="comment"># 1. select本身是不支持register模式。selector 对 select 进行了封装，故可以支持 register</span></span><br><span class="line">    <span class="comment"># 2. socket状态变化以后的回调是由程序员完成的</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> stop:</span><br><span class="line">        <span class="comment"># 这里的 stop 是全局变量</span></span><br><span class="line">        <span class="comment"># selector.select() 在 Windows 下面调用的是 select 方法，注意，当传入的列表为空时，会报错</span></span><br><span class="line">        <span class="comment"># 这也是为啥设置了一个全局 stop 变量。注意和 readable() 中的代码结合起来看，需要仔细体会。为了解决这个问题，还设置了一个 urls = [] 和 self.spider_url = url</span></span><br><span class="line">        ready = selector.select()</span><br><span class="line">        <span class="keyword">for</span> key, mask <span class="keyword">in</span> ready:</span><br><span class="line">            call_back = key.data</span><br><span class="line">            call_back(key)</span><br><span class="line">    <span class="comment"># 回调+事件循环+select(poll\epoll)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    fetcher = Fetcher()</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        url = <span class="string">"http://shop.projectsedu.com/goods/&#123;&#125;/"</span>.format(url)</span><br><span class="line">        urls.append(url)</span><br><span class="line">        fetcher = Fetcher()</span><br><span class="line">        fetcher.get_url(url)</span><br><span class="line">    loop()</span><br><span class="line">    print(time.time()-start_time)</span><br></pre></td></tr></table></figure>
<h1 id="5-协程"><a href="#5-协程" class="headerlink" title="5. 协程"></a>5. 协程</h1><h2 id="5-1-回调之痛"><a href="#5-1-回调之痛" class="headerlink" title="5.1 回调之痛"></a>5.1 回调之痛</h2><blockquote>
<p>上面的代码使用了回调，回调虽然有比较高的性能，但是有一些明显的缺点。缺点主要有以下三点：</p>
</blockquote>
<ol>
<li>可读性差；</li>
<li>共享状态管理困难；</li>
<li>异常处理困难；</li>
</ol>
<blockquote>
<p>为了解决回调的缺点，解决的办法是：</p>
</blockquote>
<ol>
<li>采用同步的方式去编写异步代码</li>
<li>使用单线程去切换任务：<ol>
<li>线程是由操作系统切换的，单线程切换意味着我们需要程序员自己去调度任务；</li>
<li>不再需要锁，并发性高，如果单线程内切换函数，性能远高于线程切换，并发性更高</li>
</ol>
</li>
</ol>
<h3 id="5-2-生成器进阶"><a href="#5-2-生成器进阶" class="headerlink" title="5.2 生成器进阶"></a>5.2 生成器进阶</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">协程，也被称作有多个入口的函数，或者可以暂停的函数（可以向暂停的地方传入值）。协程的实现方式：生成器。协程是函数级别的调用，由程序员决定自己调用逻辑。线程和进程是系统级别的调用。</span><br><span class="line">生成器：</span><br><span class="line"></span><br><span class="line">生成器不止可以产生值，还可以接收值</span><br><span class="line">下面介绍三个方法，通过这生成器中的这三个方法实现协程。</span><br></pre></td></tr></table></figure>
<h3 id="5-2-1-send-方法"><a href="#5-2-1-send-方法" class="headerlink" title="5.2.1 send 方法"></a>5.2.1 send 方法</h3><blockquote>
<p>send方法可以传递值进入生成器内部，同时还可以重启生成器执行到下一个yield位置。<br>send 方法启用生成器时，需要先 send(None)，以使生成器启用。而 next 方法不需要。<br>除了 send 方法之外，生成器启用的另一个方式是 next 方法，next(gen)。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 下面这行代码有两个作用：</span></span><br><span class="line">    <span class="comment"># 1. 可以产出值， 2. 可以接收值(调用方传递进来的值)</span></span><br><span class="line">    <span class="comment"># 在运行 html = "bobby" 和 gen.send(html) 之后，会打印 bobby，表明可以接收外面传进来的值</span></span><br><span class="line">    html = <span class="keyword">yield</span> <span class="string">"http://projectsedu.com"</span></span><br><span class="line">    print(html)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"bobby"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    gen = gen_func()</span><br><span class="line">    <span class="comment"># 在调用send发送非none值之前，我们必须启动一次生成器， 方式有两种1. gen.send(None), 2. next(gen)</span></span><br><span class="line">    url = gen.send(<span class="literal">None</span>)</span><br><span class="line">    <span class="comment"># download url</span></span><br><span class="line">    html = <span class="string">"bobby"</span></span><br><span class="line">    print(gen.send(html))  <span class="comment"># send方法可以传递值进入生成器内部，同时还可以重启生成器执行到下一个yield位置</span></span><br><span class="line">    print(gen.send(html))</span><br></pre></td></tr></table></figure>
<h3 id="5-2-2-close-方法"><a href="#5-2-2-close-方法" class="headerlink" title="5.2.2 close 方法"></a>5.2.2 close 方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 1. 可以产出值， 2. 可以接收值(调用方传递进来的值)</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">"http://projectsedu.com"</span></span><br><span class="line">    <span class="comment"># GeneratorExit是继承自BaseException， 不是继承Exception</span></span><br><span class="line">    <span class="comment"># 捕捉 GeneratorExit 或者 BaseException 都会报错，捕捉 Exception 不会报错</span></span><br><span class="line">    <span class="keyword">except</span> GeneratorExit:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"bobby"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    gen = gen_func()</span><br><span class="line">    print(next(gen))</span><br><span class="line">    <span class="comment"># 第一点：调用 close 方法后，如果后面的代码还有 yield 会抛出 GeneratorExit 异常。</span></span><br><span class="line">    <span class="comment"># 上面的例子中，后面有 yield 2 和 yield 3。如果注释掉这两行，close 是不会报错的。</span></span><br><span class="line">    <span class="comment"># 第二点：但是，close 之后，如果再执行 next(gen)，会抛出 StopIteration 异常。</span></span><br><span class="line">    <span class="comment"># 第三点：上面的例子，对 yield "http://projectsedu.com" 进行了 try/catch，会报 RuntimeError 异常。</span></span><br><span class="line">    <span class="comment"># 第三点：不要擅自进行 try/catch。如果 try/catch，需要在 catch 中抛出 raise StopIteration。</span></span><br><span class="line">    gen.close()</span><br><span class="line">    print(<span class="string">"bobby"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="5-2-3-throw-方法"><a href="#5-2-3-throw-方法" class="headerlink" title="5.2.3 throw 方法"></a>5.2.3 throw 方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#1. 可以产出值， 2. 可以接收值(调用方传递进来的值)</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">"http://projectsedu.com"</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"bobby"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    gen = gen_func()</span><br><span class="line">    print(next(gen))</span><br><span class="line">    <span class="comment"># 下面这一句的异常是第 4 行的异常，返回值是 2</span></span><br><span class="line">    gen.throw(Exception, <span class="string">"download error"</span>)</span><br><span class="line">    <span class="comment"># 打印值是 3</span></span><br><span class="line">    print(next(gen))</span><br><span class="line">    gen.throw(Exception, <span class="string">"download error"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="5-3-yield-from-语法"><a href="#5-3-yield-from-语法" class="headerlink" title="5.3 yield from 语法"></a>5.3 yield from 语法</h3><h3 id="5-3-1-yield-和-yield-from-的区别"><a href="#5-3-1-yield-和-yield-from-的区别" class="headerlink" title="5.3.1 yield 和 yield from 的区别"></a>5.3.1 yield 和 yield from 的区别</h3><blockquote>
<p>yield from 后面接一个 iterable 对象。yield from 不仅仅是不断的 yield iterable 中的值，还进行了很多额外的操作，参考源码即可。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line"></span><br><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">my_dict = &#123;</span><br><span class="line">    <span class="string">"url1"</span>: <span class="string">"http://www.baidu.com"</span>,</span><br><span class="line">    <span class="string">"url2"</span>: <span class="string">"http://www.google.com"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># for value in chain(my_list, my_dict, range(5, 10)):</span></span><br><span class="line"><span class="comment">#     print(value)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># chain 内部的实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别使用yield / yield from</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_chain</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> my_iterable <span class="keyword">in</span> args:</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> my_iterable</span><br><span class="line">        <span class="comment"># for value in my_iterable:</span></span><br><span class="line">        <span class="comment">#     yield value</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> my_chain(my_list, my_dict, range(<span class="number">5</span>, <span class="number">10</span>)):</span><br><span class="line">    print(value)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g1</span><span class="params">(iterable)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> iterable</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g2</span><span class="params">(iterable)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> iterable</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> g1(range(<span class="number">10</span>)):</span><br><span class="line">    print(value)</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> g2(range(<span class="number">10</span>)):</span><br><span class="line">    print(value)</span><br></pre></td></tr></table></figure>
<h3 id="5-3-2-yield-from-完成统计销量"><a href="#5-3-2-yield-from-完成统计销量" class="headerlink" title="5.3.2 yield from 完成统计销量"></a>5.3.2 yield from 完成统计销量</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">final_result = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sales_sum</span><span class="params">(pro_name)</span>:</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    nums = []</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        x = <span class="keyword">yield</span></span><br><span class="line">        print(pro_name+<span class="string">"销量: "</span>, x)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> x:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        total += x</span><br><span class="line">        nums.append(x)</span><br><span class="line">    <span class="keyword">return</span> total, nums</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">middle</span><span class="params">(key)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># sales_sum 中的返回值是两个元素，故 final_result 中的 value 是 tuple</span></span><br><span class="line">        final_result[key] = <span class="keyword">yield</span> <span class="keyword">from</span> sales_sum(key)</span><br><span class="line">        print(key+<span class="string">"销量统计完成！！."</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    data_sets = &#123;</span><br><span class="line">        <span class="string">"bobby牌面膜"</span>: [<span class="number">1200</span>, <span class="number">1500</span>, <span class="number">3000</span>],</span><br><span class="line">        <span class="string">"bobby牌手机"</span>: [<span class="number">28</span>,<span class="number">55</span>,<span class="number">98</span>,<span class="number">108</span> ],</span><br><span class="line">        <span class="string">"bobby牌大衣"</span>: [<span class="number">280</span>,<span class="number">560</span>,<span class="number">778</span>,<span class="number">70</span>],</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> key, data_set <span class="keyword">in</span> data_sets.items():</span><br><span class="line">        print(<span class="string">"start key:"</span>, key)</span><br><span class="line">        <span class="comment"># 在 middle 方法中，调用了 yield from，从而将 yield from sales_sum(key) 的返回值和 当前的 main 函数建立了双向通道 </span></span><br><span class="line">        m = middle(key)</span><br><span class="line">        m.send(<span class="literal">None</span>) <span class="comment"># 预激middle协程</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> data_set:</span><br><span class="line">            <span class="comment"># 不断地向 sales_sum 中发送值，值会被传到 x = yield 中（重点）</span></span><br><span class="line">            m.send(value)   <span class="comment"># 给协程传递每一组的值</span></span><br><span class="line">        <span class="comment"># 下面一行代码会导致 sales_sum 函数中 if not x: break，进而运行 return 语句，从而导致抛出 StopIteration</span></span><br><span class="line">        m.send(<span class="literal">None</span>)</span><br><span class="line">    print(<span class="string">"final_result:"</span>, final_result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>上面的例子，如果不使用 yield from，使用 yield 需要自己处理 StopIteration 异常。</p>
</blockquote>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">final_result = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sales_sum</span><span class="params">(pro_name)</span>:</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    nums = []</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        x = <span class="keyword">yield</span></span><br><span class="line">        print(pro_name+<span class="string">"销量: "</span>, x)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> x:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        total += x</span><br><span class="line">        nums.append(x)</span><br><span class="line">    <span class="keyword">return</span> total, nums</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    my_gen = sales_sum(<span class="string">"bobby牌手机"</span>)</span><br><span class="line">    my_gen.send(<span class="literal">None</span>)</span><br><span class="line">    my_gen.send(<span class="number">1200</span>)</span><br><span class="line">    my_gen.send(<span class="number">1500</span>)</span><br><span class="line">    my_gen.send(<span class="number">3000</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 下面一行代码会导致 sales_sum 函数中 if not x: break，进而运行 return 语句，从而导致抛出 StopIteration</span></span><br><span class="line">        my_gen.send(<span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">        result = e.value</span><br><span class="line">        print(result)</span><br></pre></td></tr></table></figure>
<h3 id="5-3-3-yield-from-深入分析"><a href="#5-3-3-yield-from-深入分析" class="headerlink" title="5.3.3 yield from 深入分析"></a>5.3.3 yield from 深入分析</h3><blockquote>
<blockquote>
<p>下面的代码非常有难度，只建议有非常扎实基础的人学习。</p>
</blockquote>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pep380</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. RESULT = yield from EXPR可以简化成下面这样</span></span><br><span class="line"><span class="comment"># 一些说明</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">_i：子生成器，同时也是一个迭代器</span></span><br><span class="line"><span class="string">_y：子生成器生产的值</span></span><br><span class="line"><span class="string">_r：yield from 表达式最终的值</span></span><br><span class="line"><span class="string">_s：调用方通过send()发送的值</span></span><br><span class="line"><span class="string">_e：异常对象</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">_i = iter(EXPR)      <span class="comment"># EXPR是一个可迭代对象，_i其实是子生成器；</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    _y = next(_i)   <span class="comment"># 预激子生成器，把产出的第一个值存在_y中；</span></span><br><span class="line"><span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e:</span><br><span class="line">    _r = _e.value   <span class="comment"># 如果抛出了`StopIteration`异常，那么就将异常对象的`value`属性保存到_r，这是最简单的情况的返回值；</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:    <span class="comment"># 尝试执行这个循环，委托生成器会阻塞；</span></span><br><span class="line">        _s = <span class="keyword">yield</span> _y   <span class="comment"># 生产子生成器的值，等待调用方`send()`值，发送过来的值将保存在_s中；</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            _y = _i.send(_s)    <span class="comment"># 转发_s，并且尝试向下执行；</span></span><br><span class="line">        <span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e:</span><br><span class="line">            _r = _e.value       <span class="comment"># 如果子生成器抛出异常，那么就获取异常对象的`value`属性存到_r，退出循环，恢复委托生成器的运行；</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">RESULT = _r     <span class="comment"># _r就是整个yield from表达式返回的值。</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">1. 子生成器可能只是一个迭代器，并不是一个作为协程的生成器，所以它不支持.throw()和.close()方法；</span></span><br><span class="line"><span class="string">2. 如果子生成器支持.throw()和.close()方法，但是在子生成器内部，这两个方法都会抛出异常；</span></span><br><span class="line"><span class="string">3. 调用方让子生成器自己抛出异常</span></span><br><span class="line"><span class="string">4. 当调用方使用next()或者.send(None)时，都要在子生成器上调用next()函数，当调用方使用.send()发送非 None 值时，才调用子生成器的.send()方法；</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">_i = iter(EXPR)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    _y = next(_i)</span><br><span class="line"><span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e:</span><br><span class="line">    _r = _e.value</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            _s = <span class="keyword">yield</span> _y</span><br><span class="line">        <span class="keyword">except</span> GeneratorExit <span class="keyword">as</span> _e:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                _m = _i.close</span><br><span class="line">            <span class="keyword">except</span> AttributeError:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                _m()</span><br><span class="line">            <span class="keyword">raise</span> _e</span><br><span class="line">        <span class="keyword">except</span> BaseException <span class="keyword">as</span> _e:</span><br><span class="line">            _x = sys.exc_info()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                _m = _i.throw</span><br><span class="line">            <span class="keyword">except</span> AttributeError:</span><br><span class="line">                <span class="keyword">raise</span> _e</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    _y = _m(*_x)</span><br><span class="line">                <span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e:</span><br><span class="line">                    _r = _e.value</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> _s <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    _y = next(_i)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    _y = _i.send(_s)</span><br><span class="line">            <span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e:</span><br><span class="line">                _r = _e.value</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">RESULT = _r</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">看完代码，我们总结一下关键点：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. 子生成器生产的值，都是直接传给调用方的；调用方通过.send()发送的值都是直接传递给子生成器的；如果发送的是 None，会调用子生成器的__next__()方法，如果不是 None，会调用子生成器的.send()方法；</span></span><br><span class="line"><span class="string">2. 子生成器退出的时候，最后的return EXPR，会触发一个StopIteration(EXPR)异常；</span></span><br><span class="line"><span class="string">3. yield from表达式的值，是子生成器终止时，传递给StopIteration异常的第一个参数；</span></span><br><span class="line"><span class="string">4. 如果调用的时候出现StopIteration异常，委托生成器会恢复运行，同时其他的异常会向上 "冒泡"；</span></span><br><span class="line"><span class="string">5. 传入委托生成器的异常里，除了GeneratorExit之外，其他的所有异常全部传递给子生成器的.throw()方法；如果调用.throw()的时候出现了StopIteration异常，那么就恢复委托生成器的运行，其他的异常全部向上 "冒泡"；</span></span><br><span class="line"><span class="string">6. 如果在委托生成器上调用.close()或传入GeneratorExit异常，会调用子生成器的.close()方法，没有的话就不调用。如果在调用.close()的时候抛出了异常，那么就向上 "冒泡"，否则的话委托生成器会抛出GeneratorExit异常。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<h3 id="5-4-async-和-wait-定义原生的协程"><a href="#5-4-async-和-wait-定义原生的协程" class="headerlink" title="5.4 async 和 wait 定义原生的协程"></a>5.4 async 和 wait 定义原生的协程</h3><blockquote>
<p><strong>前面是使用 yield from 实现的协程，但是这种方式过于底层。python 提供了async和await关键词用于定义原生的协程。在实际开发中，建议使用这种方式。</strong>前文的大幅章节主要用于帮助理解协程，以及协程怎么实现。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#python为了将语义变得更加明确，就引入了async和await关键词用于定义原生的协程</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">downloader</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"bobby"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 async 中不能使用 yield</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">download_url</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="comment">#dosomethings</span></span><br><span class="line">    html = <span class="keyword">await</span> downloader(url)</span><br><span class="line">    <span class="keyword">return</span> html</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    coro = download_url(<span class="string">"http://www.imooc.com"</span>)</span><br><span class="line">    <span class="comment"># 不能这样调用 next(None)，应该使用下面这种方式，否则会报错</span></span><br><span class="line">    coro.send(<span class="literal">None</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>await 关键字后面只能接 Awaitable 对象。await 后面的对象不能包含 yield 关键字，即下面代码的第一种实现。当使用了 types.coroutine 装饰后，就变成了 Awaitable 对象，也就不会报错了。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloader</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"bobby"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> types</span><br><span class="line"></span><br><span class="line"><span class="meta">@types.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloader</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"bobby"</span></span><br></pre></td></tr></table></figure>
<h3 id="5-5-生成器是有状态的"><a href="#5-5-生成器是有状态的" class="headerlink" title="5.5 生成器是有状态的"></a>5.5 生成器是有状态的</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过 inspect 模块获取生成器的状态</span></span><br><span class="line"><span class="comment"># 比如：inspect.getgeneratorstate(gen)</span></span><br><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 下面这句有两层含义：</span></span><br><span class="line">    <span class="comment"># 第一：返回值给调用方； 第二： 调用方通过send方式返回值给gen</span></span><br><span class="line">    value=<span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"bobby"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    gen = gen_func()</span><br><span class="line">    print(inspect.getgeneratorstate(gen))</span><br><span class="line">    next(gen)</span><br><span class="line">    print(inspect.getgeneratorstate(gen))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        next(gen)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    print(inspect.getgeneratorstate(gen))</span><br></pre></td></tr></table></figure>
<h3 id="6-多路复用实现聊天群"><a href="#6-多路复用实现聊天群" class="headerlink" title="6. 多路复用实现聊天群"></a>6. 多路复用实现聊天群</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Server 端</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">server select</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">g_select_timeout = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, host=<span class="string">'0.0.0.0'</span>, port=<span class="number">3333</span>, timeout=<span class="number">2</span>, client_nums=<span class="number">10</span>)</span>:</span></span><br><span class="line">        self.__host = host</span><br><span class="line">        self.__port = port</span><br><span class="line">        self.__timeout = timeout</span><br><span class="line">        self.__client_nums = client_nums</span><br><span class="line">        self.__buffer_size = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">        self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        self.server.setblocking(<span class="literal">False</span>)</span><br><span class="line">        self.server.settimeout(self.__timeout)</span><br><span class="line">        self.server.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, <span class="number">1</span>)  <span class="comment"># keepalive</span></span><br><span class="line">        self.server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)  <span class="comment"># 端口复用</span></span><br><span class="line">        server_host = (self.__host, self.__port)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.server.bind(server_host)</span><br><span class="line">            self.server.listen(self.__client_nums)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">        self.inputs = [self.server]  <span class="comment"># select 接收文件描述符列表</span></span><br><span class="line">        self.outputs = []  <span class="comment"># 输出文件描述符列表</span></span><br><span class="line">        self.message_queues = &#123;&#125;  <span class="comment"># 消息队列</span></span><br><span class="line">        self.client_info = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            readable, writable, exceptional = select.select(self.inputs, self.outputs, self.inputs, g_select_timeout)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (readable <span class="keyword">or</span> writable <span class="keyword">or</span> exceptional):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> readable:</span><br><span class="line">                <span class="keyword">if</span> s <span class="keyword">is</span> self.server:  <span class="comment"># 是客户端连接</span></span><br><span class="line">                    connection, client_address = s.accept()</span><br><span class="line">                    <span class="comment"># print "connection", connection</span></span><br><span class="line">                    print(<span class="string">"%s connect."</span> % str(client_address))</span><br><span class="line">                    connection.setblocking(<span class="number">0</span>)  <span class="comment"># 非阻塞</span></span><br><span class="line">                    self.inputs.append(connection)  <span class="comment"># 客户端添加到inputs</span></span><br><span class="line">                    self.client_info[connection] = str(client_address)</span><br><span class="line">                    self.message_queues[connection] = Queue()  <span class="comment"># 每个客户端一个消息队列</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># 是client, 数据发送过来</span></span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        data = s.recv(self.__buffer_size)</span><br><span class="line">                    <span class="keyword">except</span>:</span><br><span class="line">                        err_msg = <span class="string">"Client Error!"</span></span><br><span class="line">                        logging.error(err_msg)</span><br><span class="line">                    <span class="keyword">if</span> data:</span><br><span class="line">                        <span class="comment"># print data</span></span><br><span class="line">                        data = <span class="string">"%s %s say: %s"</span> % (time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>), self.client_info[s], data)</span><br><span class="line">                        self.message_queues[s].put(data)  <span class="comment"># 队列添加消息</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> s <span class="keyword">not</span> <span class="keyword">in</span> self.outputs:  <span class="comment"># 要回复消息</span></span><br><span class="line">                            self.outputs.append(s)</span><br><span class="line">                    <span class="keyword">else</span>:  <span class="comment"># 客户端断开</span></span><br><span class="line">                        <span class="comment"># Interpret empty result as closed connection</span></span><br><span class="line">                        <span class="keyword">print</span></span><br><span class="line">                        <span class="string">"Client:%s Close."</span> % str(self.client_info[s])</span><br><span class="line">                        <span class="keyword">if</span> s <span class="keyword">in</span> self.outputs:</span><br><span class="line">                            self.outputs.remove(s)</span><br><span class="line">                        self.inputs.remove(s)</span><br><span class="line">                        s.close()</span><br><span class="line">                        <span class="keyword">del</span> self.message_queues[s]</span><br><span class="line">                        <span class="keyword">del</span> self.client_info[s]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> writable:  <span class="comment"># outputs 有消息就要发出去了</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    next_msg = self.message_queues[s].get_nowait()  <span class="comment"># 非阻塞获取</span></span><br><span class="line">                <span class="keyword">except</span> queue.Empty:</span><br><span class="line">                    err_msg = <span class="string">"Output Queue is Empty!"</span></span><br><span class="line">                    <span class="comment"># g_logFd.writeFormatMsg(g_logFd.LEVEL_INFO, err_msg)</span></span><br><span class="line">                    self.outputs.remove(s)</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:  <span class="comment"># 发送的时候客户端关闭了则会出现writable和readable同时有数据，会出现message_queues的keyerror</span></span><br><span class="line">                    err_msg = <span class="string">"Send Data Error! ErrMsg:%s"</span> % str(e)</span><br><span class="line">                    logging.error(err_msg)</span><br><span class="line">                    <span class="keyword">if</span> s <span class="keyword">in</span> self.outputs:</span><br><span class="line">                        self.outputs.remove(s)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">for</span> cli <span class="keyword">in</span> self.client_info:  <span class="comment"># 发送给其他客户端</span></span><br><span class="line">                        <span class="keyword">if</span> cli <span class="keyword">is</span> <span class="keyword">not</span> s:</span><br><span class="line">                            <span class="keyword">try</span>:</span><br><span class="line">                                cli.sendall(next_msg.encode(<span class="string">"utf8"</span>))</span><br><span class="line">                            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:  <span class="comment"># 发送失败就关掉</span></span><br><span class="line">                                err_msg = <span class="string">"Send Data to %s  Error! ErrMsg:%s"</span> % (str(self.client_info[cli]), str(e))</span><br><span class="line">                                logging.error(err_msg)</span><br><span class="line">                                <span class="keyword">print</span></span><br><span class="line">                                <span class="string">"Client: %s Close Error."</span> % str(self.client_info[cli])</span><br><span class="line">                                <span class="keyword">if</span> cli <span class="keyword">in</span> self.inputs:</span><br><span class="line">                                    self.inputs.remove(cli)</span><br><span class="line">                                    cli.close()</span><br><span class="line">                                <span class="keyword">if</span> cli <span class="keyword">in</span> self.outputs:</span><br><span class="line">                                    self.outputs.remove(s)</span><br><span class="line">                                <span class="keyword">if</span> cli <span class="keyword">in</span> self.message_queues:</span><br><span class="line">                                    <span class="keyword">del</span> self.message_queues[s]</span><br><span class="line">                                <span class="keyword">del</span> self.client_info[cli]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> exceptional:</span><br><span class="line">                logging.error(<span class="string">"Client:%s Close Error."</span> % str(self.client_info[cli]))</span><br><span class="line">                <span class="keyword">if</span> s <span class="keyword">in</span> self.inputs:</span><br><span class="line">                    self.inputs.remove(s)</span><br><span class="line">                    s.close()</span><br><span class="line">                <span class="keyword">if</span> s <span class="keyword">in</span> self.outputs:</span><br><span class="line">                    self.outputs.remove(s)</span><br><span class="line">                <span class="keyword">if</span> s <span class="keyword">in</span> self.message_queues:</span><br><span class="line">                    <span class="keyword">del</span> self.message_queues[s]</span><br><span class="line">                <span class="keyword">del</span> self.client_info[s]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">"__main__"</span> == __name__:</span><br><span class="line">    Server().run()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># client 端</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!/usr/local/bin/python</span></span><br><span class="line"><span class="comment"># *-* coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">client.py</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, host, port=<span class="number">3333</span>, timeout=<span class="number">1</span>, reconnect=<span class="number">2</span>)</span>:</span></span><br><span class="line">        self.__host = host</span><br><span class="line">        self.__port = port</span><br><span class="line">        self.__timeout = timeout</span><br><span class="line">        self.__buffer_size = <span class="number">1024</span></span><br><span class="line">        self.__flag = <span class="number">1</span></span><br><span class="line">        self.client = <span class="literal">None</span></span><br><span class="line">        self.__lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flag</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__flag</span><br><span class="line"></span><br><span class="line"><span class="meta">    @flag.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flag</span><span class="params">(self, new_num)</span>:</span></span><br><span class="line">        self.__flag = new_num</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__connect</span><span class="params">(self)</span>:</span></span><br><span class="line">        client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        <span class="comment"># client.bind(('0.0.0.0', 12345,))</span></span><br><span class="line">        client.setblocking(<span class="literal">True</span>)</span><br><span class="line">        client.settimeout(self.__timeout)</span><br><span class="line">        client.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)  <span class="comment"># 端口复用</span></span><br><span class="line">        server_host = (self.__host, self.__port)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            client.connect(server_host)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">        <span class="keyword">return</span> client</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_msg</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.client:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            time.sleep(<span class="number">0.1</span>)</span><br><span class="line">            <span class="comment"># data = raw_input()</span></span><br><span class="line">            data = sys.stdin.readline().strip()</span><br><span class="line">            <span class="keyword">if</span> <span class="string">"exit"</span> == data.lower():</span><br><span class="line">                <span class="keyword">with</span> self.__lock:</span><br><span class="line">                    self.flag = <span class="number">0</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            self.client.sendall(data.encode(<span class="string">"utf8"</span>))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recv_msg</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.client:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            data = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">with</span> self.__lock:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> self.flag:</span><br><span class="line">                    print(<span class="string">'ByeBye~~'</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                data = self.client.recv(self.__buffer_size)</span><br><span class="line">            <span class="keyword">except</span> socket.timeout:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line">            <span class="keyword">if</span> data:</span><br><span class="line">                print(<span class="string">"%s\n"</span> % data)</span><br><span class="line">            time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.client = self.__connect()</span><br><span class="line">        send_proc = threading.Thread(target=self.send_msg)</span><br><span class="line">        recv_proc = threading.Thread(target=self.recv_msg)</span><br><span class="line">        recv_proc.start()</span><br><span class="line">        send_proc.start()</span><br><span class="line">        recv_proc.join()</span><br><span class="line">        send_proc.join()</span><br><span class="line">        self.client.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">"__main__"</span> == __name__:</span><br><span class="line">    Client(<span class="string">'localhost'</span>).run()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行方式：</span></span><br><span class="line"><span class="comment"># 1. 启动server</span></span><br><span class="line"><span class="comment"># python server.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 启动client1</span></span><br><span class="line"><span class="comment"># python client.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动client2</span></span><br><span class="line"><span class="comment"># python client.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在client1的console中输入任何字符串，client2中立马就可以收到</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Coroutine</tag>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>python -- 多线程 多进程 线程池编程</title>
    <url>/2019/05/09/python-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="GIL"><a href="#GIL" class="headerlink" title="GIL"></a>GIL</h3><blockquote>
<p>GIL 全称：global interpreter lock 这是一个基于 C 语言的模块。python中一个线程对应于c语言中的一个线程。GIL 使得同一个时刻只有一个线程在一个cpu上执行字节码, 无法将多个线程映射到多个cpu上执行</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 dis 模块打印函数的字节码</span></span><br><span class="line"><span class="comment"># import dis</span></span><br><span class="line"><span class="comment"># def add(a):</span></span><br><span class="line"><span class="comment">#     a = a+1</span></span><br><span class="line"><span class="comment">#     return a</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># print(dis.dis(add))</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>GIL 并不是在函数执行过程中，一直占有，直到执行完，而是会根据执行的字节码行数以及时间片释放gil。除此之外，gil在遇到io的操作时候主动释放。下面的代码演示了 total 每次运行后的结果都不一样，这说明了 GIL 并不是一直占有的，而是根据时间片和字节码释放 GIL。</p>
</blockquote>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 1. dosomething1</span></span><br><span class="line">    <span class="comment"># 2. io操作</span></span><br><span class="line">    <span class="comment"># 1. dosomething3</span></span><br><span class="line">    <span class="keyword">global</span> total</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        total += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">desc</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> total</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        total -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thread1 = threading.Thread(target=add)</span><br><span class="line">thread2 = threading.Thread(target=desc)</span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line"></span><br><span class="line">thread1.join()</span><br><span class="line">thread2.join()</span><br><span class="line">print(total)</span><br></pre></td></tr></table></figure>
<h3 id="2-多线程编程"><a href="#2-多线程编程" class="headerlink" title="2. 多线程编程"></a>2. 多线程编程</h3><blockquote>
<p>对于io操作来说，多线程和多进程性能差别不大。</p>
</blockquote>
<h3 id="2-1-通过Thread类实例化"><a href="#2-1-通过Thread类实例化" class="headerlink" title="2.1 通过Thread类实例化"></a>2.1 通过Thread类实例化</h3><blockquote>
<p>比较简单的任务或者动态创建线程或者线程池时，可能会使用这种方式。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail_html</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">"get detail html started"</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"get detail html end"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail_url</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">"get detail url started"</span>)</span><br><span class="line">    time.sleep(<span class="number">4</span>)</span><br><span class="line">    print(<span class="string">"get detail url end"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 方式一：通过Thread类实例化</span></span><br><span class="line">    <span class="comment"># 注意这里面传入的是函数名，而不是函数的调用</span></span><br><span class="line">    thread1 = threading.Thread(target=get_detail_html, args=(<span class="string">''</span>,))</span><br><span class="line">    thread2 = threading.Thread(target=get_detail_url, args=(<span class="string">''</span>,))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># setDaemon(True) 表示设置这个线程为守护线程，即当主线程退出的时候，直接结束子线程，不管子线程是否执行完。</span></span><br><span class="line">    <span class="comment"># thread1.setDaemon(True)</span></span><br><span class="line">    <span class="comment"># thread2.setDaemon(True)</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># join() 表示主线程会等待子线程执行完后才会向下执行。</span></span><br><span class="line">    <span class="comment"># 下面两行设置后，主线程会等待 thread1 和 thread2都执行完，才执行后面的 print 语句。</span></span><br><span class="line">    <span class="comment"># 并且，主线程等待的时间是 max(time_thread1, time_thread2), 而不是等待 time_thread1 + time_thread2 时间</span></span><br><span class="line">    <span class="comment"># 解除 join 方法：调用 task_done()。调用 task_done() 之后，主线程不再等待子线程。</span></span><br><span class="line">    thread1.join()</span><br><span class="line">    thread2.join()</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 需求:当主线程退出的时候， 子线程kill掉 setDaemon可以满足</span></span><br><span class="line">   <span class="comment"># 需求:线程会等待子线程执行完后才会向下执行 join()可以满足</span></span><br><span class="line">    print(<span class="string">"last time: &#123;&#125;"</span>.format(time.time()-start_time))</span><br></pre></td></tr></table></figure>
<h3 id="2-2-通过继承Thread来实现多线程"><a href="#2-2-通过继承Thread来实现多线程" class="headerlink" title="2.2 通过继承Thread来实现多线程"></a>2.2 通过继承Thread来实现多线程</h3><blockquote>
<p>大部分情况，都是使用这种方式。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetDetailHtml</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="comment"># 这是一个好习惯，在进行多线程编程时，首先调用父类的初始化方法</span></span><br><span class="line">        super().__init__(name=name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"get detail html started"</span>)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        print(<span class="string">"get detail html end"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetDetailUrl</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        super().__init__(name=name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"get detail url started"</span>)</span><br><span class="line">        time.sleep(<span class="number">4</span>)</span><br><span class="line">        print(<span class="string">"get detail url end"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 方式二：通过集成Thread来实现多线程</span></span><br><span class="line">    thread1 = GetDetailHtml(<span class="string">"get_detail_html"</span>)</span><br><span class="line">    thread2 = GetDetailUrl(<span class="string">"get_detail_url"</span>)</span><br><span class="line">    <span class="comment"># setDaemon(True) 表示设置这个线程为守护线程，即当主线程退出的时候，直接结束子线程，不管子线程是否执行完。</span></span><br><span class="line">    <span class="comment"># thread1.setDaemon(True)</span></span><br><span class="line">    <span class="comment"># thread2.setDaemon(True)</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># join() 表示主线程会等待子线程执行完后才会向下执行。</span></span><br><span class="line">    <span class="comment"># 下面两行设置后，主线程会等待 thread1 和 thread2都执行完，才执行后面的 print 语句。</span></span><br><span class="line">    <span class="comment"># 并且，主线程等待的时间是 max(time_thread1, time_thread2), 而不是等待 time_thread1 + time_thread2 时间</span></span><br><span class="line">    <span class="comment"># 解除 join 方法：调用 task_done()。调用 task_done() 之后，主线程不再等待子线程。</span></span><br><span class="line">    thread1.join()</span><br><span class="line">    thread2.join()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当主线程退出的时候， 子线程kill掉</span></span><br><span class="line">    print(<span class="string">"last time: &#123;&#125;"</span>.format(time.time()-start_time))</span><br></pre></td></tr></table></figure>
<h3 id="3-线程间通信"><a href="#3-线程间通信" class="headerlink" title="3. 线程间通信"></a>3. 线程间通信</h3><blockquote>
<p>本篇中，本小节之后的所有部分都需要扎实的操作系统知识。Prerequisite：<a href="https://blog.csdn.net/kisslotus/article/details/84503886" target="_blank" rel="noopener">https://blog.csdn.net/kisslotus/article/details/84503886</a></p>
</blockquote>
<h3 id="3-1-通过共享变量的方式"><a href="#3-1-通过共享变量的方式" class="headerlink" title="3.1 通过共享变量的方式"></a>3.1 通过共享变量的方式</h3><blockquote>
<p>通过 global 关键字，多个线程对一个变量共同读的方式。这种方式是适合“共同读”的情况。如果需要进程间进行同步，需要加锁，但这种方式对编程者的技术要求比较高。<br>如果共享变量很多时，可以把变量单独放到一个文件中，便于管理。<br>这里有一个坑需要注意，在从其他文件中引用变量时，使用 from chapter11 import variables</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 线程间通信</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="comment"># 下面这一行代码，不要这样使用：from chapter11.variables import detail_url_list</span></span><br><span class="line"><span class="comment"># 这种做法的坏处就是：当另一个线程修改了 detail_url_list 这个变量，我们看不到了。</span></span><br><span class="line"><span class="comment"># 但是，下面这一行的这种使用方法，在 detail_url_list = variables.detail_url_list 这一行中，</span></span><br><span class="line"><span class="comment"># 如果其他线程修改了 detail_url_list，我们就能通过 detail_url_list 看得到。</span></span><br><span class="line"><span class="keyword">from</span> chapter11 <span class="keyword">import</span> variables</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Condition</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 生产者当生产10个url以后就就等待，保证detail_url_list中最多只有十个url</span></span><br><span class="line"><span class="comment"># 2. 当url_list为空的时候，消费者就暂停</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail_html</span><span class="params">(lock)</span>:</span></span><br><span class="line">    <span class="comment"># 爬取文章详情页</span></span><br><span class="line">    <span class="comment"># 互斥变量</span></span><br><span class="line">    detail_url_list = variables.detail_url_list</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(variables.detail_url_list):</span><br><span class="line">            lock.acquire()</span><br><span class="line">            <span class="keyword">if</span> len(detail_url_list):</span><br><span class="line">                <span class="comment"># 每次弹出从 list 中弹出一个元素</span></span><br><span class="line">                url = detail_url_list.pop()</span><br><span class="line">                lock.release()</span><br><span class="line">                <span class="comment"># for url in detail_url_list:</span></span><br><span class="line">                print(<span class="string">"get detail html started"</span>)</span><br><span class="line">                time.sleep(<span class="number">2</span>)</span><br><span class="line">                print(<span class="string">"get detail html end"</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lock.release()</span><br><span class="line">                time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail_url</span><span class="params">(lock)</span>:</span></span><br><span class="line">    <span class="comment"># 爬取文章列表页</span></span><br><span class="line">    <span class="comment"># 互斥变量</span></span><br><span class="line">    detail_url_list = variables.detail_url_list</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">"get detail url started"</span>)</span><br><span class="line">        time.sleep(<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">            lock.acquire()</span><br><span class="line">            <span class="keyword">if</span> len(detail_url_list) &gt;= <span class="number">10</span>:</span><br><span class="line">                lock.release()</span><br><span class="line">                time.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                detail_url_list.append(</span><br><span class="line">                    <span class="string">"http://projectsedu.com/&#123;id&#125;"</span>.format(id=i))</span><br><span class="line">                lock.release()</span><br><span class="line">        print(<span class="string">"get detail url end"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 线程通信方式- 共享变量</span></span><br><span class="line"><span class="comment"># 一般不建议使用共享变量的方式进行线程通信，除非对锁有比较扎实的了解</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    lock = RLock()</span><br><span class="line">    thread_detail_url = threading.Thread(target=get_detail_url, args=(lock,))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        html_thread = threading.Thread(target=get_detail_html, args=(lock,))</span><br><span class="line">        html_thread.start()</span><br><span class="line">    <span class="comment"># # thread2 = GetDetailUrl("get_detail_url")</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    <span class="comment"># thread_detail_url.start()</span></span><br><span class="line">    <span class="comment"># thread_detail_url1.start()</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># thread1.join()</span></span><br><span class="line">    <span class="comment"># thread2.join()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当主线程退出的时候， 子线程kill掉</span></span><br><span class="line">    print(<span class="string">"last time: &#123;&#125;"</span>.format(time.time()-start_time))</span><br></pre></td></tr></table></figure>
<h3 id="3-2-通过-queue-的方式进行线程间同步"><a href="#3-2-通过-queue-的方式进行线程间同步" class="headerlink" title="3.2 通过 queue 的方式进行线程间同步"></a>3.2 通过 queue 的方式进行线程间同步</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2. 通过queue的方式进行线程间同步</span></span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="comment"># queue 底层使用的是deque deque本身就是线程安全的 put默认是阻塞的，可以使用put_nowait非阻塞方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail_html</span><span class="params">(queue)</span>:</span></span><br><span class="line">    <span class="comment"># 爬取文章详情页</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        url = queue.get()</span><br><span class="line">        <span class="comment"># for url in detail_url_list:</span></span><br><span class="line">        print(<span class="string">"get detail html started"</span>)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        print(<span class="string">"get detail html end"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail_url</span><span class="params">(queue)</span>:</span></span><br><span class="line">    <span class="comment"># 爬取文章列表页</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">"get detail url started"</span>)</span><br><span class="line">        time.sleep(<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">            queue.put(<span class="string">"http://projectsedu.com/&#123;id&#125;"</span>.format(id=i))</span><br><span class="line">        print(<span class="string">"get detail url end"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    detail_url_queue = Queue(maxsize=<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">    thread_detail_url = threading.Thread(</span><br><span class="line">        target=get_detail_url, args=(detail_url_queue,))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        html_thread = threading.Thread(</span><br><span class="line">            target=get_detail_html, args=(detail_url_queue,))</span><br><span class="line">        html_thread.start()</span><br><span class="line">    <span class="comment"># # thread2 = GetDetailUrl("get_detail_url")</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    <span class="comment"># thread_detail_url.start()</span></span><br><span class="line">    <span class="comment"># thread_detail_url1.start()</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># thread1.join()</span></span><br><span class="line">    <span class="comment"># thread2.join()</span></span><br><span class="line">    detail_url_queue.task_done()</span><br><span class="line">    detail_url_queue.join()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当主线程退出的时候， 子线程kill掉</span></span><br><span class="line">    print(<span class="string">"last time: &#123;&#125;"</span>.format(time.time()-start_time))</span><br></pre></td></tr></table></figure>
<h3 id="4-线程间同步"><a href="#4-线程间同步" class="headerlink" title="4. 线程间同步"></a>4. 线程间同步</h3><blockquote>
<p>RLock 是基于 Lock 实现的。Condition 是基于 Lock 和 RLock 实现的。Semaphore 是基于 Condition 实现的。  </p>
</blockquote>
<h3 id="4-1-Lock-和-RLock"><a href="#4-1-Lock-和-RLock" class="headerlink" title="4.1 Lock 和 RLock"></a>4.1 Lock 和 RLock</h3><blockquote>
<p>使用 Lock 或者 RLock 完成进程的同步，对互斥资源使用 acquire 加锁，使用 release 释放锁。acquire 不可以连续多次调用。<br>RLock 表示可重入的锁，可以连续多次调用 acquire，但是一定要注意acquire的次数要和release的次数相等。RLock 更常用。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock, RLock, Condition  </span><br><span class="line"></span><br><span class="line"><span class="comment"># RLock 表示可重入的锁</span></span><br><span class="line"><span class="comment"># 在同一个线程里面，可以连续调用多次acquire， 一定要注意acquire的次数要和release的次数相等。</span></span><br><span class="line"><span class="comment"># 注意，这里是同一个线程，并不是多个线程之间可以调用多次</span></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line">lock = RLock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 1. dosomething1</span></span><br><span class="line">    <span class="comment"># 2. io操作</span></span><br><span class="line">    <span class="comment"># 1. dosomething3</span></span><br><span class="line">    <span class="keyword">global</span> lock</span><br><span class="line">    <span class="keyword">global</span> total</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        lock.acquire()</span><br><span class="line">        total += <span class="number">1</span></span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">desc</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> total</span><br><span class="line">    <span class="keyword">global</span> lock</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        lock.acquire()</span><br><span class="line">        total -= <span class="number">1</span></span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thread1 = threading.Thread(target=add)</span><br><span class="line">thread2 = threading.Thread(target=desc)</span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">thread1.join()</span><br><span class="line">thread2.join()</span><br><span class="line">print(total)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 用锁会影响性能</span></span><br><span class="line"><span class="comment"># 2. 锁会引起死锁</span></span><br><span class="line"><span class="comment"># 死锁的情况 A（a，b）</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">下面的代码会出现循环等待情况，导致死锁</span></span><br><span class="line"><span class="string">A(a、b)</span></span><br><span class="line"><span class="string">acquire (a)</span></span><br><span class="line"><span class="string">acquire (b)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">B(a、b)</span></span><br><span class="line"><span class="string">acquire (a)</span></span><br><span class="line"><span class="string">acquire (b)</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-condition"><a href="#4-2-condition" class="headerlink" title="4.2 condition"></a>4.2 condition</h3><blockquote>
<p>用于线程间的复杂通信</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 条件变量， 用于复杂的线程间同步</span></span><br><span class="line"><span class="comment"># class XiaoAi(threading.Thread):</span></span><br><span class="line"><span class="comment">#     def __init__(self, lock):</span></span><br><span class="line"><span class="comment">#         super().__init__(name="小爱")</span></span><br><span class="line"><span class="comment">#         self.lock = lock</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     def run(self):</span></span><br><span class="line"><span class="comment">#         self.lock.acquire()</span></span><br><span class="line"><span class="comment">#         print("&#123;&#125; : 在 ".format(self.name))</span></span><br><span class="line"><span class="comment">#         self.lock.release()</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#         self.lock.acquire()</span></span><br><span class="line"><span class="comment">#         print("&#123;&#125; : 好啊 ".format(self.name))</span></span><br><span class="line"><span class="comment">#         self.lock.release()</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># class TianMao(threading.Thread):</span></span><br><span class="line"><span class="comment">#     def __init__(self, lock):</span></span><br><span class="line"><span class="comment">#         super().__init__(name="天猫精灵")</span></span><br><span class="line"><span class="comment">#         self.lock = lock</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     def run(self):</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#         self.lock.acquire()</span></span><br><span class="line"><span class="comment">#         print("&#123;&#125; : 小爱同学 ".format(self.name))</span></span><br><span class="line"><span class="comment">#         self.lock.release()</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#         self.lock.acquire()</span></span><br><span class="line"><span class="comment">#         print("&#123;&#125; : 我们来对古诗吧 ".format(self.name))</span></span><br><span class="line"><span class="comment">#         self.lock.release()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过condition完成协同读诗</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaoAi</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, cond)</span>:</span></span><br><span class="line">        super().__init__(name=<span class="string">"小爱"</span>)</span><br><span class="line">        self.cond = cond</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 这里使用了 with 语句，如果不实用 with 语句，应该使用 self.cond.acquire()，并在结束时使用 self.cond.release()</span></span><br><span class="line">        <span class="comment"># with 语句实际调用了 Condition 的 acquire 方法。</span></span><br><span class="line">        <span class="comment"># Condition 其实是有两层锁的，一把是 Condition 对象的锁，这种是底层锁，</span></span><br><span class="line">        <span class="comment"># 另一把是 wait 方法被调用时产生的锁，这个锁被放在一个 deque 中，并在 notify 时从 deque 中释放一个锁。</span></span><br><span class="line">        <span class="comment"># 主线程先调用 Xiaoai 线程，当 Xiaoai 线程执行 with self.cond 时，Tianmao 是无法进入 with self.cond 的。</span></span><br><span class="line">        <span class="comment"># 当 Xiaoai 线程执行 wait() 方法时，自己被阻塞，Tianmao 线程开始执行。</span></span><br><span class="line">        print(<span class="string">'A'</span>)</span><br><span class="line">        <span class="keyword">with</span> self.cond:</span><br><span class="line">            print(<span class="string">'B'</span>)</span><br><span class="line">            self.cond.wait()</span><br><span class="line">            print(<span class="string">"&#123;&#125; : 在 "</span>.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line">            print(<span class="string">'F'</span>)</span><br><span class="line"></span><br><span class="line">            self.cond.wait()</span><br><span class="line">            print(<span class="string">"&#123;&#125; : 好啊 "</span>.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line"></span><br><span class="line">            self.cond.wait()</span><br><span class="line">            print(<span class="string">"&#123;&#125; : 君住长江尾 "</span>.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line"></span><br><span class="line">            self.cond.wait()</span><br><span class="line">            print(<span class="string">"&#123;&#125; : 共饮长江水 "</span>.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line"></span><br><span class="line">            self.cond.wait()</span><br><span class="line">            print(<span class="string">"&#123;&#125; : 此恨何时已 "</span>.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line"></span><br><span class="line">            self.cond.wait()</span><br><span class="line">            print(<span class="string">"&#123;&#125; : 定不负相思意 "</span>.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TianMao</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, cond)</span>:</span></span><br><span class="line">        super().__init__(name=<span class="string">"天猫精灵"</span>)</span><br><span class="line">        self.cond = cond</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 这里使用了 with 语句，如果不实用 with 语句，应该使用 self.cond.acquire()，并在结束时使用 self.cond.release()</span></span><br><span class="line">        print(<span class="string">'C'</span>)</span><br><span class="line">        <span class="keyword">with</span> self.cond:</span><br><span class="line">            print(<span class="string">'D'</span>)</span><br><span class="line">            print(<span class="string">"&#123;&#125; : 小爱同学 "</span>.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line">            print(<span class="string">'E'</span>)</span><br><span class="line">            self.cond.wait()</span><br><span class="line">            print(<span class="string">'G'</span>)</span><br><span class="line"></span><br><span class="line">            print(<span class="string">"&#123;&#125; : 我们来对古诗吧 "</span>.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line">            self.cond.wait()</span><br><span class="line"></span><br><span class="line">            print(<span class="string">"&#123;&#125; : 我住长江头 "</span>.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line">            self.cond.wait()</span><br><span class="line"></span><br><span class="line">            print(<span class="string">"&#123;&#125; : 日日思君不见君 "</span>.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line">            self.cond.wait()</span><br><span class="line"></span><br><span class="line">            print(<span class="string">"&#123;&#125; : 此水几时休 "</span>.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line">            self.cond.wait()</span><br><span class="line"></span><br><span class="line">            print(<span class="string">"&#123;&#125; : 只愿君心似我心 "</span>.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line">            self.cond.wait()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line">    cond = threading.Condition()</span><br><span class="line">    xiaoai = XiaoAi(cond)</span><br><span class="line">    tianmao = TianMao(cond)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动顺序很重要</span></span><br><span class="line">    <span class="comment"># 在调用with cond之后才能调用wait或者notify方法</span></span><br><span class="line">    <span class="comment"># condition有两层锁， 一把底层锁会在线程调用了 wait 方法的时候释放， 上面的锁会在每次调用 wait 的时候分配一把并放入到 cond 的等待队列中，等到 notify 方法的唤醒</span></span><br><span class="line">    xiaoai.start()</span><br><span class="line">    tianmao.start()</span><br></pre></td></tr></table></figure>
<h3 id="4-3-Semaphore"><a href="#4-3-Semaphore" class="headerlink" title="4.3 Semaphore"></a>4.3 Semaphore</h3><blockquote>
<p>通过 Semaphore 控制线程并发数量</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Semaphore 是用于控制进入数量的锁</span></span><br><span class="line"><span class="comment">#文件， 读、写， 写一般只是用于一个线程写，读可以允许有多个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#做爬虫</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlSpider</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, url, sem)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.url = url</span><br><span class="line">        self.sem = sem</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        print(<span class="string">"got html text success"</span>)</span><br><span class="line">        <span class="comment"># 每调用 release 时，semaphore 都会加一</span></span><br><span class="line">        self.sem.release()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UrlProducer</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, sem)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.sem = sem</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">            <span class="comment"># 每调用 acquire 时，semaphore 都会减一</span></span><br><span class="line">            self.sem.acquire()</span><br><span class="line">            html_thread = HtmlSpider(<span class="string">"https://baidu.com/&#123;&#125;"</span>.format(i), self.sem)</span><br><span class="line">            html_thread.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 最多允许三个线程并发</span></span><br><span class="line">    sem = threading.Semaphore(<span class="number">3</span>)</span><br><span class="line">    url_producer = UrlProducer(sem)</span><br><span class="line">    url_producer.start()</span><br></pre></td></tr></table></figure>
<h3 id="5-线程池"><a href="#5-线程池" class="headerlink" title="5 线程池"></a>5 线程池</h3><h3 id="5-1-done-cancel-和-result-三个方法"><a href="#5-1-done-cancel-和-result-三个方法" class="headerlink" title="5.1 done, cancel, 和 result 三个方法"></a>5.1 done, cancel, 和 result 三个方法</h3><blockquote>
<p>done 用于获取线程是否执行完成<br>cancel 用于终止线程。注意，cancel 只能对未执行的线程终止。如果线程在执行中或者执行完成，返回 false。成功 cancel 返回 true。<br>result 获取线程的返回值。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, as_completed, wait, FIRST_COMPLETED</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> Future</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 线程池， 为什么要线程池</span></span><br><span class="line"><span class="comment"># 主线程中可以获取某一个线程的状态或者某一个任务的状态，以及返回值</span></span><br><span class="line"><span class="comment"># 当一个线程完成的时候我们主线程能立即知道</span></span><br><span class="line"><span class="comment"># futures可以让多线程和多进程编码接口一致</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(times)</span>:</span></span><br><span class="line">    time.sleep(times)</span><br><span class="line">    print(<span class="string">"get page &#123;&#125; success"</span>.format(times))</span><br><span class="line">    <span class="keyword">return</span> times</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">executor = ThreadPoolExecutor(max_workers=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 通过submit函数提交执行的函数到线程池中, submit 是立即返回</span></span><br><span class="line"><span class="comment"># 注意，这里传递的是函数名，不是函数的调用</span></span><br><span class="line">task1 = executor.submit(get_html, (<span class="number">3</span>))</span><br><span class="line">task2 = executor.submit(get_html, (<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#done方法用于判定某个任务是否完成</span></span><br><span class="line">print(task1.done())</span><br><span class="line">print(task2.cancel())</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">print(task1.done())</span><br><span class="line"></span><br><span class="line"><span class="comment">#result方法可以获取task的执行结果</span></span><br><span class="line">print(task1.result())</span><br></pre></td></tr></table></figure>
<h3 id="5-2-获取成功执行的线程返回值"><a href="#5-2-获取成功执行的线程返回值" class="headerlink" title="5.2 获取成功执行的线程返回值"></a>5.2 获取成功执行的线程返回值</h3><blockquote>
<p>使用 as_completed 或者 map 方法完成。注意，两个方法调用的对象不同。as_completed 是一个单独的函数。map 是 executor 的是一个实例方法。个人优先使用 as_completed 方式。</p>
</blockquote>
<h3 id="5-2-1-使用-as-completed-方法"><a href="#5-2-1-使用-as-completed-方法" class="headerlink" title="5.2.1 使用 as_completed 方法"></a>5.2.1 使用 as_completed 方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, as_completed, wait, FIRST_COMPLETED</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> Future</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(times)</span>:</span></span><br><span class="line">    time.sleep(times)</span><br><span class="line">    print(<span class="string">"get page &#123;&#125; success"</span>.format(times))</span><br><span class="line">    <span class="keyword">return</span> times</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">executor = ThreadPoolExecutor(max_workers=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 要获取已经成功的task的返回</span></span><br><span class="line">urls = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">all_task = [executor.submit(get_html, (url)) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line"><span class="keyword">for</span> future <span class="keyword">in</span> as_completed(all_task):</span><br><span class="line">    data = future.result()</span><br><span class="line">    print(<span class="string">"get &#123;&#125; page"</span>.format(data))</span><br></pre></td></tr></table></figure>
<h3 id="5-2-2-使用-map-方法完成"><a href="#5-2-2-使用-map-方法完成" class="headerlink" title="5.2.2 使用 map 方法完成"></a>5.2.2 使用 map 方法完成</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, as_completed, wait, FIRST_COMPLETED</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> Future</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(times)</span>:</span></span><br><span class="line">    time.sleep(times)</span><br><span class="line">    print(<span class="string">"get page &#123;&#125; success"</span>.format(times))</span><br><span class="line">    <span class="keyword">return</span> times</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">executor = ThreadPoolExecutor(max_workers=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 通过executor的map获取已经完成的task的值</span></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> executor.map(get_html, urls):</span><br><span class="line">    print(<span class="string">"get &#123;&#125; page"</span>.format(data))</span><br></pre></td></tr></table></figure>
<h3 id="5-3-等待特定的线程执行完，再向下执行"><a href="#5-3-等待特定的线程执行完，再向下执行" class="headerlink" title="5.3 等待特定的线程执行完，再向下执行"></a>5.3 等待特定的线程执行完，再向下执行</h3><blockquote>
<p>这个需求有点像 join 方法实现的功能。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, as_completed, wait, FIRST_COMPLETED</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> Future</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(times)</span>:</span></span><br><span class="line">    time.sleep(times)</span><br><span class="line">    print(<span class="string">"get page &#123;&#125; success"</span>.format(times))</span><br><span class="line">    <span class="keyword">return</span> times</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">executor = ThreadPoolExecutor(max_workers=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要获取已经成功的task的返回</span></span><br><span class="line">urls = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">all_task = [executor.submit(get_html, (url)) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line"><span class="comment"># FIRST_COMPLETED 表示当第一个线程执行完成时，便不再等待了。</span></span><br><span class="line"><span class="comment"># return_when 没有设置的时候，等待所有的线程执行完再向下执行。</span></span><br><span class="line">wait(all_task, return_when=FIRST_COMPLETED)</span><br><span class="line">print(<span class="string">"main"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="5-4-分析线程池源码-（重点）"><a href="#5-4-分析线程池源码-（重点）" class="headerlink" title="5.4 分析线程池源码 （重点）"></a>5.4 分析线程池源码 （重点）</h3><blockquote>
<p>线程池有一个非常重要的类，Future。Future 放置在 from concurrent.futures import Future 中。每个线程执行后返回的对象是 Future，即 task 的返回容器。Future 贯穿于多线程编程的始终，可以理解为一个统一的封装接口，就好像所有的对象的顶层父类都是 Object一样。<br>理解了上一点，那么，Future 对象是怎么贯穿线程生命周期的始终呢？<br>在调用 ThreadPoolExecutor 的 submit 函数时，以下面的代码为例，首先会生成 Future 对象，最后返回这个对象。在执行的过程中，生成 _WorkItem，并将 Future 对象，线程函数体，参数一起传入 _WorkItem中，再将其放入 queue 中，这个 queue 是线程安全的。放入 queue 之后，使用 _adjust_thread_count 调成线程数量。在 _adjust_thread_count 函数体中，如果当前等待的线程数小于线程池的容量，会启动线程，直到等于线程池数量。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">submit</span><span class="params">(self, fn, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> self._shutdown_lock:</span><br><span class="line">        <span class="keyword">if</span> self._shutdown:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">'cannot schedule new futures after shutdown'</span>)</span><br><span class="line"></span><br><span class="line">        f = _base.Future()</span><br><span class="line">        w = _WorkItem(f, fn, args, kwargs)</span><br><span class="line"></span><br><span class="line">        self._work_queue.put(w)</span><br><span class="line">        self._adjust_thread_count()</span><br><span class="line">        <span class="keyword">return</span> f</span><br></pre></td></tr></table></figure>
<blockquote>
<p>下面，我们来详细了解 _adjust_thread_count 的执行过程。启动一个新的线程时，执行体是 _worker，_worker 从 queue 中取出一个值，这是值是封装了我们自己写的线程函数体的 work_item，进而调用 work_item 中的 run 方法。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">def _adjust_thread_count(self):</span><br><span class="line">    <span class="comment"># When the executor gets lost, the weakref callback will wake up</span></span><br><span class="line">    <span class="comment"># the worker threads.</span></span><br><span class="line">    def weakref_cb(_, q=self._work_queue):</span><br><span class="line">        q.put(None)</span><br><span class="line">    <span class="comment"># TODO(bquinlan): Should avoid creating new threads if there are more</span></span><br><span class="line">    <span class="comment"># idle threads than items in the work queue.</span></span><br><span class="line">    num_threads = len(self._threads)</span><br><span class="line">    <span class="keyword">if</span> num_threads &lt; self._max_workers:</span><br><span class="line">        thread_name = <span class="string">'%s_%d'</span> % (self._thread_name_prefix or self,</span><br><span class="line">                                 num_threads)</span><br><span class="line">        t = threading.Thread(name=thread_name, target=_worker,</span><br><span class="line">                             args=(weakref.ref(self, weakref_cb),</span><br><span class="line">                                   self._work_queue))</span><br><span class="line">        t.daemon = True</span><br><span class="line">        t.start()</span><br><span class="line">        self._threads.add(t)</span><br><span class="line">        _threads_queues[t] = self._work_queue</span><br><span class="line"></span><br><span class="line">def _worker(executor_reference, work_queue):</span><br><span class="line">    try:</span><br><span class="line">        <span class="keyword">while</span> True:</span><br><span class="line">            work_item = work_queue.get(block=True)</span><br><span class="line">            <span class="keyword">if</span> work_item is not None:</span><br><span class="line">                work_item.run()</span><br><span class="line">                <span class="comment"># Delete references to object. See issue16284</span></span><br><span class="line">                del work_item</span><br><span class="line">                <span class="built_in">continue</span></span><br><span class="line">            executor = executor_reference()</span><br><span class="line">            <span class="comment"># Exit if:</span></span><br><span class="line">            <span class="comment">#   - The interpreter is shutting down OR</span></span><br><span class="line">            <span class="comment">#   - The executor that owns the worker has been collected OR</span></span><br><span class="line">            <span class="comment">#   - The executor that owns the worker has been shutdown.</span></span><br><span class="line">            <span class="keyword">if</span> _shutdown or executor is None or executor._shutdown:</span><br><span class="line">                <span class="comment"># Notice other workers</span></span><br><span class="line">                work_queue.put(None)</span><br><span class="line">                <span class="built_in">return</span></span><br><span class="line">            del executor</span><br><span class="line">    except BaseException:</span><br><span class="line">        _base.LOGGER.critical(<span class="string">'Exception in worker'</span>, exc_info=True)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>下面，我们再来看一下 work_item 中的 run 方法。首先，run 方法会执行我们自己写的线程函数体，得到函数的返回值，并将值设置到 Future 对象中。由此，变完成了使用 Future 统一线程的执行。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.future.set_running_or_notify_cancel():</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        result = self.fn(*self.args, **self.kwargs)</span><br><span class="line">    <span class="keyword">except</span> BaseException <span class="keyword">as</span> exc:</span><br><span class="line">        self.future.set_exception(exc)</span><br><span class="line">        <span class="comment"># Break a reference cycle with the exception 'exc'</span></span><br><span class="line">        self = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.future.set_result(result)</span><br></pre></td></tr></table></figure>
<h3 id="6-多进程编程"><a href="#6-多进程编程" class="headerlink" title="6. 多进程编程"></a>6. 多进程编程</h3><blockquote>
<p><strong>耗 cpu 的操作，用多进程编程。对于 io 操作来说， 使用多线程编程。</strong><br>由于 Python 中有 GIL 锁，Python 中的多线程编程是无法充分利用多核的优势。但是，<strong>多进程编程就能够利用多核的优势。</strong></p>
</blockquote>
<h3 id="6-1-对于耗费-cpu-的操作，多进程优于多线程"><a href="#6-1-对于耗费-cpu-的操作，多进程优于多线程" class="headerlink" title="6.1 对于耗费 cpu 的操作，多进程优于多线程"></a>6.1 对于耗费 cpu 的操作，多进程优于多线程</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, as_completed</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n&lt;=<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fib(n<span class="number">-1</span>)+fib(n<span class="number">-2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 多线程</span></span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(<span class="number">3</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        all_task = [executor.submit(fib, (num)) <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">25</span>,<span class="number">40</span>)]</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> as_completed(all_task):</span><br><span class="line">            data = future.result()</span><br><span class="line">            print(<span class="string">"exe result: &#123;&#125;"</span>.format(data))</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"last time is: &#123;&#125;"</span>.format(time.time()-start_time))</span><br><span class="line">    </span><br><span class="line">	<span class="comment"># 多进程</span></span><br><span class="line">	<span class="comment"># Windows 下面执行 ProcessPoolExecutor 需要放到 main 函数下执行，不然会报错</span></span><br><span class="line">    <span class="keyword">with</span> ProcessPoolExecutor(<span class="number">3</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        all_task = [executor.submit(fib, (num)) <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">25</span>,<span class="number">40</span>)]</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> as_completed(all_task):</span><br><span class="line">            data = future.result()</span><br><span class="line">            print(<span class="string">"exe result: &#123;&#125;"</span>.format(data))</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"last time is: &#123;&#125;"</span>.format(time.time()-start_time))</span><br></pre></td></tr></table></figure>
<h3 id="6-2-对于-io-操作来说，多线程优于多进程"><a href="#6-2-对于-io-操作来说，多线程优于多进程" class="headerlink" title="6.2 对于 io 操作来说，多线程优于多进程"></a>6.2 对于 io 操作来说，多线程优于多进程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line">from concurrent.futures import ThreadPoolExecutor, as_completed</span><br><span class="line">from concurrent.futures import ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def random_sleep(n):</span><br><span class="line">    time.sleep(n)</span><br><span class="line">    return n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">	# 多线程</span><br><span class="line">	with ThreadPoolExecutor(3) as executor:</span><br><span class="line">        all_task &#x3D; [executor.submit(random_sleep, (num)) for num in [2]*30]</span><br><span class="line">        start_time &#x3D; time.time()</span><br><span class="line">        for future in as_completed(all_task):</span><br><span class="line">            data &#x3D; future.result()</span><br><span class="line">            print(&quot;exe result: &#123;&#125;&quot;.format(data))</span><br><span class="line"></span><br><span class="line">        print(&quot;last time is: &#123;&#125;&quot;.format(time.time()-start_time))</span><br><span class="line">    </span><br><span class="line">    # 多进程</span><br><span class="line">    with ProcessPoolExecutor(3) as executor:</span><br><span class="line">        all_task &#x3D; [executor.submit(random_sleep, (num)) for num in [2]*30]</span><br><span class="line">        start_time &#x3D; time.time()</span><br><span class="line">        for future in as_completed(all_task):</span><br><span class="line">            data &#x3D; future.result()</span><br><span class="line">            print(&quot;exe result: &#123;&#125;&quot;.format(data))</span><br><span class="line"></span><br><span class="line">        print(&quot;last time is: &#123;&#125;&quot;.format(time.time()-start_time))</span><br></pre></td></tr></table></figure>
<h3 id="6-3-fork-与多进程的区别"><a href="#6-3-fork-与多进程的区别" class="headerlink" title="6.3 fork 与多进程的区别"></a>6.3 fork 与多进程的区别</h3><blockquote>
<p>fork 会新建一个子进程</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># fork只能用于linux/unix中</span></span><br><span class="line"><span class="comment"># 调用 fork 函数之后，会完全拷贝一份父进程的数据给子进程，子进程执行 fork 之后的代码</span></span><br><span class="line">pid = os.fork()</span><br><span class="line">print(<span class="string">"bobby"</span>)</span><br><span class="line"><span class="keyword">if</span> pid == <span class="number">0</span>:</span><br><span class="line">   print(<span class="string">'子进程 &#123;&#125; ，父进程是： &#123;&#125;.'</span> .format(os.getpid(), os.getppid()))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   print(<span class="string">'我是父进程：&#123;&#125;.'</span>.format(pid))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有 sleep 代码，会出现子进程无法退出的情况。这是因为，父进程执行完了之后，由于没有 sleep 函数，父进程会直接退出，但是，此时子进程依然在执行，当子进程执行完了之后，发现父进程已经消失了，子进程就无法退出。</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h3 id="6-4-multiprocessing"><a href="#6-4-multiprocessing" class="headerlink" title="6.4 multiprocessing"></a>6.4 multiprocessing</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多进程编程</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(n)</span>:</span></span><br><span class="line">    time.sleep(n)</span><br><span class="line">    print(<span class="string">"sub_progress success"</span>)</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 下面这行代码也可以使用继承 multiprocessing.Process 方式实现，就像继承 Thread 方式实现多线程一样</span></span><br><span class="line">    progress = multiprocessing.Process(target=get_html, args=(<span class="number">2</span>,))</span><br><span class="line">    <span class="comment"># 打印 pid</span></span><br><span class="line">    print(progress.pid)</span><br><span class="line">    progress.start()</span><br><span class="line">    print(progress.pid)</span><br><span class="line">    progress.join()</span><br><span class="line">    print(<span class="string">"main progress end"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="6-5-进程池"><a href="#6-5-进程池" class="headerlink" title="6.5 进程池"></a>6.5 进程池</h3><blockquote>
<p><strong>使用进程池时，建议使用ProcessPoolExecutor，而不是multiprocessing模块。</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="comment">#多进程编程</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(n)</span>:</span></span><br><span class="line">    time.sleep(n)</span><br><span class="line">    print(<span class="string">"sub_progress success"</span>)</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 使用进程池</span></span><br><span class="line">    pool = multiprocessing.Pool(multiprocessing.cpu_count())</span><br><span class="line">    <span class="comment"># 提交任务到池子中</span></span><br><span class="line">    result = pool.apply_async(get_html, args=(<span class="number">3</span>,))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 等待所有任务完成</span></span><br><span class="line">    <span class="comment"># 在调用 join 之前，需要调用 close 方法，关闭池子</span></span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    </span><br><span class="line">    print(result.get())</span><br></pre></td></tr></table></figure>
<h3 id="6-6-imap-和-imap-unordered"><a href="#6-6-imap-和-imap-unordered" class="headerlink" title="6.6 imap 和 imap_unordered"></a>6.6 imap 和 imap_unordered</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="comment">#多进程编程</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(n)</span>:</span></span><br><span class="line">    time.sleep(n)</span><br><span class="line">    print(<span class="string">"sub_progress success"</span>)</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 使用进程池</span></span><br><span class="line">    pool = multiprocessing.Pool(multiprocessing.cpu_count())</span><br><span class="line">    <span class="comment"># imap 按顺序执行</span></span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> pool.imap(get_html, [<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>]):</span><br><span class="line">        print(<span class="string">"&#123;&#125; sleep success"</span>.format(result))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># imap_unordered</span></span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> pool.imap_unordered(get_html, [<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>]):</span><br><span class="line">        print(<span class="string">"&#123;&#125; sleep success"</span>.format(result))</span><br></pre></td></tr></table></figure>
<h3 id="6-7-进程间通信"><a href="#6-7-进程间通信" class="headerlink" title="6.7 进程间通信"></a>6.7 进程间通信</h3><h3 id="6-7-1-使用-multiprocessing-中的-Queue"><a href="#6-7-1-使用-multiprocessing-中的-Queue" class="headerlink" title="6.7.1 使用 multiprocessing 中的 Queue"></a>6.7.1 使用 multiprocessing 中的 Queue</h3><blockquote>
<p>多线程编程时通过 queue 进行通信，但是在多进程编程时，需要使用 from multiprocessing import Queue 中的 queue。<br>多进程编程时不能通过共享全局变量方式通信，因为多个进程间的变量是完全隔离的。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue, Pool, Manager, Pipe</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(queue)</span>:</span></span><br><span class="line">    queue.put(<span class="string">"a"</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(queue)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    data = queue.get()</span><br><span class="line">    print(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    queue = Queue(<span class="number">10</span>)</span><br><span class="line">    my_producer = Process(target=producer, args=(queue,))</span><br><span class="line">    my_consumer = Process(target=consumer, args=(queue,))</span><br><span class="line">    my_producer.start()</span><br><span class="line">    my_consumer.start()</span><br><span class="line">    my_producer.join()</span><br><span class="line">    my_consumer.join()</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>multiprocessing中的queue不能用于pool进程池。pool中的进程间通信需要使用manager中的queue。</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue, Pool, Manager, Pipe</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(queue)</span>:</span></span><br><span class="line">    queue.put(<span class="string">"a"</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(queue)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    data = queue.get()</span><br><span class="line">    print(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    queue = Manager().Queue(<span class="number">10</span>)</span><br><span class="line">    pool = Pool(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    pool.apply_async(producer, args=(queue,))</span><br><span class="line">    pool.apply_async(consumer, args=(queue,))</span><br><span class="line"></span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Python 中有三个 Queue，需要注意不同点。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue, Pool, Manager, Pipe</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(pipe)</span>:</span></span><br><span class="line">    pipe.send(<span class="string">"bobby"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(pipe)</span>:</span></span><br><span class="line">    print(pipe.recv())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    recevie_pipe, send_pipe = Pipe()</span><br><span class="line">    <span class="comment">#pipe只能适用于两个进程</span></span><br><span class="line">    my_producer= Process(target=producer, args=(send_pipe, ))</span><br><span class="line">    my_consumer = Process(target=consumer, args=(recevie_pipe,))</span><br><span class="line"></span><br><span class="line">    my_producer.start()</span><br><span class="line">    my_consumer.start()</span><br><span class="line">    my_producer.join()</span><br><span class="line">    my_consumer.join()</span><br></pre></td></tr></table></figure>
<h3 id="6-7-2-使用-Pipe"><a href="#6-7-2-使用-Pipe" class="headerlink" title="6.7.2 使用 Pipe"></a>6.7.2 使用 Pipe</h3><blockquote>
<p>pipe的性能高于queue。但是 pipe只能适用于两个进程。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue, Pool, Manager, Pipe</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(pipe)</span>:</span></span><br><span class="line">    pipe.send(<span class="string">"bobby"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(pipe)</span>:</span></span><br><span class="line">    print(pipe.recv())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    recevie_pipe, send_pipe = Pipe()</span><br><span class="line">    <span class="comment">#pipe只能适用于两个进程</span></span><br><span class="line">    my_producer= Process(target=producer, args=(send_pipe, ))</span><br><span class="line">    my_consumer = Process(target=consumer, args=(recevie_pipe,))</span><br><span class="line"></span><br><span class="line">    my_producer.start()</span><br><span class="line">    my_consumer.start()</span><br><span class="line">    my_producer.join()</span><br><span class="line">    my_consumer.join()</span><br></pre></td></tr></table></figure>
<h3 id="6-7-3-使用-Manager-中的数据结构"><a href="#6-7-3-使用-Manager-中的数据结构" class="headerlink" title="6.7.3 使用 Manager() 中的数据结构"></a>6.7.3 使用 Manager() 中的数据结构</h3><blockquote>
<p>Manager 类中有 dict, array, list 等数据结构。可以通过共享这些数据结构对象，进而实现通信。但是，使用这种方式需要注意同步的问题，即需要加锁，保持数据一致性。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue, Pool, Manager, Pipe</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_data</span><span class="params">(p_dict, key, value)</span>:</span></span><br><span class="line">    p_dict[key] = value</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    progress_dict = Manager().dict()</span><br><span class="line"></span><br><span class="line">    first_progress = Process(target=add_data, args=(progress_dict, <span class="string">"bobby1"</span>, <span class="number">22</span>))</span><br><span class="line">    second_progress = Process(target=add_data, args=(progress_dict, <span class="string">"bobby2"</span>, <span class="number">23</span>))</span><br><span class="line"></span><br><span class="line">    first_progress.start()</span><br><span class="line">    second_progress.start()</span><br><span class="line">    first_progress.join()</span><br><span class="line">    second_progress.join()</span><br><span class="line">    print(progress_dict)</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://blog.csdn.net/kisslotus/article/details/83990214" target="_blank" rel="noopener">https://blog.csdn.net/kisslotus/article/details/83990214</a></p>
<!-- indicate-the-source -->]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>多线程</tag>
        <tag>多进程</tag>
        <tag>线程池</tag>
        <tag>进程池</tag>
      </tags>
  </entry>
  <entry>
    <title>python -- 序列类</title>
    <url>/2019/06/12/python-%E5%BA%8F%E5%88%97%E7%B1%BB/</url>
    <content><![CDATA[<p>python 序列类型</p>
<blockquote>
<p>序列类型主要可分为以下几个类别：</p>
</blockquote>
<ol>
<li>容器序列：list、tuple、deque</li>
<li>扁平序列：str、bytes、bytearray、array.array</li>
<li>可变序列：list， deque，bytearray、array</li>
<li>不可变序列：str、tuple、bytes</li>
</ol>
<a id="more"></a>
<h3 id="1-bisect模块"><a href="#1-bisect模块" class="headerlink" title="1.bisect模块"></a>1.bisect模块</h3><blockquote>
<p>bisect 模块常常用来维护一个已排序的升序序列。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="comment">#用来处理已排序的序列，用来维持已排序的序列， 升序</span></span><br><span class="line"><span class="comment">#二分查找</span></span><br><span class="line">inter_list = deque()</span><br><span class="line">bisect.insort(inter_list, <span class="number">3</span>)</span><br><span class="line">bisect.insort(inter_list, <span class="number">2</span>)</span><br><span class="line">bisect.insort(inter_list, <span class="number">5</span>)</span><br><span class="line">bisect.insort(inter_list, <span class="number">1</span>)</span><br><span class="line">bisect.insort(inter_list, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">print(bisect.bisect_left(inter_list, <span class="number">3</span>))</span><br><span class="line"><span class="comment">#学习成绩</span></span><br><span class="line">print(inter_list)</span><br></pre></td></tr></table></figure>
<h3 id="2-array与list的不同点"><a href="#2-array与list的不同点" class="headerlink" title="2.array与list的不同点"></a>2.array与list的不同点</h3><p>1.array只能存在指定的数据类型，list可以存放各种数据类型</p>
<p>2.array性能高</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> array</span><br><span class="line"></span><br><span class="line">my_array = array.array(<span class="string">"i"</span>)</span><br><span class="line">my_array.append(<span class="number">1</span>)</span><br><span class="line">my_array.append(<span class="string">"abc"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="3-切片操作"><a href="#3-切片操作" class="headerlink" title="3.切片操作"></a>3.切片操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#模式[start:end:step]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    其中，第一个数字start表示切片开始位置，默认为0；</span></span><br><span class="line"><span class="string">    第二个数字end表示切片截止（但不包含）位置（默认为列表长度）；</span></span><br><span class="line"><span class="string">    第三个数字step表示切片的步长（默认为1）。</span></span><br><span class="line"><span class="string">    当start为0时可以省略，当end为列表长度时可以省略，</span></span><br><span class="line"><span class="string">    当step为1时可以省略，并且省略步长时可以同时省略最后一个冒号。</span></span><br><span class="line"><span class="string">    另外，当step为负整数时，表示反向切片，这时start应该比end的值要大才行。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">aList = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">17</span>]</span><br><span class="line"><span class="keyword">print</span> (aList[::])  <span class="comment"># 返回包含原列表中所有元素的新列表</span></span><br><span class="line"><span class="keyword">print</span> (aList[::<span class="number">-1</span>])  <span class="comment"># 返回包含原列表中所有元素的逆序列表</span></span><br><span class="line"><span class="keyword">print</span> (aList[::<span class="number">2</span>])  <span class="comment"># 隔一个取一个，获取偶数位置的元素</span></span><br><span class="line"><span class="keyword">print</span> (aList[<span class="number">1</span>::<span class="number">2</span>])  <span class="comment"># 隔一个取一个，获取奇数位置的元素</span></span><br><span class="line"><span class="keyword">print</span> (aList[<span class="number">3</span>:<span class="number">6</span>])  <span class="comment"># 指定切片的开始和结束位置</span></span><br><span class="line">aList[<span class="number">0</span>:<span class="number">100</span>]  <span class="comment"># 切片结束位置大于列表长度时，从列表尾部截断</span></span><br><span class="line">aList[<span class="number">100</span>:]  <span class="comment"># 切片开始位置大于列表长度时，返回空列表</span></span><br><span class="line"></span><br><span class="line">aList[len(aList):] = [<span class="number">9</span>]  <span class="comment"># 在列表尾部增加元素</span></span><br><span class="line">aList[:<span class="number">0</span>] = [<span class="number">1</span>, <span class="number">2</span>]  <span class="comment"># 在列表头部插入元素</span></span><br><span class="line">aList[<span class="number">3</span>:<span class="number">3</span>] = [<span class="number">4</span>]  <span class="comment"># 在列表中间位置插入元素</span></span><br><span class="line">aList[:<span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>]  <span class="comment"># 替换列表元素，等号两边的列表长度相等</span></span><br><span class="line">aList[<span class="number">3</span>:] = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]  <span class="comment"># 等号两边的列表长度也可以不相等</span></span><br><span class="line">aList[::<span class="number">2</span>] = [<span class="number">0</span>] * <span class="number">3</span>  <span class="comment"># 隔一个修改一个</span></span><br><span class="line"><span class="keyword">print</span> (aList)</span><br><span class="line">aList[::<span class="number">2</span>] = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]  <span class="comment"># 隔一个修改一个</span></span><br><span class="line">aList[::<span class="number">2</span>] = [<span class="number">1</span>,<span class="number">2</span>]  <span class="comment"># 左侧切片不连续，等号两边列表长度必须相等</span></span><br><span class="line">aList[:<span class="number">3</span>] = []  <span class="comment"># 删除列表中前3个元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> aList[:<span class="number">3</span>]  <span class="comment"># 切片元素连续</span></span><br><span class="line"><span class="keyword">del</span> aList[::<span class="number">2</span>]  <span class="comment"># 切片元素不连续，隔一个删一个</span></span><br></pre></td></tr></table></figure>
<h3 id="4-列表生成式、生成器表达式、字典推导式、集合推导式"><a href="#4-列表生成式、生成器表达式、字典推导式、集合推导式" class="headerlink" title="4. 列表生成式、生成器表达式、字典推导式、集合推导式"></a>4. 列表生成式、生成器表达式、字典推导式、集合推导式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列表生成式</span></span><br><span class="line">int_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">qu_list = [item * item <span class="keyword">for</span> item <span class="keyword">in</span> int_list]</span><br><span class="line">print(type(qu_list))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成器表达式</span></span><br><span class="line">odd_gen = (i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>) <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">print(type(odd_gen))</span><br><span class="line">odd_list = list(odd_gen)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典推导式</span></span><br><span class="line">my_dict = &#123;<span class="string">"key1"</span>: <span class="string">"bobby1"</span>, <span class="string">"key2"</span>: <span class="string">"bobby2"</span>&#125;</span><br><span class="line">reversed_dict = &#123;value: key <span class="keyword">for</span> key, value <span class="keyword">in</span> my_dict.items()&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合推导式</span></span><br><span class="line">my_set = &#123;key <span class="keyword">for</span> key, value <span class="keyword">in</span> my_dict.items()&#125;</span><br><span class="line">print(my_set)</span><br></pre></td></tr></table></figure>
<h3 id="5-序列中-extend-区别"><a href="#5-序列中-extend-区别" class="headerlink" title="5.序列中+ += extend 区别"></a>5.序列中+ += extend 区别</h3><ol>
<li>加号会创建一个新的序列；</li>
<li>+= 符号是在原有序列的基础上修改，实际调用的是 extend 方法；</li>
<li>extend 也是在原有序列的基础上修改，实际上调用的是 append 方法。</li>
</ol>
<h3 id="6-list-与-set、dict-性能对比"><a href="#6-list-与-set、dict-性能对比" class="headerlink" title="6. list 与 set、dict 性能对比"></a>6. list 与 set、dict 性能对比</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th>Set</th>
<th>List</th>
<th>Dict</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">是否要求 Hash</td>
<td>是</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td style="text-align:center">查找效率</td>
<td>优</td>
<td>中</td>
<td>良</td>
</tr>
<tr>
<td style="text-align:center">内存</td>
<td>小</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td style="text-align:center">是否记录元素顺序</td>
<td>否</td>
<td>是</td>
<td>是，但有变化</td>
</tr>
</tbody>
</table>
</div>
<p>1.dict 查找的性能远远大于 list<br>2.在 list 中随着 list 数据的增大查找时间会增大<br>3.在 dict 中查找元素不会随着 dict 的增大而增大<br>4.dict 的 key 或者 set 的值都必须是可以 hash 的。不可变对象 都是可hash的， str， fronzenset， tuple，自己实现的类 hash<br>5.dict 的内存花销大，但是查询速度快， 自定义的对象或者 python 内部的对象都是用 dict 包装的<br>6.dict 的存储顺序和元素添加顺序有关，添加数据有可能改变已有数据的顺序</p>
<h5 id="fronzenset"><a href="#fronzenset" class="headerlink" title="fronzenset"></a>fronzenset</h5><blockquote>
<p><strong>frozenset()</strong> 返回一个冻结的集合，冻结后集合不能再添加或删除任何元素。</p>
<p>函数签名 class frozenset([iterable])</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;a = frozenset(range(<span class="number">10</span>))     <span class="comment"># 生成一个新的不可变集合</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">frozenset([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = frozenset(<span class="string">'runoob'</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">frozenset([<span class="string">'b'</span>, <span class="string">'r'</span>, <span class="string">'u'</span>, <span class="string">'o'</span>, <span class="string">'n'</span>])   <span class="comment"># 创建不可变集合</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>序列类</tag>
      </tags>
  </entry>
  <entry>
    <title>python -- 迭代器和生成器</title>
    <url>/2019/07/01/python-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<h3 id="1-迭代器-Iterator-和可迭代的-Iterable"><a href="#1-迭代器-Iterator-和可迭代的-Iterable" class="headerlink" title="1. 迭代器 Iterator 和可迭代的 Iterable"></a>1. 迭代器 Iterator 和可迭代的 Iterable</h3><blockquote>
<p>迭代器是访问集合内元素的一种方式， 一般用来遍历数据。迭代器和以下标的访问方式不一样， 迭代器是不能返回的, 迭代器提供了一种惰性方式数据的方式。<br>可迭代的 Iterable 表示这个对象是可以迭代的。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable, Iterator</span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">iter_rator = iter(a)</span><br><span class="line"><span class="keyword">print</span> (isinstance(a, Iterable))</span><br><span class="line"><span class="keyword">print</span> (isinstance(iter_rator, Iterator))</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="2-迭代器"><a href="#2-迭代器" class="headerlink" title="2. 迭代器"></a>2. 迭代器</h3><h3 id="2-1-第一个例子"><a href="#2-1-第一个例子" class="headerlink" title="2.1 第一个例子"></a>2.1 第一个例子</h3><blockquote>
<p>使用 Python 内置的 iter 函数获得迭代器</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterator</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, employee_list)</span>:</span></span><br><span class="line">        self.employee = employee_list</span><br><span class="line">	</span><br><span class="line">	<span class="comment"># 如果重写这个函数，需要返回迭代器，否则会报错</span></span><br><span class="line">	<span class="comment"># 优先调用 __iter__ 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> MyIterator(self.employee)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 如果没有 __iter__ 方法，才会调用这个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.employee[item]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    company = Company([<span class="string">"tom"</span>, <span class="string">"bob"</span>, <span class="string">"jane"</span>])</span><br><span class="line">    </span><br><span class="line">    my_itor = iter(company)</span><br></pre></td></tr></table></figure>
<h3 id="2-2-自定义迭代器"><a href="#2-2-自定义迭代器" class="headerlink" title="2.2 自定义迭代器"></a>2.2 自定义迭代器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterator</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, employee_list)</span>:</span></span><br><span class="line">        self.employee = employee_list</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> MyIterator(self.employee)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.employee[item]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承默认的 Iterator</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIterator</span><span class="params">(Iterator)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, employee_list)</span>:</span></span><br><span class="line">        self.iter_list = employee_list</span><br><span class="line">        self.index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># 迭代器是不支持切片的，需要自己维护索引，进而控制返回的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#真正返回迭代值的逻辑</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            word = self.iter_list[self.index]</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        self.index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> word</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    company = Company([<span class="string">"tom"</span>, <span class="string">"bob"</span>, <span class="string">"jane"</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 结束迭代的时候会返回 StopIteration，for 语句接收到这个 except，进而结束循环</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> company:</span><br><span class="line">        print(item)</span><br><span class="line">	<span class="comment"># 上面的 for 语句实现的功能可以用如下代码替代</span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">print</span> (next(my_itor))</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h3 id="3-生成器"><a href="#3-生成器" class="headerlink" title="3. 生成器"></a>3. 生成器</h3><blockquote>
<p>函数里只要有yield关键字就是生成器函数。</p>
</blockquote>
<h3 id="3-1-一个例子"><a href="#3-1-一个例子" class="headerlink" title="3.1 一个例子"></a>3.1 一个例子</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(index)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> index &lt;= <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fib(index<span class="number">-1</span>) + fib(index<span class="number">-2</span>)</span><br><span class="line">print(fib(<span class="number">2</span>),<span class="number">8888</span>)</span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib2</span><span class="params">(index)</span>:</span></span><br><span class="line">    re_list = [] <span class="comment"># 几十万上百万比较消耗内存</span></span><br><span class="line">    n,a,b = <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n&lt;index:</span><br><span class="line">        re_list.append(b)</span><br><span class="line">        a,b = b, a+b</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> re_list</span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_fib</span><span class="params">(index)</span>:</span></span><br><span class="line">    n,a,b = <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n&lt;index:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a,b = b, a+b</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> gen_fib(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">print</span> (data)</span><br><span class="line">-------------------------------------------------</span><br></pre></td></tr></table></figure>
<h3 id="3-2-读取只有单行的大文件"><a href="#3-2-读取只有单行的大文件" class="headerlink" title="3.2 读取只有单行的大文件"></a>3.2 读取只有单行的大文件</h3><blockquote>
<p>假设有个文件有 500G，并且只有一行，使用通常的方法都无法满足需求，我们使用每次读取 read(4096) 个字符，再加上 yield 方式完成需求。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#500G, 特殊 一行</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myreadlines</span><span class="params">(f, newline)</span>:</span></span><br><span class="line">  buf = <span class="string">""</span> <span class="comment"># 可以理解为缓存，存储已经读出的数据量</span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">while</span> newline <span class="keyword">in</span> buf: <span class="comment"># 查看缓存中是否有&#123;|&#125;分隔符</span></span><br><span class="line">      pos = buf.index(newline)</span><br><span class="line">      <span class="keyword">yield</span> buf[:pos]</span><br><span class="line">      buf = buf[pos + len(newline):]</span><br><span class="line">    chunk = f.read(<span class="number">4096</span>) <span class="comment"># 刚开始时候是空字符串，先读4096个字符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> chunk:</span><br><span class="line">      <span class="comment"># 处理边缘条件</span></span><br><span class="line">      <span class="comment">#说明已经读到了文件结尾</span></span><br><span class="line">      <span class="keyword">yield</span> buf</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    buf += chunk</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"input.txt"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> myreadlines(f, <span class="string">"&#123;|&#125;"</span>):</span><br><span class="line">        <span class="keyword">print</span> (line)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>iterator</tag>
        <tag>yield</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka -- 集群安装与配置（Docker）</title>
    <url>/2018/10/09/windows-docker-nginx-request-error/</url>
    <content><![CDATA[<h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><blockquote>
<p>在windows10中安装docker toolbox，启动nginx，页面无法访问</p>
</blockquote>
<h5 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.在windows上运行的docker实际是在Linux中运行</span><br><span class="line">2.启动的服务中的localhost指linux中，而不是宿主机windows中的地址</span><br><span class="line">3.使用docker-machine ip default 得到真正的ip是192.168.99.100</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>windows10</category>
        <category>docker toolbox</category>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>windows10</tag>
      </tags>
  </entry>
  <entry>
    <title>strace -- 跟踪器</title>
    <url>/2018/10/09/strace%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="什么是strace"><a href="#什么是strace" class="headerlink" title="什么是strace"></a>什么是strace</h4><blockquote>
<p>strace是一个可用于诊断，调试，用户控件跟踪器，监控用户空间进程和内核的交互，如系统调用，信号传递，进程状态变更</p>
</blockquote>
<a id="more"></a>
<h4 id="strace常用选项："><a href="#strace常用选项：" class="headerlink" title="strace常用选项："></a>strace常用选项：</h4><p>从一个示例命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">strace -tt -T -v -f -e trac=file -o /data/<span class="built_in">log</span>/strace.log -s 1024 -p 23489</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-tt 在每行输出的前面，显示毫秒级别的时间</p>
<p>-T 显示每次系统调用所花费的时间</p>
<p>-v 对于某些相关调用，把完整的环境变量，文件stat结构打印出来</p>
<p>-f 跟踪目标进程，以及目标进程穿件的所有子进程</p>
<p>-e 控制要跟踪的时间和跟踪行为，如指定要跟踪的系统调用名称</p>
<p>-o 把strace输出单独写到指定文件</p>
<p>-s当系统调用的某个参数是字符串时，最多输出指定长度的内容，默认是32字节</p>
<p>-p指定要跟踪的进程pid，要同时跟踪多个pid，重复多次-p选项即可</p>
</blockquote>
<h4 id="系统调用函数分类说明"><a href="#系统调用函数分类说明" class="headerlink" title="系统调用函数分类说明"></a>系统调用函数分类说明</h4><h5 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h5><div class="table-container">
<table>
<thead>
<tr>
<th>函数名</th>
<th>说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td>fork</td>
<td>创建一个新进程 </td>
</tr>
<tr>
<td>clone</td>
<td>按指定条件创建子进程 </td>
</tr>
<tr>
<td>execve</td>
<td>运行可执行文件 </td>
</tr>
<tr>
<td>pause</td>
<td>进程将除域阻塞状态 </td>
</tr>
<tr>
<td>wait</td>
<td>等待子进程终止 </td>
</tr>
<tr>
<td>waitpid</td>
<td>等待指定子进程终止 </td>
</tr>
</tbody>
</table>
</div>
<h5 id="文件和设备访问"><a href="#文件和设备访问" class="headerlink" title="文件和设备访问"></a>文件和设备访问</h5><div class="table-container">
<table>
<thead>
<tr>
<th>函数名</th>
<th>说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td>open</td>
<td>打开文件 </td>
</tr>
<tr>
<td>creat</td>
<td>创建新文件 </td>
</tr>
<tr>
<td>close</td>
<td>关闭文件描述字 </td>
</tr>
<tr>
<td>read</td>
<td>读文件 </td>
</tr>
<tr>
<td>write</td>
<td>写文件 </td>
</tr>
<tr>
<td>pread</td>
<td>对文件随机读 </td>
</tr>
<tr>
<td>pwirte</td>
<td>对文件随机写 </td>
</tr>
<tr>
<td>poll</td>
<td>I/O多路转换 </td>
</tr>
<tr>
<td>truncate</td>
<td>截断文件 </td>
</tr>
</tbody>
</table>
</div>
<h5 id="文件系统操作"><a href="#文件系统操作" class="headerlink" title="文件系统操作"></a>文件系统操作</h5><div class="table-container">
<table>
<thead>
<tr>
<th>函数名</th>
<th>说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td>access</td>
<td>确定文件的可存取 </td>
</tr>
<tr>
<td>chmod</td>
<td></td>
</tr>
<tr>
<td>chown</td>
<td>改变文件的主，组 </td>
</tr>
<tr>
<td>chroot</td>
<td>改变根目录 </td>
</tr>
<tr>
<td>stat</td>
<td>获取文件状态信息 </td>
</tr>
<tr>
<td>lstat</td>
<td>参见stat </td>
</tr>
<tr>
<td>getdents</td>
<td>读取目录项 </td>
</tr>
<tr>
<td>mkdir</td>
<td>创建目录 </td>
</tr>
<tr>
<td>link</td>
<td>创建链接 </td>
</tr>
</tbody>
</table>
</div>
<h5 id="内存管路"><a href="#内存管路" class="headerlink" title="内存管路"></a>内存管路</h5><div class="table-container">
<table>
<thead>
<tr>
<th>函数名</th>
<th>说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td>mmap</td>
<td>映射虚拟内存页 </td>
</tr>
<tr>
<td>sync</td>
<td>将内存缓冲区数据写回硬盘 </td>
</tr>
</tbody>
</table>
</div>
<h5 id="socket控制"><a href="#socket控制" class="headerlink" title="socket控制"></a>socket控制</h5><div class="table-container">
<table>
<thead>
<tr>
<th>函数名</th>
<th>说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td>socketall</td>
<td>socket系统调用 </td>
</tr>
<tr>
<td>socket</td>
<td>建立socket </td>
</tr>
<tr>
<td>bind</td>
<td>绑定socket端口 </td>
</tr>
<tr>
<td>connect</td>
<td>链接远程主机 </td>
</tr>
<tr>
<td>send</td>
<td>通过socket发送信息 </td>
</tr>
<tr>
<td>sendto</td>
<td>发送UDP信息 </td>
</tr>
<tr>
<td>sendmsg</td>
<td>参见send </td>
</tr>
<tr>
<td>listen</td>
<td>监听socket端口 </td>
</tr>
<tr>
<td>select</td>
<td>对多路同步I/O进行轮询 </td>
</tr>
</tbody>
</table>
</div>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strace -ff -o out nc -l 8080</span><br><span class="line"># -ff 抓取nc -l 8080 所有进程线程的对内核的调用</span><br><span class="line">会产生一个nc -l 8080 进程所对应进程id的文件</span><br><span class="line">如：out.92345</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">无法链接到服务器</span><br><span class="line">ping www.baidu.com</span><br><span class="line">strace -e connect，select，poll，sendto www.baidu.com</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
        <category>strace</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>strace</tag>
      </tags>
  </entry>
  <entry>
    <title>io -- 多路复用 理解</title>
    <url>/2020/05/09/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<h5 id="不通过浏览器访问百度主页"><a href="#不通过浏览器访问百度主页" class="headerlink" title="不通过浏览器访问百度主页"></a>不通过浏览器访问百度主页</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exec</span> 8&lt;&gt; /dev/tcp/www.baidu.com/80</span><br><span class="line"><span class="comment"># 8文件描述符 可以理解为一个对象</span></span><br><span class="line"><span class="comment"># &lt;&gt; 输入输出流</span></span><br><span class="line"><span class="comment"># 以读写方式打开/dev/tcp，并指定服务器名为:www.baidu.com,端口号为：80,指定描述符为8 要注意的是 /dev/tcp本身是不存在的</span></span><br><span class="line"><span class="comment"># /dev/tcp  类似于发出了一个socket调用，建立一个socket连接，读写这个文件就相当于在这个socket连接中传输数据</span></span><br><span class="line"><span class="built_in">cd</span> /proc/$$/fd</span><br><span class="line"><span class="comment"># $$ 当前解释器的进程</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><img src="http://q9xxrt86m.bkt.clouddn.com/socket.jpg" alt=""></p>
<blockquote>
<p>关闭文件描述符  exec 8&lt;&amp;-</p>
</blockquote>
<p>以上已经创建TCP连接，剩下的就是应用层协议交互的过程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">'GET / HTTP/1.0\n'</span> 1&gt;&amp; 8</span><br><span class="line">cat 0&lt;&amp; 8</span><br></pre></td></tr></table></figure>
<h5 id="TCP描述"><a href="#TCP描述" class="headerlink" title="TCP描述"></a>TCP描述</h5><blockquote>
<p>面向连接的，可靠的传输协议(确认机制)</p>
</blockquote>
<ul>
<li>面向连接（涉及到的就是三次握手），这里的连接并不是物理的，而是一个抽象的概念，三次握手之后开辟内存资源，并与上层的应用程序汇报，连接已经创建，资源的目的是为对方提供服务，</li>
</ul>
<p><img src="http://q9xxrt86m.bkt.clouddn.com/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SYN攻击：</span><br><span class="line">在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行：#netstat -nap | grep SYN_RECV</span><br></pre></td></tr></table></figure>
<blockquote>
<p>四次分手 双方都想端来连接，才会释放资源</p>
</blockquote>
<p><img src="http://q9xxrt86m.bkt.clouddn.com/%E5%9B%9B%E6%AC%A1%E5%88%86%E6%89%8B.png" alt=""></p>
<p>在LInux中演示三次握手，四次分手</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -nn -i eth0 port 80</span><br><span class="line"><span class="comment"># -nn 不显示协议名称，直接显示IP port</span></span><br><span class="line"><span class="comment"># -i 抓取那块网卡的数据包</span></span><br><span class="line"><span class="comment"># eth0 网卡</span></span><br><span class="line">curl www.baidu.com</span><br></pre></td></tr></table></figure>
<p><img src="http://q9xxrt86m.bkt.clouddn.com/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E5%88%86%E6%89%8B%E8%BF%87%E7%A8%8B.png" alt=""></p>
<blockquote>
<p>三次握手 ——&gt;传输数据—&gt;四次分手</p>
<p>整体可以算做一个粒度，不应该被拆散，如果做了一个负载均衡，有多台服务器，从三次握手 ——&gt;传输数据—&gt;四次分手 客户端只能给一个server发送</p>
</blockquote>
<h5 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 终端1</span></span><br><span class="line">strace -ff -o out nc -l 8080</span><br><span class="line"> <span class="comment"># -ff 抓取nc -l 8080 所有进程线程的对内核的调用会产生一个nc -l 8080 </span></span><br><span class="line"> 进程所对应进程id的文件如：out.92345</span><br><span class="line"> <span class="comment"># 终端2</span></span><br><span class="line"> nc localhost 8080</span><br><span class="line"> <span class="comment"># 终端3</span></span><br><span class="line"> tail -f out.92345 查看系统调用的过程</span><br><span class="line"> ![](http://q9xxrt86m.bkt.clouddn.com/BIO%E9%98%BB%E5%A1%9E%E5%BC%8Fio.png)</span><br></pre></td></tr></table></figure>
<p> <img src="http://q9xxrt86m.bkt.clouddn.com/strace%E7%9B%91%E6%B5%8B%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png" alt=""></p>
<blockquote>
<p>BIO 阻塞式IO，</p>
</blockquote>
]]></content>
      <categories>
        <category>io</category>
        <category>多路复用</category>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>io</tag>
        <tag>多路复用</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据 Hbase伪分布式集群安装</title>
    <url>/2020/06/20/%E5%A4%A7%E6%95%B0%E6%8D%AE-hbase%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h4 id="HBase伪分布式环境部署"><a href="#HBase伪分布式环境部署" class="headerlink" title="HBase伪分布式环境部署"></a>HBase伪分布式环境部署</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hadoop@hadoop001:~ $ cd ~&#x2F;softeware</span><br><span class="line">hadoop@hadoop001:~&#x2F;software $ tar -zxvf hbase-1.2.4-bin.tar.gz –C ..&#x2F;app</span><br><span class="line">hadoop@hadoop001:~&#x2F;software $ cd ..&#x2F;app</span><br><span class="line">hadoop@hadoop001:~&#x2F;app $ cd hbase-1.2.4&#x2F;conf</span><br><span class="line">hadoop@hadoop001:~&#x2F;app&#x2F;hbase-1.2.4&#x2F;conf $ cp ~&#x2F;app&#x2F;hadoop-2.7.3&#x2F;etc&#x2F;hadoop</span><br><span class="line">&#x2F;hdfs-site.xml .</span><br><span class="line">hadoop@hadoop001:~&#x2F;app&#x2F;hbase-1.2.4&#x2F;conf $ cp ~&#x2F;app&#x2F;hadoop-2.7.3&#x2F;etc&#x2F;hadoop</span><br><span class="line">&#x2F;core-site.xml .</span><br><span class="line">hadoop@hadoop001:~&#x2F;app&#x2F;hbase-1.2.4&#x2F;conf $ vi hbase-env.sh</span><br><span class="line">export JAVA_HOME&#x3D;~&#x2F;app&#x2F;jdk1.8.0_161</span><br><span class="line"># export HBASE_MASTER_OPTS&#x3D;”$HBASE_MASTER_OPTS –XX:PermSize&#x3D;128m –XX:MaxPermSize</span><br><span class="line">&#x3D;128m”</span><br><span class="line"># export HBASE_REGIONSERVER_OPTS&#x3D;”$HBASE_REGIONSERVER_OPTS –XX:PermSize&#x3D;128m –XX:</span><br><span class="line">MaxPermSize&#x3D;128m”</span><br><span class="line">hadoop@hadoop001:~&#x2F;app&#x2F;hbase-1.2.4&#x2F;conf $ vi hbase-site.xml</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hbase.root.dir &lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;hdfs:&#x2F;&#x2F;localhost:9000&#x2F;hbase&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hbase.zookeeper.property.dataDir&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;&#x2F;home&#x2F;hadoop&#x2F;hadoop_data&#x2F;zookeeper &lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hbase.cluster.distributed&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;true&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br><span class="line">hadoop@hadoop001:~&#x2F;app&#x2F;hbase-1.2.4&#x2F;conf $ cd ..&#x2F;bin</span><br><span class="line">hadoop@hadoop001:~&#x2F;app&#x2F;hbase-1.2.4&#x2F;bin $ .&#x2F;start-hbase.sh</span><br><span class="line">hadoop@hadoop001:~&#x2F;app&#x2F;hbase-1.2.4&#x2F;bin $ jps</span><br><span class="line">13792 HQuorumPeer</span><br><span class="line">13968 HRegionServer</span><br><span class="line">13864 HMaster</span><br><span class="line">12156 NameNode</span><br><span class="line">12556 SecondaryNameNode</span><br><span class="line">14317 Jps</span><br><span class="line">12335 DataNode</span><br><span class="line">hadoop@hadoop001:~&#x2F;app&#x2F;hbase-1.2.4&#x2F;bin $ .&#x2F;hbase shell</span><br><span class="line">hbase(main):001:0&gt; status</span><br><span class="line">1 active master, 0 backup master, 1 servers, 0 dead, 2.0000 average load </span><br><span class="line">hadoop@hadoop001:~&#x2F;app&#x2F;hbase-1.2.4&#x2F;bin $ cd ~&#x2F;app&#x2F;hadoop-2.7.3&#x2F;bin</span><br><span class="line">hadoop@hadoop001: ~&#x2F;app&#x2F;hadoop-2.7.3&#x2F;bin $ .&#x2F;hdfs dfs –ls &#x2F;</span><br><span class="line">Found 2 items</span><br><span class="line">drwxr-xr-x  - hadoop supergroup 0 2018-07-15 17:23 &#x2F;hbase</span><br><span class="line">drwxr-xr-x  - hadoop supergroup 0 2018-07-15 17:08 &#x2F;test</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Hbase</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>Hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>go -- 生成指定大小文件</title>
    <url>/2020/08/21/go-%E7%94%9F%E6%88%90%E6%8C%87%E5%AE%9A%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%8C%E5%86%85%E5%AE%B9%E8%87%AA%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"math"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">		<span class="string">"name"</span>: <span class="string">"harry"</span>,</span><br><span class="line">		<span class="string">"age"</span>: <span class="number">20</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	sStr, err := json.Marshal(s)</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(sStr))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">	CreateFixedFile(<span class="number">4</span>*<span class="number">1024</span>, <span class="keyword">string</span>(sStr), <span class="string">"./small.txt"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建指定大小文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateFixedFile</span><span class="params">(size <span class="keyword">float64</span>, source <span class="keyword">string</span>, fileName <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	file, err := os.OpenFile(fileName, os.O_CREATE|os.O_WRONLY|os.O_APPEND, os.ModePerm)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	count := math.Ceil(<span class="keyword">float64</span>(size) / <span class="keyword">float64</span>(<span class="built_in">len</span>(source)))</span><br><span class="line"></span><br><span class="line">	fmt.Println(count)</span><br><span class="line">	n, err := file.WriteString(strings.Repeat(source+<span class="string">","</span> + <span class="string">"\r\n"</span>, <span class="keyword">int</span>(count)) )</span><br><span class="line">	HandleErr(err)</span><br><span class="line">	fmt.Println(n)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleErr</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
        <category>file</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>file</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机基础 -- 存储单元转换</title>
    <url>/2016/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>位（bit）：一个数字0或者一个数字1，代表一位。<br>字节（Byte）：每逢8位是一个字节，这是数据存储的最小单位。</p>
<p>1 Byte = 8 bit</p>
<p>1 KB = 1024 Byte<br>1 MB = 1024 KB<br>1 GB = 1024 MB<br>1 TB = 1024 GB<br>1 PB = 1024 TB<br>1 EB = 1024 PB<br>1 ZB = 1024 EB</p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>存储单元转换</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>存储单元转换</tag>
      </tags>
  </entry>
  <entry>
    <title>字符编码-ASCII-Unicode-UTF8</title>
    <url>/2020/03/21/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%EF%BC%9AASCII-Unicode-%E5%92%8CUTF-8/</url>
    <content><![CDATA[<h4 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h4><p><img src="//tvax2.sinaimg.cn/large/d479ba17ly1gfytwuvab6j20oo0kljsx.jpg" alt=""></p>
<h4 id="扩展ASCII码"><a href="#扩展ASCII码" class="headerlink" title="扩展ASCII码"></a><strong>扩展ASCII码</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1000 0000</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">1111 1111</span><br></pre></td></tr></table></figure>
<p>当欧洲国家开始使用计算机的时候，发现原有的ASCII根本不够用，所在在原有的ASCII进行了扩展,把原来的第1位0变成了1</p>
<h4 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h4><p>当电脑来到中国时，256个字符也是太少了，就不能用8位表示，用16位表示一个字符</p>
<p>设计字符集:</p>
<p>使用分区管理，共计94个区，每个区含94位，共8836个码位</p>
<ul>
<li><p>01-09区 收录除汉字外的682个字符                                                                                                 </p>
</li>
<li><p>10-15区为空白区，没有使用                                                                                                             </p>
</li>
<li><p>15-55区收录3755个一级汉字,按照拼音排序                                                                                      </p>
</li>
<li><p>56-87区收录3008个二级汉字，按照部首、笔画排序                                                                         </p>
</li>
<li><p>88-94区为空白区，没有使用                                                                                                             </p>
</li>
</ul>
<p><img src="//tva2.sinaimg.cn/large/d479ba17ly1gfytps1jvwj2082072gmj.jpg" alt=""></p>
<p><img src="//tva4.sinaimg.cn/large/d479ba17ly1gfytqbjzk7j208206w0u4.jpg" alt=""></p>
<p><img src="//tva2.sinaimg.cn/large/d479ba17ly1gfytqpnxfej207u06jab7.jpg" alt=""></p>
<p><img src="//tva2.sinaimg.cn/large/d479ba17ly1gfytr5i0e7j20ai07b76a.jpg" alt=""></p>
<p><img src="//tva1.sinaimg.cn/large/d479ba17ly1gfytrg9z1gj20au0730un.jpg" alt=""></p>
<p><img src="//tva2.sinaimg.cn/large/d479ba17ly1gfytsgq70bj21870pk4qq.jpg" alt=""></p>
<p><img src="//tvax1.sinaimg.cn/large/d479ba17ly1gfytrspti7j21930pj4qq.jpg" alt=""></p>
<p>参考：<a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html</a></p>
]]></content>
      <categories>
        <category>字符编码</category>
      </categories>
      <tags>
        <tag>ASCII</tag>
        <tag>Unicode</tag>
      </tags>
  </entry>
  <entry>
    <title>子网络掩码</title>
    <url>/2018/12/21/%E7%BD%91%E7%BB%9C-ip%E5%9C%B0%E5%9D%80-%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81/</url>
    <content><![CDATA[<h4 id="一道面试题"><a href="#一道面试题" class="headerlink" title="一道面试题"></a>一道面试题</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下列那个ip地址不在192.168.11.18&#x2F;30网段中？</span><br><span class="line">A) 192.168.11.17</span><br><span class="line">B）192.168.11.18</span><br><span class="line">C) 192.168.11.19</span><br><span class="line">D) 192.168.11.20</span><br></pre></td></tr></table></figure>
<h4 id="1-子网络掩码，作用"><a href="#1-子网络掩码，作用" class="headerlink" title="1.子网络掩码，作用"></a>1.子网络掩码，作用</h4><blockquote>
<p>网络掩码”又叫“子网掩码”、“地址掩码”、“子网路遮罩”（subnet mask），它是一种用来指明一个<a href="https://zh.wikipedia.org/wiki/IP%E5%9C%B0%E5%9D%80" target="_blank" rel="noopener">IP地址</a>的哪些位标识的是主机所在的网络地址以及哪些位标识的是主机地址的<a href="https://zh.wikipedia.org/wiki/%E6%8E%A9%E7%A0%81" target="_blank" rel="noopener">位掩码</a>。</p>
<p>来源：维基百科</p>
</blockquote>
<ul>
<li>作用：就是将ip地址划分为网络地址和主机地址两个部分</li>
</ul>
<a id="more"></a>
<h4 id="2-子网络掩码的分类"><a href="#2-子网络掩码的分类" class="headerlink" title="2.子网络掩码的分类"></a>2.子网络掩码的分类</h4><ol>
<li><p>缺省子网络掩码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A类网络缺省子网掩码： 255.0.0.0，用CIDR表示为&#x2F;8</span><br><span class="line">B类网络缺省子网掩码： 255.255.0.0，用CIDR表示为&#x2F;16</span><br><span class="line">C类网络缺省子网掩码： 255.255.255.0，用CIDR表示为&#x2F;24</span><br></pre></td></tr></table></figure>
<p>2.自定义子网络掩码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将一个网络划分子网后，把原本的主机号位置的一部分给了子网号，余下的才是给了子网的主机号</span><br><span class="line">做子网划分后的IP地址：网络号＋子网号＋子网主机号</span><br><span class="line">如：192.168.1.100&#x2F;25，</span><br><span class="line">其子网掩码表示：255.255.255.128</span><br><span class="line">其子网掩码二进制表示:11111111.11111111.11111111.10000000</span><br><span class="line">意思就是将192.168.1.0这个网段的主机位的最高1位划分为了子网</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="3-子网个数"><a href="#3-子网个数" class="headerlink" title="3.子网个数"></a>3.子网个数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2n（n代表子网掩码往右移动的位数）</span><br></pre></td></tr></table></figure>
<h4 id="4-子网可用地址个数"><a href="#4-子网可用地址个数" class="headerlink" title="4. 子网可用地址个数"></a>4. 子网可用地址个数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每个子网可用地址个数（IP_num）&#x3D; 2^(8-n)-2</span><br></pre></td></tr></table></figure>
<h4 id="5-子网地址块大小"><a href="#5-子网地址块大小" class="headerlink" title="5.子网地址块大小"></a>5.子网地址块大小</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每个子网地址块大小（IP_block）&#x3D; 2^(8-n)</span><br></pre></td></tr></table></figure>
<h4 id="用上边的实例举例说明"><a href="#用上边的实例举例说明" class="headerlink" title="用上边的实例举例说明"></a>用上边的实例举例说明</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.11.18&#x2F;30</span><br><span class="line">网络地址：192.168.11.18 子网掩码用CIDR表示为&#x2F;30</span><br><span class="line">1.计算子网数</span><br><span class="line">    因为子网掩码用CIDR表示为&#x2F;30，</span><br><span class="line">    所以子网络掩码二进制：11111111.11111111.11111111.11111100</span><br><span class="line">    故子网络掩码：255.255.255.252</span><br><span class="line">    我们对比一下发现：例子中的C类子网掩码的网络地址比标准的C类子网掩码多了6位，其实比标准的自网络掩码多出来的位数，就是网络位</span><br><span class="line">    有效子网:2^6 &#x3D; 64个</span><br><span class="line">2. 子网可用地址个数</span><br><span class="line">	0表示主机位</span><br><span class="line">	主机个数: 2^2</span><br><span class="line">	有效主机个数: 2^2 -2 &#x3D; 2个 </span><br><span class="line">	每个子网络中的有效主机个数是2个</span><br><span class="line">3.子网地址块大小</span><br><span class="line">	2^(8-n) &#x3D; 4</span><br><span class="line">	第一个子网的广播地址192.168.11.0。第二个子网的广播地址192.168.11.4。第三个广播地址：192.168.11.8。第四个广播地址：192.168.11.12，第五个广播地址：192.168.11.16，第五个广播地址：192.168.11.20,....</span><br><span class="line"></span><br><span class="line">4.计算子网ip地址范围</span><br><span class="line">	第一个子网的网络地址:192.168.11.0主机地址是192.168.11.1到192.168.11.3,广播地址:192.168.11.4</span><br><span class="line">	第二个子网的网络地址:192.168.11.8主机地址是192.168.11.9到192.168.11.10,广播地址:192.168.11.11</span><br><span class="line">	第三个子网的网络地址:192.168.11.12主机地址是192.168.11.13到192.168.11.14,广播地址:192.168.11.15</span><br><span class="line">	第四个子网的网络地址:192.168.11.16主机地址是192.168.11.17到192.168.11.18,广播地址:192.168.11.19</span><br><span class="line">	第五个子网的网络地址:192.168.11.20主机地址是192.168.11.21到192.168.11.22,广播地址:192.168.11.23</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://www.jianshu.com/p/f70fcec5fc92" target="_blank" rel="noopener">https://www.jianshu.com/p/f70fcec5fc92</a></p>
]]></content>
      <categories>
        <category>网络</category>
        <category>ip</category>
        <category>Subnet Mask</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>ip</tag>
        <tag>Subnet Mask</tag>
      </tags>
  </entry>
  <entry>
    <title>零拷贝</title>
    <url>/2020/05/22/%E9%9B%B6%E6%8B%B7%E8%B4%9D%EF%BC%88zero%20copy%EF%BC%89/</url>
    <content><![CDATA[<h3 id="文件传输到网络的公共数据路径"><a href="#文件传输到网络的公共数据路径" class="headerlink" title="文件传输到网络的公共数据路径"></a>文件传输到网络的公共数据路径</h3><ul>
<li>操作系统将数据从磁盘读入到内核空间的页缓存（page cache）</li>
<li>应用程序将数据从内核空间读取到用户空间缓存中（因为应用程序无法直接操纵内核空间，只能操作用户空间）</li>
<li>应用程序将数据写回到内核空间到socket缓存中（要发送到网络中，所以需要写到socket缓存中）</li>
<li>操作系统将数据从socket缓冲区复制到网卡缓冲区，以便将数据经网络发出</li>
</ul>
<a id="more"></a>
<h3 id="零拷贝过程"><a href="#零拷贝过程" class="headerlink" title="零拷贝过程"></a>零拷贝过程</h3><ul>
<li>操作系统将数据从磁盘读入到内核空间的页缓存</li>
<li>将数据的位置和长度的信息的描述符增加至内核空间（socket缓冲区）</li>
<li>操作系统将数据从内核拷贝到网卡缓冲区，以便将数据经网络发出<blockquote>
<p>直接简化到了直接从内核拷贝到了网卡缓冲区<br>零拷贝并不是指所有的拷贝次数为0，而是值内核空间和用户空间的交互拷贝为0，</p>
</blockquote>
</li>
</ul>
<p><img src="//tvax2.sinaimg.cn/large/d479ba17gy1gfmgg7mlabj21d00h6jtw.jpg" alt=""></p>
]]></content>
      <categories>
        <category>Middleware</category>
        <category>MQ</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Middleware</tag>
        <tag>MQ</tag>
        <tag>Kafka</tag>
        <tag>零拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据 Hbase简介</title>
    <url>/2020/06/20/%E5%A4%A7%E6%95%B0%E6%8D%AE-Hbase/</url>
    <content><![CDATA[<h3 id="HBase简介"><a href="#HBase简介" class="headerlink" title="HBase简介"></a>HBase简介</h3><ul>
<li><p>HBase是一个分布式的、面向列的开源Nosql数据库</p>
</li>
<li><p>来源于googlBigtable</p>
<p>HBase在Hadoop之上提供了类似于Bigtable的能力（是基于Hadoop的HDFS进行存储）</p>
</li>
<li><p>HBase不同于一般的关系数据库，它适合非结构化数据存储</p>
</li>
<li><p>Bigtable是什么</p>
<p>Bigtable是压缩的、高性能的、高可扩展性的、基于Google GFS文件系统的数据库</p>
<p>用于存储大规模的结构化数据</p>
<p>在扩展性和性能方面有很大的优势</p>
</li>
<li><p>什么是面向列的数据库</p>
<p>即列式数据库，就是把每一列中的数据值放在一起进行存储</p>
<p>对应的就是行式数据库（常见的有关系型数据库）：把每一行的数据放在一起存储，存储完了之后就存储下一行的数据</p>
</li>
</ul>
<p><strong>为什么HBase适合非结构化数据存储</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">为什么HBase适合非结构化数据存储</span><br><span class="line">结构化数据与非结构化数据的概念</span><br><span class="line"></span><br><span class="line">结构化数据：可以用二维表格形式存储的数据</span><br><span class="line"></span><br><span class="line">非结构化数据：图片、文档这些可以认为为非结构化数据</span><br><span class="line"></span><br><span class="line">我们可以将这些非结构化数据以二进制的方式存到HBase里面，这样无论是存储还是查询都是比较方便快捷的，而且很容易进行扩展</span><br></pre></td></tr></table></figure>
<h3 id="HBase与HDFS"><a href="#HBase与HDFS" class="headerlink" title="HBase与HDFS"></a>HBase与HDFS</h3><ul>
<li>HBase建立在Hadoop文件系统之上，利用了Hadoop的文件系统的容错能力</li>
<li>HBase提供了对数据的随机实时读/写访问功能</li>
<li>HBase内部使用哈希表，并存储索引，可将在HDFS文件中的数据进行快速查找</li>
</ul>
<h3 id="HBase使用场景"><a href="#HBase使用场景" class="headerlink" title="HBase使用场景"></a>HBase使用场景</h3><ul>
<li>瞬间写入量很大，常用数据库不好支撑或需要很高成本支撑的场景</li>
<li>数据需要长久保存，且量会持久增长到比较大的场景</li>
<li>HBase不适用于有join，多级索引，表关系复杂的数据模型</li>
</ul>
<h3 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h3><p>CAP定理就是对于一个分布式计算系统不可能同时满足以下三点：</p>
<ul>
<li>一致性（所有节点在同一时间具有相同的数据）</li>
<li>可用性（保证每个请求不管成功或者失败都有响应，但不保证获取的数据为正确的数据）</li>
<li>分区容错性（系统中任意信息的丢失或失败不会影响系统的继续运作，系统如果不能在某一个时限内达成数据一致性，就必须在上面两个操作之间做出选择）</li>
</ul>
<p>那么对于分布式数据系统，分区容错性是最基本的要求，否则就失去了存在的意义，因此需要在一致性和可用性上做出取舍：在很多情况下会牺牲一致性从而来换取可用性，比如：Cassandra就是AP类型的，当然，牺牲一致性，只是要求不像关系型数据库一样，要求强一致性，而是要求系统能达到最终一致性。而HBase属于CP类型的，是强一致性的，它的每一行有regionserver、rowkey、版本标签等来组合，从而保证行的一致性。</p>
<h3 id="ACID定义"><a href="#ACID定义" class="headerlink" title="ACID定义"></a>ACID定义</h3><p>数据库事务正确执行的4个基本要素</p>
<ul>
<li>原子性（一个事务要么全部执行，要么全部不执行。如果执行过程中发生了错误，系统会回滚到最初的状态）</li>
<li>一致性（事务的运行，不会改变数据库中数据的一致性）</li>
<li>隔离性（2个以上的事务在执行的过程中，不会出现交错执行的状态（因为这样的话可能会导致数据的不一致））</li>
<li>持久性（一个事务执行成功之后，该事务对数据库的更改，要持久性的保存在数据库当中）</li>
</ul>
<p>一个支持事务的数据库系统中必须得有这4个特性，否则在事务的过程当中就无法保证事务的正确性</p>
<p>HBase作为一个NoSQL数据库，为了性能不支持严格的ACID，只支持到单个的行</p>
<h2 id="HBase概念"><a href="#HBase概念" class="headerlink" title="HBase概念"></a>HBase概念</h2><ul>
<li>NameSpace：可以把NameSpace理解为RDBMS的“数据库”，1个NameSpace包含一组表</li>
<li>Table：表名必须是能用在文件路径里的合法名字。这样做是因为HBase的表是映射成HDFS上相应的文件的，因此表名必须是合法的路径</li>
<li>Row：在表里面，每一行代表着一个数据对象，每一行都是以一个Row Key来进行唯一标识的，Row Key并没有什么特定的数据类型，以二进制的字节来存储</li>
<li>Column：HBase的列由Column family和Column qualifier组成，由冒号（:）进行间隔；比如 family:qualifier</li>
<li>RowKey：可以唯一标识一行记录，不可被改变；改变的唯一方式是删除这个RowKey，再重新插入</li>
<li>Column Family：是一些Column的集合，1个Column Family所包含的所有的Column成员是有着相同的前缀；在物理上1个Column Family所有的成员是存储在一起的，存储的优化都是针对Column Family级别的；这就意味着1个- Column Family的成员都是用相同的方式进行访问的；在定义HBase表的时候需要提前设置好列族，表中所有的列都需要组织在列族里面；列族一旦定义好之后，就不能轻易的更改了，因为它会影响到HBase真实的物理存储结构</li>
<li>Column Qualifier：列族中的数据通过列标识（Column Qualifier）来进行映射，可以理解为一个键值对，Column Qualifier就是key</li>
<li>Cell：每一个RowKey、Column Family、Column Qualifier共同组成的一个单元；存储在Cell里面就是我们想要保存的数据；Cell存储的数据没有特定的数据类型，以二进制字节来进行存储</li>
<li>Timestamp：每个值都会有一个timestamp，作为该值特定版本的标识符；默认HBase中每次插入数据的时候，都会用timestamp来进行版本标识；读取数据时，如果这个时间戳没有被指定，就默认返回最新的数据；写入数据时，如果没有设置时间戳，默认使用当前的时间戳；每一个列族的数据的版本都由HBase单独维护；默认情况下，HBase会保留3个版本的数据</li>
</ul>
<h2 id="HBase与传统关系型数据库的区别"><a href="#HBase与传统关系型数据库的区别" class="headerlink" title="HBase与传统关系型数据库的区别"></a>HBase与传统关系型数据库的区别</h2><p><img src="//tva3.sinaimg.cn/large/d479ba17ly1gfyuhy9bvkj21970mhk2n.jpg" alt=""></p>
<p>查询的时候只能通过API去查询，不支持SQL，所以也默认支持通过RowKey去进行查询<br>两者的数据排布方式有很大的区别：</p>
<ul>
<li>传统的数据库就是行列的组织</li>
<li>对于HBase这种NoSQL数据库我们可以理解为稀疏的多维的map</li>
</ul>
<p>每一行都是一个文件，每一列都是相关的属性</p>
<p><strong>关系型数据库：</strong></p>
<p><img src="//tvax1.sinaimg.cn/large/d479ba17ly1gfyuj0d0lvj21am0kk7cj.jpg" alt=""></p>
<p><img src="//tva1.sinaimg.cn/large/d479ba17ly1gfyujvakg6j21at0mm12h.jpg" alt=""></p>
<h3 id="HBase数据模型"><a href="#HBase数据模型" class="headerlink" title="HBase数据模型"></a>HBase数据模型</h3><p><img src="//tvax1.sinaimg.cn/large/d479ba17ly1gfyuldxw1bj20s40obtg4.jpg" alt=""></p>
<p><img src="//tva1.sinaimg.cn/large/d479ba17ly1gfyultxh5cj213h0npgu0.jpg" alt=""></p>
<h3 id="HBase基础架构"><a href="#HBase基础架构" class="headerlink" title="HBase基础架构"></a>HBase基础架构</h3><p><img src="//tvax2.sinaimg.cn/large/d479ba17ly1gfyutv9p8sj20pu0f7n1e.jpg" alt=""></p>
<p>HBase依托于HDFS之上；整体上又划分为HMaster和RegionServer，在上层通过Java API提供查询的功能；通过Zookeeper进行管理</p>
<p>通过上图我们可以发现，HBase工作的三大模块：</p>
<ol>
<li><p>HMaster</p>
<ul>
<li>HMaster是HBase主/从集群架构中的中央节点</li>
<li>HMaster用于协调多个RegionServer、检测各个RegionServer的状态、并且平衡各个RegionServer之间的负载、同时还负责分配region到RegionServer</li>
<li>region：region是HBase中存储的最小的单元、是HBase表格的基本单位</li>
<li>HMaster维护表和Region的元数据，不参与数据的输入/输出过程</li>
<li>HBase本身是支持HA的，也就是说同时可以有多个HMaster进行运行，但是只有1个处于active状态；如果处于active的节点失效了，挂掉了，其它的HMaster节点就会选举出一个active节点来接管整个HBase集群</li>
<li>HMaster只负责各种协调工作（ 其实就是打杂） ， 比如建表、 删表、移动Region、 合并等操作 </li>
</ul>
</li>
<li><p>RegionServer</p>
<ul>
<li>维护HMaster分配给他的region，处理堆这些region的io请求。当用户需要读取数据的时候会连接到对应的RegionServer，从相关的region中去获取数据</li>
<li>负责切分正在运行过程中变的过大的region，从而保证查询的效率</li>
</ul>
</li>
<li><p>Zookeeer</p>
<ul>
<li><p>Zookeeper是HBase HA的解决方案，是整个集群的协调器</p>
<p>通过Zookeeper保证了至少有一个HMaster处于active状态</p>
<p>HMaster并不直接参与数据的读写操作，当我们使用HBase的API的时候，当我们想用HBase的API去读取数据的时候，我们并不需要知道HMaster的地址、也不需要知道RegionServer的地址，我们只需要知Zookeeper集群的地址就可以了</p>
</li>
<li><p>HMaster启动将系统加载到Zookeeper</p>
<p>Zookeeper保存了HBase集群region的信息、meta的信息等等</p>
</li>
<li><p>维护着RegionServer的状态信息，知道哪些数据需要从哪些RegionServer去读取</p>
</li>
</ul>
</li>
</ol>
<p>结构化数据：可以用二维表格形式存储的数据</p>
<p>非结构化数据：图片、文档这些可以认为为非结构化数据</p>
<p>我们可以将这些非结构化数据以二进制的方式存到HBase里面，这样无论是存储还是查询都是比较方便快捷的，而且很容易进行扩展</p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Hbase</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>Hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>用GOB传输数据</title>
    <url>/2017/04/11/go-%E7%94%A8GOB%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>示例代码：</p>
<h5 id="go-编码到文件，读取文件内容并解码"><a href="#go-编码到文件，读取文件内容并解码" class="headerlink" title="go 编码到文件，读取文件内容并解码"></a>go 编码到文件，读取文件内容并解码</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bufio"</span></span><br><span class="line">	<span class="string">"encoding/gob"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">	Type             <span class="keyword">string</span></span><br><span class="line">	City             <span class="keyword">string</span></span><br><span class="line">	Country          <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> VCard <span class="keyword">struct</span> &#123;</span><br><span class="line">	FirstName	<span class="keyword">string</span></span><br><span class="line">	LastName	<span class="keyword">string</span></span><br><span class="line">	Addresses	[]*Address</span><br><span class="line">	Remark		<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//WriteGobFile()</span></span><br><span class="line">	ReadGobFile()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteGobFile</span><span class="params">()</span></span> &#123;</span><br><span class="line">	pa := &amp;Address&#123;<span class="string">"private"</span>, <span class="string">"Aartselaar"</span>,<span class="string">"Belgium"</span>&#125;</span><br><span class="line">	wa := &amp;Address&#123;<span class="string">"work"</span>, <span class="string">"Boom"</span>, <span class="string">"Belgium"</span>&#125;</span><br><span class="line">	vc := VCard&#123;<span class="string">"Jan"</span>, <span class="string">"Kersschot"</span>, []*Address&#123;pa,wa&#125;, <span class="string">"none"</span>&#125;</span><br><span class="line">	file, _ := os.OpenFile(<span class="string">"vcard.gob"</span>, os.O_CREATE|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	enc := gob.NewEncoder(file)  <span class="comment">// Will write to network.</span></span><br><span class="line">	err := enc.Encode(vc)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">"Error in encoding gob"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadGobFile</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file, err := os.Open(<span class="string">"vcard.gob"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	rd := bufio.NewReader(file)</span><br><span class="line">	dec := gob.NewDecoder(rd)</span><br><span class="line">	<span class="keyword">var</span> v VCard</span><br><span class="line">	err = dec.Decode(&amp;v)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(v)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考链接：<a href="https://github.com/zmjaction/the-way-to-go_ZH_CN/blob/master/eBook/12.11.md" target="_blank" rel="noopener">https://github.com/zmjaction/the-way-to-go_ZH_CN/blob/master/eBook/12.11.md</a></p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>GOB</tag>
      </tags>
  </entry>
</search>
