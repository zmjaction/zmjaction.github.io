<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yijunworld.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1. asyncio 简介">
<meta property="og:type" content="article">
<meta property="og:title" content="python -- asyncio">
<meta property="og:url" content="http://yijunworld.com/2019/07/06/python-asyncio/index.html">
<meta property="og:site_name" content="Action">
<meta property="og:description" content="1. asyncio 简介">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181222184931518.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215b25lbG90dXM=,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2019-07-06T14:27:29.000Z">
<meta property="article:modified_time" content="2020-06-08T05:53:30.789Z">
<meta property="article:author" content="Action">
<meta property="article:tag" content="python">
<meta property="article:tag" content="asyncio">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20181222184931518.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215b25lbG90dXM=,size_16,color_FFFFFF,t_70">

<link rel="canonical" href="http://yijunworld.com/2019/07/06/python-asyncio/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>python -- asyncio | Action</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Action" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Action</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">锤子</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">84</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">47</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">74</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/zmjaction" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yijunworld.com/2019/07/06/python-asyncio/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat.jpg">
      <meta itemprop="name" content="Action">
      <meta itemprop="description" content="热爱你所坚持的，坚持你所热爱的">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Action">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          python -- asyncio
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-06 22:27:29" itemprop="dateCreated datePublished" datetime="2019-07-06T22:27:29+08:00">2019-07-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="1-asyncio-简介"><a href="#1-asyncio-简介" class="headerlink" title="1. asyncio 简介"></a>1. asyncio 简介</h3><p><img src="https://img-blog.csdnimg.cn/20181222184931518.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215b25lbG90dXM=,size_16,color_FFFFFF,t_70" alt=""></p>
<a id="more"></a>
<h3 id="1-1-协程与-asyncio"><a href="#1-1-协程与-asyncio" class="headerlink" title="1.1 协程与 asyncio"></a>1.1 协程与 asyncio</h3><blockquote>
<p>协程编写的三个组成部分：1. 事件循环， 2. 回调(驱动生成器)， 3. epoll（IO 多路复用）<br><strong>asyncio 是 python 用于解决异步 IO 编程的一整套解决方案。</strong>基于 asyncio 的框架有: tornado、gevent、twisted（scrapy， django channels）。<br>django channels 用于 HTTP 2.0 开发；torando (实现 web 服务器)， 如果使用 django ，通常使用 django + flask (uwsgi, gunicorn+nginx) 的搭配方式；tornado 可以直接部署， 通常使用 nginx + tornado 的搭配方式。<br>asyncio 不能和 requests 库结合使用<br><a href="http://www.imooc.com/article/24759" target="_blank" rel="noopener">http://www.imooc.com/article/24759</a></p>
</blockquote>
<h3 id="2-asyncio-的使用"><a href="#2-asyncio-的使用" class="headerlink" title="2 asyncio 的使用"></a>2 asyncio 的使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">"start get url"</span>)</span><br><span class="line">    <span class="comment"># 这里不能使用 time.sleep(2) 模拟 HTTP 请求，因为这是一个同步阻塞的方式</span></span><br><span class="line">    <span class="comment"># 这个地方必须加 await</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"end get url"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    <span class="comment"># 相当于之前例子中的 loop 函数</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    tasks = [get_html(<span class="string">"http://www.imooc.com"</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">    <span class="comment"># loop.run_until_complete(get_html("http://www.imooc.com"))</span></span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    print(time.time()-start_time)</span><br></pre></td></tr></table></figure>
<h3 id="2-2-获取-asyncio-的返回值"><a href="#2-2-获取-asyncio-的返回值" class="headerlink" title="2.2 获取 asyncio 的返回值"></a>2.2 获取 asyncio 的返回值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取协程的返回值</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">"start get url"</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"bobby"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    <span class="comment"># 方式一：</span></span><br><span class="line">    <span class="comment"># get_future = asyncio.ensure_future(get_html("http://www.imooc.com"))</span></span><br><span class="line">    <span class="comment"># loop.run_until_complete(get_future)</span></span><br><span class="line">    <span class="comment"># print(get_future.result())</span></span><br><span class="line">    <span class="comment"># 方式一中会产生一个疑惑？即：</span></span><br><span class="line">    <span class="comment"># 使用 asyncio 模块，传入的参数中没有传入 Event loop，</span></span><br><span class="line">    <span class="comment"># 那么上面的 get_html("http://www.imooc.com") 事件是如何被注入到 loop 中的呢？</span></span><br><span class="line">    <span class="comment"># 答案不是在 loop.run_until_complete(get_future) 中完成的，而是在 ensure_future 中完成的，</span></span><br><span class="line">    <span class="comment"># 在这个方法中获取 Event loop，这个 loop 和我们自己创建的 loop 是同一个 loop。具体可以参考 ensure_future 源码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方式二：</span></span><br><span class="line">    <span class="comment"># task 是 Future 的一个子类</span></span><br><span class="line">    task = loop.create_task(get_html(<span class="string">"http://www.imooc.com"</span>))</span><br><span class="line">    loop.run_until_complete(task)</span><br><span class="line">    print(task.result())</span><br></pre></td></tr></table></figure>
<h3 id="2-3-call-back"><a href="#2-3-call-back" class="headerlink" title="2.3 call back"></a>2.3 call back</h3><blockquote>
<p>使用 call back 可以完成某些回调需求，比如完成某个任务，发送一封邮件；或者某个抓取线程耗时过长，通知你一下。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">"start get url"</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"bobby"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意，这里必须有一个 future 参数，这个 Future 就是下面的 task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(future)</span>:</span></span><br><span class="line">    print(<span class="string">"send email to bobby"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    task = loop.create_task(get_html(<span class="string">"http://www.imooc.com"</span>))</span><br><span class="line">    task.add_done_callback(callback)</span><br><span class="line">    loop.run_until_complete(task)</span><br><span class="line">    print(task.result())</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当 call back 有参数的时候，使用 from functools import partial 包装 callback。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">"start get url"</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"bobby"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意，这里必须有一个 Future 参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(url, future)</span>:</span></span><br><span class="line">    print(url)</span><br><span class="line">    print(<span class="string">"send email to bobby"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    task = loop.create_task(get_html(<span class="string">"http://www.imooc.com"</span>))</span><br><span class="line">    task.add_done_callback(partial(callback, <span class="string">"http://www.imooc.com"</span>))</span><br><span class="line">    loop.run_until_complete(task)</span><br><span class="line">    print(task.result())</span><br></pre></td></tr></table></figure>
<h3 id="2-4-wait-和-gather"><a href="#2-4-wait-和-gather" class="headerlink" title="2.4 wait 和 gather"></a>2.4 wait 和 gather</h3><h3 id="2-4-1-wait"><a href="#2-4-1-wait" class="headerlink" title="2.4.1 wait"></a>2.4.1 wait</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">"start get url"</span>)</span><br><span class="line">    <span class="comment"># 这里不能使用 time.sleep(2) 模拟 HTTP 请求，因为这是一个同步阻塞的方式</span></span><br><span class="line">    <span class="comment"># 这个地方必须加 await</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"end get url"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    tasks = [get_html(<span class="string">"http://www.imooc.com"</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">    <span class="comment"># wait 一次性完成多个任务的时候使用</span></span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    print(time.time()-start_time)</span><br></pre></td></tr></table></figure>
<h3 id="2-4-2-gather"><a href="#2-4-2-gather" class="headerlink" title="2.4.2 gather"></a>2.4.2 gather</h3><blockquote>
<p>gather 是比 wait 更加高一层的功能抽象。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">"start get url"</span>)</span><br><span class="line">    <span class="comment"># 这里不能使用 time.sleep(2) 模拟 HTTP 请求，因为这是一个同步阻塞的方式</span></span><br><span class="line">    <span class="comment"># 这个地方必须加 await</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"end get url"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    tasks = [get_html(<span class="string">"http://www.imooc.com"</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">    <span class="comment"># 这儿使用 gather 的时候，需要加一个星号，会将列表中的元素传进去</span></span><br><span class="line">    loop.run_until_complete(asyncio.gather(*tasks))</span><br><span class="line">    print(time.time()-start_time)</span><br></pre></td></tr></table></figure>
<h3 id="2-4-3-wait-与-gather-中的区别"><a href="#2-4-3-wait-与-gather-中的区别" class="headerlink" title="2.4.3 wait 与 gather 中的区别"></a>2.4.3 wait 与 gather 中的区别</h3><blockquote>
<p>gather 比 wait 更加高层。gather 可以将任务分组，一般优先使用 gather。在某些定制化任务需求的时候，会使用 wait。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例子一</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">"start get url"</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"end get url"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    tasks = [get_html(<span class="string">"http://www.imooc.com"</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">    group1 = [get_html(<span class="string">"http://projectsedu.com"</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">    group2 = [get_html(<span class="string">"http://www.imooc.com"</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">    </span><br><span class="line">    loop.run_until_complete(asyncio.gather(*group1, *group2))</span><br><span class="line">    print(time.time() - start_time)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例子二</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">"start get url"</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"end get url"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    tasks = [get_html(<span class="string">"http://www.imooc.com"</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">    group1 = [get_html(<span class="string">"http://projectsedu.com"</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">    group2 = [get_html(<span class="string">"http://www.imooc.com"</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">    group1 = asyncio.gather(*group1)</span><br><span class="line">    group2 = asyncio.gather(*group2)</span><br><span class="line">    </span><br><span class="line">    loop.run_until_complete(asyncio.gather(group1, group2))</span><br><span class="line">    print(time.time() - start_time)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例子三：成批的取消任务</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">"start get url"</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"end get url"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    tasks = [get_html(<span class="string">"http://www.imooc.com"</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">    group1 = [get_html(<span class="string">"http://projectsedu.com"</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">    group2 = [get_html(<span class="string">"http://www.imooc.com"</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">    group1 = asyncio.gather(*group1)</span><br><span class="line">    group2 = asyncio.gather(*group2)</span><br><span class="line">    group2.cancel()</span><br><span class="line">    loop.run_until_complete(asyncio.gather(group1, group2))</span><br><span class="line">    print(time.time() - start_time)</span><br></pre></td></tr></table></figure>
<h3 id="2-5-run-until-complete-实现的原理"><a href="#2-5-run-until-complete-实现的原理" class="headerlink" title="2.5 run_until_complete 实现的原理"></a>2.5 run_until_complete 实现的原理</h3><blockquote>
<p>loop.run_forever() 会让线程一直运行。loop.run_until_complete() 借助了 run_forever 方法。<br>在 run_until_complete 的实现中，调用了 future.add_done_callback(_run_until_complete_cb)。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_until_complete</span><span class="params">(self, future)</span>:</span></span><br><span class="line">       <span class="string">"""Run until the Future is done.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       If the argument is a coroutine, it is wrapped in a Task.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       WARNING: It would be disastrous to call run_until_complete()</span></span><br><span class="line"><span class="string">       with the same coroutine twice -- it would wrap it in two</span></span><br><span class="line"><span class="string">       different Tasks and that can't be good.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       Return the Future's result, or raise its exception.</span></span><br><span class="line"><span class="string">       """</span></span><br><span class="line">       self._check_closed()</span><br><span class="line"></span><br><span class="line">       new_task = <span class="keyword">not</span> futures.isfuture(future)</span><br><span class="line">       future = tasks.ensure_future(future, loop=self)</span><br><span class="line">       <span class="keyword">if</span> new_task:</span><br><span class="line">           <span class="comment"># An exception is raised if the future didn't complete, so there</span></span><br><span class="line">           <span class="comment"># is no need to log the "destroy pending task" message</span></span><br><span class="line">           future._log_destroy_pending = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">       future.add_done_callback(_run_until_complete_cb)</span><br><span class="line">       <span class="keyword">try</span>:</span><br><span class="line">           self.run_forever()</span><br><span class="line">       <span class="keyword">except</span>:</span><br><span class="line">           <span class="keyword">if</span> new_task <span class="keyword">and</span> future.done() <span class="keyword">and</span> <span class="keyword">not</span> future.cancelled():</span><br><span class="line">               <span class="comment"># The coroutine raised a BaseException. Consume the exception</span></span><br><span class="line">               <span class="comment"># to not log a warning, the caller doesn't have access to the</span></span><br><span class="line">               <span class="comment"># local task.</span></span><br><span class="line">               future.exception()</span><br><span class="line">           <span class="keyword">raise</span></span><br><span class="line">       <span class="keyword">finally</span>:</span><br><span class="line">           future.remove_done_callback(_run_until_complete_cb)</span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> future.done():</span><br><span class="line">           <span class="keyword">raise</span> RuntimeError(<span class="string">'Event loop stopped before Future completed.'</span>)</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> future.result()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 _run_until_complete_cb 方法中，在运行指定的任务后，停止掉。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_run_until_complete_cb</span><span class="params">(fut)</span>:</span></span><br><span class="line">    exc = fut._exception</span><br><span class="line">    <span class="keyword">if</span> (isinstance(exc, BaseException)</span><br><span class="line">    <span class="keyword">and</span> <span class="keyword">not</span> isinstance(exc, Exception)):</span><br><span class="line">        <span class="comment"># Issue #22429: run_forever() already finished, no need to</span></span><br><span class="line">        <span class="comment"># stop it.</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    fut._loop.stop()</span><br></pre></td></tr></table></figure>
<h3 id="2-6-取消任务"><a href="#2-6-取消任务" class="headerlink" title="2.6 取消任务"></a>2.6 取消任务</h3><blockquote>
<p>这个需求非常常用。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(sleep_times)</span>:</span></span><br><span class="line">    print(<span class="string">"waiting"</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(sleep_times)</span><br><span class="line">    print(<span class="string">"done after &#123;&#125;s"</span>.format(sleep_times))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    task1 = get_html(<span class="number">2</span>)</span><br><span class="line">    task2 = get_html(<span class="number">3</span>)</span><br><span class="line">    task3 = get_html(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    tasks = [task1, task2, task3]</span><br><span class="line"></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt <span class="keyword">as</span> e:</span><br><span class="line">        all_tasks = asyncio.Task.all_tasks()</span><br><span class="line">        <span class="keyword">for</span> task <span class="keyword">in</span> all_tasks:</span><br><span class="line">            print(<span class="string">"cancel task"</span>)</span><br><span class="line">            print(task.cancel())</span><br><span class="line">        loop.stop()</span><br><span class="line">        <span class="comment"># stop 调用之后，需要调用 run_forever，不然会报错</span></span><br><span class="line">        loop.run_forever()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        loop.close()</span><br></pre></td></tr></table></figure>
<h3 id="3-协程中嵌套协程，子协程"><a href="#3-协程中嵌套协程，子协程" class="headerlink" title="3 协程中嵌套协程，子协程"></a>3 协程中嵌套协程，子协程</h3><blockquote>
<p><a href="https://docs.python.org/3.6/library/asyncio-task.html" target="_blank" rel="noopener">https://docs.python.org/3.6/library/asyncio-task.html</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个例子，参考上面链接的序列图理解。</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">compute</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    print(<span class="string">"Compute %s + %s ..."</span> % (x, y))</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1.0</span>)</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">print_sum</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    result = <span class="keyword">await</span> compute(x, y)</span><br><span class="line">    print(<span class="string">"%s + %s = %s"</span> % (x, y, result))</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(print_sum(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>
<h3 id="4-asyncio-中的几个函数"><a href="#4-asyncio-中的几个函数" class="headerlink" title="4. asyncio 中的几个函数"></a>4. asyncio 中的几个函数</h3><h3 id="4-1-call-soon"><a href="#4-1-call-soon" class="headerlink" title="4.1 call soon"></a>4.1 call soon</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这儿定义的是函数，不是协程</span></span><br><span class="line"><span class="comment"># 因为在很多时候，我们希望在 loop 当中，也就是循环体系当中，插入一个函数，可以让函数立即执行</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(sleep_times)</span>:</span></span><br><span class="line">    print(<span class="string">"success time &#123;&#125;"</span>.format(sleep_times))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stoploop</span><span class="params">(loop)</span>:</span></span><br><span class="line">    loop.stop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#call_soon</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.call_soon(callback, <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 通过定义 stoploop 函数，停止 run_forever 循环</span></span><br><span class="line">    <span class="comment"># 注意这里的参数，是传入的 loop</span></span><br><span class="line">    loop.call_soon(stoploop, loop)</span><br><span class="line">    <span class="comment"># 启动，这儿不是使用 run_until_complete，因为 callback 不是协程。</span></span><br><span class="line">    loop.run_forever()</span><br></pre></td></tr></table></figure>
<h2 id="4-2-call-later"><a href="#4-2-call-later" class="headerlink" title="4.2 call later"></a>4.2 call later</h2><blockquote>
<p>call_later 中执行顺序并不是添加顺序，会根据延迟调用时间确定一个先后顺序。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(sleep_times)</span>:</span></span><br><span class="line">    print(<span class="string">"success time &#123;&#125;"</span>.format(sleep_times))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stoploop</span><span class="params">(loop)</span>:</span></span><br><span class="line">    loop.stop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#call_later, call_at</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    <span class="comment"># 执行顺序并不是添加顺序，会根据延迟调用时间确定一个先后顺序</span></span><br><span class="line">    loop.call_later(<span class="number">2</span>, callback, <span class="number">2</span>)</span><br><span class="line">    loop.call_later(<span class="number">1</span>, callback, <span class="number">1</span>)</span><br><span class="line">    loop.call_later(<span class="number">3</span>, callback, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动，这儿不是使用 run_until_complete，因为 callback 不是协程。</span></span><br><span class="line">    loop.run_forever()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当 call_soon 和 call_later 同时出现的时候，会先执行 call_soon。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(sleep_times)</span>:</span></span><br><span class="line">    print(<span class="string">"success time &#123;&#125;"</span>.format(sleep_times))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stoploop</span><span class="params">(loop)</span>:</span></span><br><span class="line">    loop.stop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#call_later</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    <span class="comment"># 执行顺序并不是添加顺序，会根据延迟调用时间确定一个先后顺序</span></span><br><span class="line">    loop.call_later(<span class="number">2</span>, callback, <span class="number">2</span>)</span><br><span class="line">    loop.call_later(<span class="number">1</span>, callback, <span class="number">1</span>)</span><br><span class="line">    loop.call_later(<span class="number">3</span>, callback, <span class="number">3</span>)</span><br><span class="line">    loop.call_soon(callback, <span class="number">4</span>)</span><br><span class="line">    <span class="comment"># 这儿不能加入call_soon stoploop 函数，call soon 会立即执行，call_later 就不会再执行了。</span></span><br><span class="line">    <span class="comment"># loop.call_soon(stoploop, loop)</span></span><br><span class="line">    <span class="comment"># 启动，这儿不是使用 run_until_complete，因为 callback 不是协程。</span></span><br><span class="line">    loop.run_forever()</span><br></pre></td></tr></table></figure>
<h3 id="4-4-call-soon-threadsafe"><a href="#4-4-call-soon-threadsafe" class="headerlink" title="4.4 call_soon_threadsafe"></a>4.4 call_soon_threadsafe</h3><blockquote>
<p>这个方法用于解决对互斥资源访问的问题。如果有对互斥资源访问，需要使用这个方法。使用方法和上面的 call_soon 相同。</p>
</blockquote>
<h3 id="5-线程池与-asyncio-结合起来"><a href="#5-线程池与-asyncio-结合起来" class="headerlink" title="5. 线程池与 asyncio 结合起来"></a>5. 线程池与 asyncio 结合起来</h3><blockquote>
<p>asyncio 是异步 IO 的解决方案。异步 IO 包括了多线程、协程、进程。<br>协程里面不能加入阻塞 IO，但是某些库只能提供阻塞 IO 接口，那么这个时候就需要将协程放到线程中。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用多线程：在协程中集成阻塞io</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_url</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="comment"># 通过socket请求html</span></span><br><span class="line">    url = urlparse(url)</span><br><span class="line">    host = url.netloc</span><br><span class="line">    path = url.path</span><br><span class="line">    <span class="keyword">if</span> path == <span class="string">""</span>:</span><br><span class="line">        path = <span class="string">"/"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 建立socket连接</span></span><br><span class="line">    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    <span class="comment"># client.setblocking(False)</span></span><br><span class="line">    client.connect((host, <span class="number">80</span>))  <span class="comment"># 阻塞不会消耗cpu</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 不停的询问连接是否建立好， 需要while循环不停的去检查状态</span></span><br><span class="line">    <span class="comment"># 做计算任务或者再次发起其他的连接请求</span></span><br><span class="line"></span><br><span class="line">    client.send(</span><br><span class="line">        <span class="string">"GET &#123;&#125; HTTP/1.1\r\nHost:&#123;&#125;\r\nConnection:close\r\n\r\n"</span>.format(path, host).encode(<span class="string">"utf8"</span>))</span><br><span class="line"></span><br><span class="line">    data = <span class="string">b""</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        d = client.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> d:</span><br><span class="line">            data += d</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    data = data.decode(<span class="string">"utf8"</span>)</span><br><span class="line">    html_data = data.split(<span class="string">"\r\n\r\n"</span>)[<span class="number">1</span>]</span><br><span class="line">    print(html_data)</span><br><span class="line">    client.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    executor = ThreadPoolExecutor(<span class="number">3</span>)</span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        url = <span class="string">"http://shop.projectsedu.com/goods/&#123;&#125;/"</span>.format(url)</span><br><span class="line">        <span class="comment"># 返回 task</span></span><br><span class="line">        task = loop.run_in_executor(executor, get_url, url)</span><br><span class="line">        tasks.append(task)</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    print(<span class="string">"last time:&#123;&#125;"</span>.format(time.time()-start_time))</span><br></pre></td></tr></table></figure>
<h3 id="5-1-使用-asyncio-模拟-HTTP-请求"><a href="#5-1-使用-asyncio-模拟-HTTP-请求" class="headerlink" title="5.1 使用 asyncio 模拟 HTTP 请求"></a>5.1 使用 asyncio 模拟 HTTP 请求</h3><blockquote>
<p>asyncio 目前为止没有提供 HTTP 协议接口，只提供了 UDP 和 TCP 接口，也许以后会提供。可以使用 aiohttp 完成这个功能。现在，我们使用原生的底层接口实现 HTTP 请求。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># asyncio 没有提供http协议的接口</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 改成使用协程</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_url</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="comment">#通过socket请求html</span></span><br><span class="line">    url = urlparse(url)</span><br><span class="line">    host = url.netloc</span><br><span class="line">    path = url.path</span><br><span class="line">    <span class="keyword">if</span> path == <span class="string">""</span>:</span><br><span class="line">        path = <span class="string">"/"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#建立socket连接</span></span><br><span class="line">    <span class="comment"># open_connection 源码中调用了 yield from loop.create_connection 。这里实现的功能完成了 register 和 unregister</span></span><br><span class="line">    reader, writer = <span class="keyword">await</span> asyncio.open_connection(host,<span class="number">80</span>)</span><br><span class="line">    <span class="comment"># write 方法完成 register 和 unregister</span></span><br><span class="line">    writer.write(<span class="string">"GET &#123;&#125; HTTP/1.1\r\nHost:&#123;&#125;\r\nConnection:close\r\n\r\n"</span>.format(path, host).encode(<span class="string">"utf8"</span>))</span><br><span class="line">    all_lines = []</span><br><span class="line">    <span class="comment"># async for 语法，可以将读数据的方式异步化。</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">for</span> raw_line <span class="keyword">in</span> reader:</span><br><span class="line">        data = raw_line.decode(<span class="string">"utf8"</span>)</span><br><span class="line">        all_lines.append(data)</span><br><span class="line">    html = <span class="string">"\n"</span>.join(all_lines)</span><br><span class="line">    <span class="keyword">return</span> html</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 使用 tasks 放置 future 对象</span></span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        url = <span class="string">"http://shop.projectsedu.com/goods/&#123;&#125;/"</span>.format(url)</span><br><span class="line">        <span class="comment"># 使用 asyncio.ensure_future 包装协程，变成 Future 对象，从而获得协程的结果</span></span><br><span class="line">        tasks.append(asyncio.ensure_future(get_url(url)))</span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> asyncio.as_completed(tasks):</span><br><span class="line">        <span class="comment"># 这儿需要使用 await，因为返回的是一个协程，需要使用 await 关键字修饰</span></span><br><span class="line">        result = <span class="keyword">await</span> task</span><br><span class="line">        print(result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    <span class="comment"># 这儿重新定义了一个函数 main，从而实现 as_completed，即完成一个 task，打印一个 task</span></span><br><span class="line">    <span class="comment"># 在 main 中使用了 asyncio.as_completed，这和线程池中的 as_completed 效果一样</span></span><br><span class="line">    loop.run_until_complete(main())</span><br><span class="line">    print(<span class="string">'last time:&#123;&#125;'</span>.format(time.time()-start_time))</span><br></pre></td></tr></table></figure>
<h3 id="6-asuncio-中的-future-和-task"><a href="#6-asuncio-中的-future-和-task" class="headerlink" title="6. asuncio 中的 future 和 task"></a>6. asuncio 中的 future 和 task</h3><blockquote>
<p>future 是一个结果容器，将运行结果放到 Future 中。task 是协程和 Future 的桥梁。<br>我们之前的章节说过，线程是由操作系统调用的，协程是由程序员自己调用的，在定义一个协程之后， 在驱动这个协程之前，需要调用 next 或者 send(None)，是协程生效。task 的 init 方法中有 self._loop.call_soon(self._step)，在 step 方法中有 result = coro.send(None) 激活协程，通过这行语句解决协程启动的问题。并且，在 step 方法中，如果抛出 StopIteration，会执行 self.set_result(exc.value)。exc.value 表示异常中的值，正如之前章节说的，这个值也是协程中的 return 值。通过这个我们可以看出，task 不管启动了协程，还将最后 StopIteration 中的值做了处理。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_step</span><span class="params">(self, exc=None)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="keyword">not</span> self.done(), \</span><br><span class="line">        <span class="string">'_step(): already done: &#123;!r&#125;, &#123;!r&#125;'</span>.format(self, exc)</span><br><span class="line">    <span class="keyword">if</span> self._must_cancel:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(exc, futures.CancelledError):</span><br><span class="line">            exc = futures.CancelledError()</span><br><span class="line">        self._must_cancel = <span class="literal">False</span></span><br><span class="line">    coro = self._coro</span><br><span class="line">    self._fut_waiter = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    self.__class__._current_tasks[self._loop] = self</span><br><span class="line">    <span class="comment"># Call either coro.throw(exc) or coro.send(None).</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> exc <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># We use the `send` method directly, because coroutines</span></span><br><span class="line">            <span class="comment"># don't have `__iter__` and `__next__` methods.</span></span><br><span class="line">            result = coro.send(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result = coro.throw(exc)</span><br><span class="line">    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> exc:</span><br><span class="line">        <span class="keyword">if</span> self._must_cancel:</span><br><span class="line">            <span class="comment"># Task is cancelled right before coro stops.</span></span><br><span class="line">            self._must_cancel = <span class="literal">False</span></span><br><span class="line">            self.set_exception(futures.CancelledError())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.set_result(exc.value)</span><br><span class="line">    <span class="keyword">except</span> futures.CancelledError:</span><br><span class="line">        super().cancel()  <span class="comment"># I.e., Future.cancel(self).</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">        self.set_exception(exc)</span><br><span class="line">    <span class="keyword">except</span> BaseException <span class="keyword">as</span> exc:</span><br><span class="line">        self.set_exception(exc)</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        blocking = getattr(result, <span class="string">'_asyncio_future_blocking'</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> blocking <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># Yielded Future must come from Future.__iter__().</span></span><br><span class="line">            <span class="keyword">if</span> result._loop <span class="keyword">is</span> <span class="keyword">not</span> self._loop:</span><br><span class="line">                self._loop.call_soon(</span><br><span class="line">                    self._step,</span><br><span class="line">                    RuntimeError(</span><br><span class="line">                        <span class="string">'Task &#123;!r&#125; got Future &#123;!r&#125; attached to a '</span></span><br><span class="line">                        <span class="string">'different loop'</span>.format(self, result)))</span><br><span class="line">            <span class="keyword">elif</span> blocking:</span><br><span class="line">                <span class="keyword">if</span> result <span class="keyword">is</span> self:</span><br><span class="line">                    self._loop.call_soon(</span><br><span class="line">                        self._step,</span><br><span class="line">                        RuntimeError(</span><br><span class="line">                            <span class="string">'Task cannot await on itself: &#123;!r&#125;'</span>.format(</span><br><span class="line">                                self)))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    result._asyncio_future_blocking = <span class="literal">False</span></span><br><span class="line">                    result.add_done_callback(self._wakeup)</span><br><span class="line">                    self._fut_waiter = result</span><br><span class="line">                    <span class="keyword">if</span> self._must_cancel:</span><br><span class="line">                        <span class="keyword">if</span> self._fut_waiter.cancel():</span><br><span class="line">                            self._must_cancel = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self._loop.call_soon(</span><br><span class="line">                    self._step,</span><br><span class="line">                    RuntimeError(</span><br><span class="line">                        <span class="string">'yield was used instead of yield from '</span></span><br><span class="line">                        <span class="string">'in task &#123;!r&#125; with &#123;!r&#125;'</span>.format(self, result)))</span><br><span class="line">        <span class="keyword">elif</span> result <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># Bare yield relinquishes control for one event loop iteration.</span></span><br><span class="line">            self._loop.call_soon(self._step)</span><br><span class="line">        <span class="keyword">elif</span> inspect.isgenerator(result):</span><br><span class="line">            <span class="comment"># Yielding a generator is just wrong.</span></span><br><span class="line">            self._loop.call_soon(</span><br><span class="line">                self._step,</span><br><span class="line">                RuntimeError(</span><br><span class="line">                    <span class="string">'yield was used instead of yield from for '</span></span><br><span class="line">                    <span class="string">'generator in task &#123;!r&#125; with &#123;&#125;'</span>.format(</span><br><span class="line">                        self, result)))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># Yielding something else is an error.</span></span><br><span class="line">            self._loop.call_soon(</span><br><span class="line">                self._step,</span><br><span class="line">                RuntimeError(</span><br><span class="line">                    <span class="string">'Task got bad yield: &#123;!r&#125;'</span>.format(result)))</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        self.__class__._current_tasks.pop(self._loop)</span><br><span class="line">        self = <span class="literal">None</span>  <span class="comment"># Needed to break cycles when an exception occurs.</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>从系统设计的角度看，asyncio 模块尽量保持与线程池中的接口一致，为了达到这个目的，就设计了 task，用于解决线程和协程之间不一样的地方。</p>
</blockquote>
<h3 id="7-asyncio-同步和通信"><a href="#7-asyncio-同步和通信" class="headerlink" title="7. asyncio 同步和通信"></a>7. asyncio 同步和通信</h3><blockquote>
<p>asyncio 实际上是基于单线程做的，而且，asyncio 是不需要锁的。那我们为什么还会谈到 asyncio 的同步呢？<br>首先，我们来看一下，使用 asyncio 做单线程是不需要锁的。<br>下面的例子，不管执行多少次都是0，说明：凡是不涉及到 IO，或者不涉及到 await，都会执行完了，再执行另一段代码，这是为什么结果始终为 0 的本质。例子中，add 中的 for i in range(1000000) 运行完了，才会运行 desc 中的 for 循环。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 1. dosomething1</span></span><br><span class="line">    <span class="comment"># 2. io操作</span></span><br><span class="line">    <span class="comment"># 1. dosomething3</span></span><br><span class="line">    <span class="keyword">global</span> total</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        total += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">desc</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> total</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        total -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> asyncio</span><br><span class="line">    tasks = [add(), desc()]</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    print(total)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的例子已经说明了不需要设置锁。但是，在某种情况下，还是需要设置锁的，具体看下面的例子：<br>在 parse_stuff 和 use_stuff 中都会调用 get_stuff。有可能出现：缓存中没有某个 URL，两个协程 parse_stuff 和 use_stuff 运行的时候，可能都会发起 get_stuff 中的 await aiohttp.request。这个时候，就会发起两次请求，并且，这两个请求都是非常耗时的。并且，某些网站后台会进行反爬虫处理。如果有锁的话，就可以避免重复请求的情况。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> asyncio <span class="keyword">import</span> Lock, Queue</span><br><span class="line"></span><br><span class="line">lock = Lock()</span><br><span class="line">cache = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 URL 的返回值</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_stuff</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> url <span class="keyword">in</span> cache:</span><br><span class="line">        <span class="keyword">return</span> cache[url]</span><br><span class="line">    stuff = <span class="keyword">await</span> aiohttp.request(<span class="string">'GET'</span>,url)</span><br><span class="line">    cache[url] = stuff</span><br><span class="line">    <span class="keyword">return</span> stuff</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">parse_stuff</span><span class="params">()</span>:</span></span><br><span class="line">    stuff = <span class="keyword">await</span> get_stuff()</span><br><span class="line">    <span class="comment"># do some parsing</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">use_stuff</span><span class="params">()</span>:</span></span><br><span class="line">    stuff = <span class="keyword">await</span> get_stuff()</span><br><span class="line">    <span class="comment"># use stuff to do something interesting</span></span><br><span class="line"></span><br><span class="line">tasks = [parse_stuff(), use_stuff()]</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用锁之后，代码如下：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="comment"># 这里使用的是 asyncio 中的 Lock</span></span><br><span class="line"><span class="comment"># 这个 Lock 调用系统的锁，是程序员级别的锁，因为协程本身不涉及，正如我们之前说过的，协程是一个单线程。</span></span><br><span class="line"><span class="comment"># 通过自己定义的 self._locked 完成互斥执行一段代码</span></span><br><span class="line"><span class="comment"># 我们之前说过调用 acquire 这些方法的时候，一定不能是阻塞的。在 Lock 的 acquire 方法中，首先创建了 Future，然后 yield from fut</span></span><br><span class="line"><span class="keyword">from</span> asyncio <span class="keyword">import</span> Lock, Queue</span><br><span class="line"></span><br><span class="line">lock = Lock()</span><br><span class="line">cache = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 URL 的返回值</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_stuff</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="comment"># 第一个知识点：</span></span><br><span class="line">    <span class="comment"># 不使用 with 语句的时候，可以使用 await lock.acquire() 和 lock.release()。</span></span><br><span class="line">    <span class="comment"># 除了使用 with，还可以使用 async with 方式。</span></span><br><span class="line">    <span class="comment"># with await lock:</span></span><br><span class="line">    <span class="comment"># 说到 Lock，Condition 的 asyncio 的用法也是一样的，用途和之前也是一样。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第二个知识点：</span></span><br><span class="line">    <span class="comment"># async with 调用的不是 __enter__ 和 __exit__，而是 __await__ 和 __aenter__。</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> lock:</span><br><span class="line">        <span class="keyword">if</span> url <span class="keyword">in</span> cache:</span><br><span class="line">            <span class="keyword">return</span> cache[url]</span><br><span class="line">        stuff = <span class="keyword">await</span> aiohttp.request(<span class="string">'GET'</span>,url)</span><br><span class="line">        cache[url] = stuff</span><br><span class="line">        <span class="keyword">return</span> stuff</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">parse_stuff</span><span class="params">()</span>:</span></span><br><span class="line">    stuff = <span class="keyword">await</span> get_stuff()</span><br><span class="line">    <span class="comment"># do some parsing</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">use_stuff</span><span class="params">()</span>:</span></span><br><span class="line">    stuff = <span class="keyword">await</span> get_stuff()</span><br><span class="line">    <span class="comment"># use stuff to do something interesting</span></span><br><span class="line"></span><br><span class="line">tasks = [parse_stuff(), use_stuff()]</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure>
<h3 id="7-1-asyncio-模块中的-Lock-源码分析"><a href="#7-1-asyncio-模块中的-Lock-源码分析" class="headerlink" title="7.1 asyncio 模块中的 Lock 源码分析"></a>7.1 asyncio 模块中的 Lock 源码分析</h3><blockquote>
<p>这个 Lock 调用系统的锁，是程序员级别的锁，因为协程本身不涉及，正如我们之前说过的，协程是一个单线程。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># asyncio 模块中的 Lock 通过自己定义的 self._locked 完成互斥执行一段代码</span></span><br><span class="line"><span class="comment"># 我们之前说过调用 acquire 这些方法的时候，一定不能是阻塞的。</span></span><br><span class="line"><span class="comment"># 在 Lock 的 acquire 方法中，首先创建了 Future，然后将 future 对象放到一个双端队列中，然后执行 yield from fut，之后这个协程会暂停。不理解暂停的需要补充 yield from 的知识。</span></span><br><span class="line"><span class="comment"># 那么问题来了，暂停之后，谁来完成任务的驱动呢？答案是在 release 中。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">acquire</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Acquire a lock.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This method blocks until the lock is unlocked, then sets it to</span></span><br><span class="line"><span class="string">    locked and returns True.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self._locked <span class="keyword">and</span> all(w.cancelled() <span class="keyword">for</span> w <span class="keyword">in</span> self._waiters):</span><br><span class="line">        self._locked = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    fut = self._loop.create_future()</span><br><span class="line">    self._waiters.append(fut)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> fut</span><br><span class="line">        self._locked = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> futures.CancelledError:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._locked:</span><br><span class="line">            self._wake_up_first()</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        self._waiters.remove(fut)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行 acquire 之后，另一个协程在执行 release 方法的时候，会执行 _wake_up_first()。</span></span><br><span class="line"><span class="comment"># 在 _wake_up_first() 会从队列中取出一个 future，也就是从 self._waiters 中取出一个 future，判断这个 future 有没有 done，没有 done 的话，就会直接 set_result。我们之前说过 set_result 会驱动向下执行。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">release</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Release a lock.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    When the lock is locked, reset it to unlocked, and return.</span></span><br><span class="line"><span class="string">    If any other coroutines are blocked waiting for the lock to become</span></span><br><span class="line"><span class="string">    unlocked, allow exactly one of them to proceed.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    When invoked on an unlocked lock, a RuntimeError is raised.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    There is no return value.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> self._locked:</span><br><span class="line">        self._locked = <span class="literal">False</span></span><br><span class="line">        self._wake_up_first()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">'Lock is not acquired.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_wake_up_first</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Wake up the first waiter who isn't cancelled."""</span></span><br><span class="line">    <span class="keyword">for</span> fut <span class="keyword">in</span> self._waiters:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> fut.done():</span><br><span class="line">            fut.set_result(<span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<h3 id="7-2-asyncio-中的-Queue"><a href="#7-2-asyncio-中的-Queue" class="headerlink" title="7.2 asyncio 中的 Queue"></a>7.2 asyncio 中的 Queue</h3><blockquote>
<p>这个 Queue 和多线程中的 Queue 接口一样，<strong>使用 get 和 put 函数的时候，需要在前面加 await</strong>。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, item)</span>:</span></span><br><span class="line">    <span class="string">"""Put an item into the queue.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Put an item into the queue. If the queue is full, wait until a free</span></span><br><span class="line"><span class="string">    slot is available before adding item.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This method is a coroutine.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 判断消息队列是否已满</span></span><br><span class="line">    <span class="comment"># 如果已满，则进入循环</span></span><br><span class="line">    <span class="keyword">while</span> self.full():</span><br><span class="line">        putter = self._loop.create_future()</span><br><span class="line">        <span class="comment"># 将 future 放到队列中</span></span><br><span class="line">        self._putters.append(putter)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 队列已满，执行 yield from</span></span><br><span class="line">            <span class="comment"># 那么暂停了，谁来驱动后面的代码？答案是：有数据取了不为空的 future，看 get 函数。</span></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> putter</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            putter.cancel()  <span class="comment"># Just in case putter is not done yet.</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.full() <span class="keyword">and</span> <span class="keyword">not</span> putter.cancelled():</span><br><span class="line">                <span class="comment"># We were woken up by get_nowait(), but can't take</span></span><br><span class="line">                <span class="comment"># the call.  Wake up the next in line.</span></span><br><span class="line">                self._wakeup_next(self._putters)</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">return</span> self.put_nowait(item)</span><br><span class="line"></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Remove and return an item from the queue.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If queue is empty, wait until an item is available.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This method is a coroutine.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">while</span> self.empty():</span><br><span class="line">        getter = self._loop.create_future()</span><br><span class="line">        self._getters.append(getter)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> getter</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            getter.cancel()  <span class="comment"># Just in case getter is not done yet.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self._getters.remove(getter)</span><br><span class="line">            <span class="keyword">except</span> ValueError:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.empty() <span class="keyword">and</span> <span class="keyword">not</span> getter.cancelled():</span><br><span class="line">                <span class="comment"># We were woken up by put_nowait(), but can't take</span></span><br><span class="line">                <span class="comment"># the call.  Wake up the next in line.</span></span><br><span class="line">                self._wakeup_next(self._getters)</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">    <span class="comment"># 调用 get_nowait</span></span><br><span class="line">    <span class="keyword">return</span> self.get_nowait()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_nowait</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Remove and return an item from the queue.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Return an item if one is immediately available, else raise QueueEmpty.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> self.empty():</span><br><span class="line">        <span class="keyword">raise</span> QueueEmpty</span><br><span class="line">    item = self._get()</span><br><span class="line">    <span class="comment"># 这里的 _wakeup_next 和 Lock 中的类似</span></span><br><span class="line">    <span class="comment"># _putters 是一个队列</span></span><br><span class="line">    self._wakeup_next(self._putters)</span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里的 waiters 就是 _putters，里面放的是 future 对象</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_wakeup_next</span><span class="params">(self, waiters)</span>:</span></span><br><span class="line">    <span class="comment"># Wake up the next waiter (if any) that isn't cancelled.</span></span><br><span class="line">    <span class="keyword">while</span> waiters:</span><br><span class="line">        waiter = waiters.popleft()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> waiter.done():</span><br><span class="line">            <span class="comment"># set_result 会驱动协程的运行，也就是 waiter，而 waiter 就是 putters，putters 也就是前面 def put(self, item) 中的 putter，也就驱动 yield from putter，之后代码会跑到 return self.put_nowait(item)。在 put_nowait 中，将 item 放到 _put 中，之后再驱动 self._wakeup_next(self._getters)。</span></span><br><span class="line">            waiter.set_result(<span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们自己生成一个全局变量 queue 也能达到消息通信的目的，因为协程是一个单线程。但是 asyncio 中的 Queue 实现了 maxsize，当我们想限制流量的时候，这个时候就发挥了作用。如果不需要限流的功能，可以不需要使用 asyncio 中的 Queue。</p>
</blockquote>
<h3 id="aiohttp-简单使用"><a href="#aiohttp-简单使用" class="headerlink" title="aiohttp 简单使用"></a>aiohttp 简单使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(session, url)</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> response.text()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        html = <span class="keyword">await</span> fetch(session, <span class="string">'http://httpbin.org/headers'</span>)</span><br><span class="line">        print(html)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(main())</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># server example</span></span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(request)</span>:</span></span><br><span class="line">    name = request.match_info.get(<span class="string">'name'</span>, <span class="string">"Anonymous"</span>)</span><br><span class="line">    text = <span class="string">"Hello, "</span> + name</span><br><span class="line">    <span class="keyword">return</span> web.Response(text=text)</span><br><span class="line"></span><br><span class="line">app = web.Application()</span><br><span class="line">app.add_routes([web.get(<span class="string">'/'</span>, handle),</span><br><span class="line">                web.get(<span class="string">'/&#123;name&#125;'</span>, handle)])</span><br><span class="line"></span><br><span class="line">web.run_app(app)</span><br></pre></td></tr></table></figure>
<h3 id="8-使用-aiohttp-实现高并发爬虫"><a href="#8-使用-aiohttp-实现高并发爬虫" class="headerlink" title="8. 使用 aiohttp 实现高并发爬虫"></a>8. 使用 aiohttp 实现高并发爬虫</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># asyncio爬虫.去重.入库</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> aiomysql</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery</span><br><span class="line"></span><br><span class="line">start_url = <span class="string">"http://www.jobbole.com/"</span></span><br><span class="line"><span class="comment"># 可是使用 list 做通信，也可以使用 asyncio 中的 Queue 做通信都可以</span></span><br><span class="line">waitting_urls = []</span><br><span class="line"><span class="comment"># 这里使用的 set 做去重。真实的场景不可能使用 set 做去重过滤器的，比如上亿条数据，需要使用布隆过滤器</span></span><br><span class="line">seen_urls = set()</span><br><span class="line">stopping = <span class="literal">False</span></span><br><span class="line"><span class="comment">#限制并发数量</span></span><br><span class="line">sem = asyncio.Semaphore(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(url, session)</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> sem:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> resp:</span><br><span class="line">                print(<span class="string">"url status: &#123;&#125;"</span>.format(resp.status))</span><br><span class="line">                <span class="keyword">if</span> resp.status <span class="keyword">in</span> [<span class="number">200</span>,<span class="number">201</span>]:</span><br><span class="line">                    data = <span class="keyword">await</span> resp.text()</span><br><span class="line">                    <span class="keyword">return</span> data</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_urls</span><span class="params">(html)</span>:</span></span><br><span class="line">    urls = []</span><br><span class="line">    pq = PyQuery(html)</span><br><span class="line">    <span class="keyword">for</span> link <span class="keyword">in</span> pq.items(<span class="string">"a"</span>):</span><br><span class="line">        url = link.attr(<span class="string">"href"</span>)</span><br><span class="line">        <span class="keyword">if</span> url <span class="keyword">and</span> url.startswith(<span class="string">"http"</span>) <span class="keyword">and</span> url <span class="keyword">not</span> <span class="keyword">in</span> seen_urls:</span><br><span class="line">            urls.append(url)</span><br><span class="line">            waitting_urls.append(url)</span><br><span class="line">    <span class="keyword">return</span> urls</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">init_urls</span><span class="params">(url, session)</span>:</span></span><br><span class="line">    html = <span class="keyword">await</span> fetch(url, session)</span><br><span class="line">    seen_urls.add(url)</span><br><span class="line">    extract_urls(html)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">article_handler</span><span class="params">(url, session, pool)</span>:</span></span><br><span class="line">    <span class="comment"># 获取文章详情并解析入库</span></span><br><span class="line">    html = <span class="keyword">await</span> fetch(url, session)</span><br><span class="line">    seen_urls.add(url)</span><br><span class="line">    extract_urls(html)</span><br><span class="line">    pq = PyQuery(html)</span><br><span class="line">    title = pq(<span class="string">"title"</span>).text()</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> pool.acquire() <span class="keyword">as</span> conn:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cur:</span><br><span class="line">            <span class="keyword">await</span> cur.execute(<span class="string">"SELECT 42;"</span>)</span><br><span class="line">            insert_sql = <span class="string">"insert into article_test(title) values('&#123;&#125;')"</span>.format(title)</span><br><span class="line">            <span class="keyword">await</span> cur.execute(insert_sql)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(pool)</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> stopping:</span><br><span class="line">            <span class="keyword">if</span> len(waitting_urls) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">await</span> asyncio.sleep(<span class="number">0.5</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            url = waitting_urls.pop()</span><br><span class="line">            print(<span class="string">"start get url: &#123;&#125;"</span>.format(url))</span><br><span class="line">            <span class="keyword">if</span> re.match(<span class="string">"http://.*?jobbole.com/\d+/"</span>, url):</span><br><span class="line">                <span class="keyword">if</span> url <span class="keyword">not</span> <span class="keyword">in</span> seen_urls:</span><br><span class="line">                    asyncio.ensure_future(article_handler(url, session, pool))</span><br><span class="line">                    <span class="keyword">await</span> asyncio.sleep(<span class="number">30</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> url <span class="keyword">not</span> <span class="keyword">in</span> seen_urls:</span><br><span class="line">                    asyncio.ensure_future(init_urls(url, session))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(loop)</span>:</span></span><br><span class="line">    <span class="comment">#等待连接mysql</span></span><br><span class="line">    <span class="comment"># charset='utf8' 如果不设置，在插入中文的时候，不会报错，但是库中没有数据</span></span><br><span class="line">    <span class="comment"># autocommit=True 需要设置，否则库中没有数据</span></span><br><span class="line">    pool = <span class="keyword">await</span> aiomysql.create_pool(host=<span class="string">"127.0.0.1"</span>, port=<span class="number">3306</span>,</span><br><span class="line">                                      user=<span class="string">'root'</span>,password=<span class="string">'jinhua2018'</span>,</span><br><span class="line">                                      db=<span class="string">'mysql'</span>,loop=loop,</span><br><span class="line">                                      charset=<span class="string">'utf8'</span>,autocommit=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        html = <span class="keyword">await</span> fetch(start_url, session)</span><br><span class="line">        seen_urls.add(start_url)</span><br><span class="line">        extract_urls(html)</span><br><span class="line">    asyncio.ensure_future(consumer(pool))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    asyncio.ensure_future(main(loop))</span><br><span class="line">    loop.run_forever()</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/python/" rel="tag"># python</a>
              <a href="/tags/asyncio/" rel="tag"># asyncio</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/07/05/python-%E5%8D%8F%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5/" rel="prev" title="python -- 协程和异步">
      <i class="fa fa-chevron-left"></i> python -- 协程和异步
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/07/15/kafka-%E7%BA%BF%E4%B8%8A%E9%83%A8%E7%BD%B2/" rel="next" title="Kafka -- 线上部署">
      Kafka -- 线上部署 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-asyncio-简介"><span class="nav-number">1.</span> <span class="nav-text">1. asyncio 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-协程与-asyncio"><span class="nav-number">2.</span> <span class="nav-text">1.1 协程与 asyncio</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-asyncio-的使用"><span class="nav-number">3.</span> <span class="nav-text">2 asyncio 的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-获取-asyncio-的返回值"><span class="nav-number">4.</span> <span class="nav-text">2.2 获取 asyncio 的返回值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-call-back"><span class="nav-number">5.</span> <span class="nav-text">2.3 call back</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-wait-和-gather"><span class="nav-number">6.</span> <span class="nav-text">2.4 wait 和 gather</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-1-wait"><span class="nav-number">7.</span> <span class="nav-text">2.4.1 wait</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-2-gather"><span class="nav-number">8.</span> <span class="nav-text">2.4.2 gather</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-3-wait-与-gather-中的区别"><span class="nav-number">9.</span> <span class="nav-text">2.4.3 wait 与 gather 中的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-run-until-complete-实现的原理"><span class="nav-number">10.</span> <span class="nav-text">2.5 run_until_complete 实现的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-取消任务"><span class="nav-number">11.</span> <span class="nav-text">2.6 取消任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-协程中嵌套协程，子协程"><span class="nav-number">12.</span> <span class="nav-text">3 协程中嵌套协程，子协程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-asyncio-中的几个函数"><span class="nav-number">13.</span> <span class="nav-text">4. asyncio 中的几个函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-call-soon"><span class="nav-number">14.</span> <span class="nav-text">4.1 call soon</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-call-later"><span class="nav-number"></span> <span class="nav-text">4.2 call later</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-call-soon-threadsafe"><span class="nav-number">1.</span> <span class="nav-text">4.4 call_soon_threadsafe</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-线程池与-asyncio-结合起来"><span class="nav-number">2.</span> <span class="nav-text">5. 线程池与 asyncio 结合起来</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-使用-asyncio-模拟-HTTP-请求"><span class="nav-number">3.</span> <span class="nav-text">5.1 使用 asyncio 模拟 HTTP 请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-asuncio-中的-future-和-task"><span class="nav-number">4.</span> <span class="nav-text">6. asuncio 中的 future 和 task</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-asyncio-同步和通信"><span class="nav-number">5.</span> <span class="nav-text">7. asyncio 同步和通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-asyncio-模块中的-Lock-源码分析"><span class="nav-number">6.</span> <span class="nav-text">7.1 asyncio 模块中的 Lock 源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-asyncio-中的-Queue"><span class="nav-number">7.</span> <span class="nav-text">7.2 asyncio 中的 Queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#aiohttp-简单使用"><span class="nav-number">8.</span> <span class="nav-text">aiohttp 简单使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-使用-aiohttp-实现高并发爬虫"><span class="nav-number">9.</span> <span class="nav-text">8. 使用 aiohttp 实现高并发爬虫</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Action"
      src="/images/cat.jpg">
  <p class="site-author-name" itemprop="name">Action</p>
  <div class="site-description" itemprop="description">热爱你所坚持的，坚持你所热爱的</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">74</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">84</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Action8686" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Action8686" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:748173631@qq.com" title="E-Mail → mailto:748173631@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">null </a>
  </div>

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Action</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">265k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">4:01</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

  

    </div>
</body>
</html>
