<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yijunworld.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="GIL GIL 全称：global interpreter lock 这是一个基于 C 语言的模块。python中一个线程对应于c语言中的一个线程。GIL 使得同一个时刻只有一个线程在一个cpu上执行字节码, 无法将多个线程映射到多个cpu上执行  1234567# 使用 dis 模块打印函数的字节码# import dis# def add(a):#     a &#x3D; a+1#     retur">
<meta property="og:type" content="article">
<meta property="og:title" content="python -- 多线程 多进程 线程池编程">
<meta property="og:url" content="http://yijunworld.com/2019/05/09/python-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Action">
<meta property="og:description" content="GIL GIL 全称：global interpreter lock 这是一个基于 C 语言的模块。python中一个线程对应于c语言中的一个线程。GIL 使得同一个时刻只有一个线程在一个cpu上执行字节码, 无法将多个线程映射到多个cpu上执行  1234567# 使用 dis 模块打印函数的字节码# import dis# def add(a):#     a &#x3D; a+1#     retur">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-05-08T17:48:40.000Z">
<meta property="article:modified_time" content="2020-06-08T05:53:30.789Z">
<meta property="article:author" content="Action">
<meta property="article:tag" content="python">
<meta property="article:tag" content="多线程">
<meta property="article:tag" content="多进程">
<meta property="article:tag" content="线程池">
<meta property="article:tag" content="进程池">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yijunworld.com/2019/05/09/python-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BC%96%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>python -- 多线程 多进程 线程池编程 | Action</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Action" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Action</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">锤子</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">94</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">58</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">82</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/zmjaction" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yijunworld.com/2019/05/09/python-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat.jpg">
      <meta itemprop="name" content="Action">
      <meta itemprop="description" content="热爱你所坚持的，坚持你所热爱的">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Action">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          python -- 多线程 多进程 线程池编程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-09 01:48:40" itemprop="dateCreated datePublished" datetime="2019-05-09T01:48:40+08:00">2019-05-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>21k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>19 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="GIL"><a href="#GIL" class="headerlink" title="GIL"></a>GIL</h3><blockquote>
<p>GIL 全称：global interpreter lock 这是一个基于 C 语言的模块。python中一个线程对应于c语言中的一个线程。GIL 使得同一个时刻只有一个线程在一个cpu上执行字节码, 无法将多个线程映射到多个cpu上执行</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 dis 模块打印函数的字节码</span></span><br><span class="line"><span class="comment"># import dis</span></span><br><span class="line"><span class="comment"># def add(a):</span></span><br><span class="line"><span class="comment">#     a = a+1</span></span><br><span class="line"><span class="comment">#     return a</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># print(dis.dis(add))</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>GIL 并不是在函数执行过程中，一直占有，直到执行完，而是会根据执行的字节码行数以及时间片释放gil。除此之外，gil在遇到io的操作时候主动释放。下面的代码演示了 total 每次运行后的结果都不一样，这说明了 GIL 并不是一直占有的，而是根据时间片和字节码释放 GIL。</p>
</blockquote>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 1. dosomething1</span></span><br><span class="line">    <span class="comment"># 2. io操作</span></span><br><span class="line">    <span class="comment"># 1. dosomething3</span></span><br><span class="line">    <span class="keyword">global</span> total</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        total += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">desc</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> total</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        total -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thread1 = threading.Thread(target=add)</span><br><span class="line">thread2 = threading.Thread(target=desc)</span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line"></span><br><span class="line">thread1.join()</span><br><span class="line">thread2.join()</span><br><span class="line">print(total)</span><br></pre></td></tr></table></figure>
<h3 id="2-多线程编程"><a href="#2-多线程编程" class="headerlink" title="2. 多线程编程"></a>2. 多线程编程</h3><blockquote>
<p>对于io操作来说，多线程和多进程性能差别不大。</p>
</blockquote>
<h3 id="2-1-通过Thread类实例化"><a href="#2-1-通过Thread类实例化" class="headerlink" title="2.1 通过Thread类实例化"></a>2.1 通过Thread类实例化</h3><blockquote>
<p>比较简单的任务或者动态创建线程或者线程池时，可能会使用这种方式。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail_html</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">"get detail html started"</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"get detail html end"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail_url</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">"get detail url started"</span>)</span><br><span class="line">    time.sleep(<span class="number">4</span>)</span><br><span class="line">    print(<span class="string">"get detail url end"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 方式一：通过Thread类实例化</span></span><br><span class="line">    <span class="comment"># 注意这里面传入的是函数名，而不是函数的调用</span></span><br><span class="line">    thread1 = threading.Thread(target=get_detail_html, args=(<span class="string">''</span>,))</span><br><span class="line">    thread2 = threading.Thread(target=get_detail_url, args=(<span class="string">''</span>,))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># setDaemon(True) 表示设置这个线程为守护线程，即当主线程退出的时候，直接结束子线程，不管子线程是否执行完。</span></span><br><span class="line">    <span class="comment"># thread1.setDaemon(True)</span></span><br><span class="line">    <span class="comment"># thread2.setDaemon(True)</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># join() 表示主线程会等待子线程执行完后才会向下执行。</span></span><br><span class="line">    <span class="comment"># 下面两行设置后，主线程会等待 thread1 和 thread2都执行完，才执行后面的 print 语句。</span></span><br><span class="line">    <span class="comment"># 并且，主线程等待的时间是 max(time_thread1, time_thread2), 而不是等待 time_thread1 + time_thread2 时间</span></span><br><span class="line">    <span class="comment"># 解除 join 方法：调用 task_done()。调用 task_done() 之后，主线程不再等待子线程。</span></span><br><span class="line">    thread1.join()</span><br><span class="line">    thread2.join()</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 需求:当主线程退出的时候， 子线程kill掉 setDaemon可以满足</span></span><br><span class="line">   <span class="comment"># 需求:线程会等待子线程执行完后才会向下执行 join()可以满足</span></span><br><span class="line">    print(<span class="string">"last time: &#123;&#125;"</span>.format(time.time()-start_time))</span><br></pre></td></tr></table></figure>
<h3 id="2-2-通过继承Thread来实现多线程"><a href="#2-2-通过继承Thread来实现多线程" class="headerlink" title="2.2 通过继承Thread来实现多线程"></a>2.2 通过继承Thread来实现多线程</h3><blockquote>
<p>大部分情况，都是使用这种方式。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetDetailHtml</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="comment"># 这是一个好习惯，在进行多线程编程时，首先调用父类的初始化方法</span></span><br><span class="line">        super().__init__(name=name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"get detail html started"</span>)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        print(<span class="string">"get detail html end"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetDetailUrl</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        super().__init__(name=name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"get detail url started"</span>)</span><br><span class="line">        time.sleep(<span class="number">4</span>)</span><br><span class="line">        print(<span class="string">"get detail url end"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 方式二：通过集成Thread来实现多线程</span></span><br><span class="line">    thread1 = GetDetailHtml(<span class="string">"get_detail_html"</span>)</span><br><span class="line">    thread2 = GetDetailUrl(<span class="string">"get_detail_url"</span>)</span><br><span class="line">    <span class="comment"># setDaemon(True) 表示设置这个线程为守护线程，即当主线程退出的时候，直接结束子线程，不管子线程是否执行完。</span></span><br><span class="line">    <span class="comment"># thread1.setDaemon(True)</span></span><br><span class="line">    <span class="comment"># thread2.setDaemon(True)</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># join() 表示主线程会等待子线程执行完后才会向下执行。</span></span><br><span class="line">    <span class="comment"># 下面两行设置后，主线程会等待 thread1 和 thread2都执行完，才执行后面的 print 语句。</span></span><br><span class="line">    <span class="comment"># 并且，主线程等待的时间是 max(time_thread1, time_thread2), 而不是等待 time_thread1 + time_thread2 时间</span></span><br><span class="line">    <span class="comment"># 解除 join 方法：调用 task_done()。调用 task_done() 之后，主线程不再等待子线程。</span></span><br><span class="line">    thread1.join()</span><br><span class="line">    thread2.join()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当主线程退出的时候， 子线程kill掉</span></span><br><span class="line">    print(<span class="string">"last time: &#123;&#125;"</span>.format(time.time()-start_time))</span><br></pre></td></tr></table></figure>
<h3 id="3-线程间通信"><a href="#3-线程间通信" class="headerlink" title="3. 线程间通信"></a>3. 线程间通信</h3><blockquote>
<p>本篇中，本小节之后的所有部分都需要扎实的操作系统知识。Prerequisite：<a href="https://blog.csdn.net/kisslotus/article/details/84503886" target="_blank" rel="noopener">https://blog.csdn.net/kisslotus/article/details/84503886</a></p>
</blockquote>
<h3 id="3-1-通过共享变量的方式"><a href="#3-1-通过共享变量的方式" class="headerlink" title="3.1 通过共享变量的方式"></a>3.1 通过共享变量的方式</h3><blockquote>
<p>通过 global 关键字，多个线程对一个变量共同读的方式。这种方式是适合“共同读”的情况。如果需要进程间进行同步，需要加锁，但这种方式对编程者的技术要求比较高。<br>如果共享变量很多时，可以把变量单独放到一个文件中，便于管理。<br>这里有一个坑需要注意，在从其他文件中引用变量时，使用 from chapter11 import variables</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 线程间通信</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="comment"># 下面这一行代码，不要这样使用：from chapter11.variables import detail_url_list</span></span><br><span class="line"><span class="comment"># 这种做法的坏处就是：当另一个线程修改了 detail_url_list 这个变量，我们看不到了。</span></span><br><span class="line"><span class="comment"># 但是，下面这一行的这种使用方法，在 detail_url_list = variables.detail_url_list 这一行中，</span></span><br><span class="line"><span class="comment"># 如果其他线程修改了 detail_url_list，我们就能通过 detail_url_list 看得到。</span></span><br><span class="line"><span class="keyword">from</span> chapter11 <span class="keyword">import</span> variables</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Condition</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 生产者当生产10个url以后就就等待，保证detail_url_list中最多只有十个url</span></span><br><span class="line"><span class="comment"># 2. 当url_list为空的时候，消费者就暂停</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail_html</span><span class="params">(lock)</span>:</span></span><br><span class="line">    <span class="comment"># 爬取文章详情页</span></span><br><span class="line">    <span class="comment"># 互斥变量</span></span><br><span class="line">    detail_url_list = variables.detail_url_list</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(variables.detail_url_list):</span><br><span class="line">            lock.acquire()</span><br><span class="line">            <span class="keyword">if</span> len(detail_url_list):</span><br><span class="line">                <span class="comment"># 每次弹出从 list 中弹出一个元素</span></span><br><span class="line">                url = detail_url_list.pop()</span><br><span class="line">                lock.release()</span><br><span class="line">                <span class="comment"># for url in detail_url_list:</span></span><br><span class="line">                print(<span class="string">"get detail html started"</span>)</span><br><span class="line">                time.sleep(<span class="number">2</span>)</span><br><span class="line">                print(<span class="string">"get detail html end"</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lock.release()</span><br><span class="line">                time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail_url</span><span class="params">(lock)</span>:</span></span><br><span class="line">    <span class="comment"># 爬取文章列表页</span></span><br><span class="line">    <span class="comment"># 互斥变量</span></span><br><span class="line">    detail_url_list = variables.detail_url_list</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">"get detail url started"</span>)</span><br><span class="line">        time.sleep(<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">            lock.acquire()</span><br><span class="line">            <span class="keyword">if</span> len(detail_url_list) &gt;= <span class="number">10</span>:</span><br><span class="line">                lock.release()</span><br><span class="line">                time.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                detail_url_list.append(</span><br><span class="line">                    <span class="string">"http://projectsedu.com/&#123;id&#125;"</span>.format(id=i))</span><br><span class="line">                lock.release()</span><br><span class="line">        print(<span class="string">"get detail url end"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 线程通信方式- 共享变量</span></span><br><span class="line"><span class="comment"># 一般不建议使用共享变量的方式进行线程通信，除非对锁有比较扎实的了解</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    lock = RLock()</span><br><span class="line">    thread_detail_url = threading.Thread(target=get_detail_url, args=(lock,))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        html_thread = threading.Thread(target=get_detail_html, args=(lock,))</span><br><span class="line">        html_thread.start()</span><br><span class="line">    <span class="comment"># # thread2 = GetDetailUrl("get_detail_url")</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    <span class="comment"># thread_detail_url.start()</span></span><br><span class="line">    <span class="comment"># thread_detail_url1.start()</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># thread1.join()</span></span><br><span class="line">    <span class="comment"># thread2.join()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当主线程退出的时候， 子线程kill掉</span></span><br><span class="line">    print(<span class="string">"last time: &#123;&#125;"</span>.format(time.time()-start_time))</span><br></pre></td></tr></table></figure>
<h3 id="3-2-通过-queue-的方式进行线程间同步"><a href="#3-2-通过-queue-的方式进行线程间同步" class="headerlink" title="3.2 通过 queue 的方式进行线程间同步"></a>3.2 通过 queue 的方式进行线程间同步</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. 通过queue的方式进行线程间同步</span></span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="comment"># queue 底层使用的是deque deque本身就是线程安全的 put默认是阻塞的，可以使用put_nowait非阻塞方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail_html</span><span class="params">(queue)</span>:</span></span><br><span class="line">    <span class="comment"># 爬取文章详情页</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        url = queue.get()</span><br><span class="line">        <span class="comment"># for url in detail_url_list:</span></span><br><span class="line">        print(<span class="string">"get detail html started"</span>)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        print(<span class="string">"get detail html end"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail_url</span><span class="params">(queue)</span>:</span></span><br><span class="line">    <span class="comment"># 爬取文章列表页</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">"get detail url started"</span>)</span><br><span class="line">        time.sleep(<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">            queue.put(<span class="string">"http://projectsedu.com/&#123;id&#125;"</span>.format(id=i))</span><br><span class="line">        print(<span class="string">"get detail url end"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    detail_url_queue = Queue(maxsize=<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">    thread_detail_url = threading.Thread(</span><br><span class="line">        target=get_detail_url, args=(detail_url_queue,))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        html_thread = threading.Thread(</span><br><span class="line">            target=get_detail_html, args=(detail_url_queue,))</span><br><span class="line">        html_thread.start()</span><br><span class="line">    <span class="comment"># # thread2 = GetDetailUrl("get_detail_url")</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    <span class="comment"># thread_detail_url.start()</span></span><br><span class="line">    <span class="comment"># thread_detail_url1.start()</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># thread1.join()</span></span><br><span class="line">    <span class="comment"># thread2.join()</span></span><br><span class="line">    detail_url_queue.task_done()</span><br><span class="line">    detail_url_queue.join()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当主线程退出的时候， 子线程kill掉</span></span><br><span class="line">    print(<span class="string">"last time: &#123;&#125;"</span>.format(time.time()-start_time))</span><br></pre></td></tr></table></figure>
<h3 id="4-线程间同步"><a href="#4-线程间同步" class="headerlink" title="4. 线程间同步"></a>4. 线程间同步</h3><blockquote>
<p>RLock 是基于 Lock 实现的。Condition 是基于 Lock 和 RLock 实现的。Semaphore 是基于 Condition 实现的。  </p>
</blockquote>
<h3 id="4-1-Lock-和-RLock"><a href="#4-1-Lock-和-RLock" class="headerlink" title="4.1 Lock 和 RLock"></a>4.1 Lock 和 RLock</h3><blockquote>
<p>使用 Lock 或者 RLock 完成进程的同步，对互斥资源使用 acquire 加锁，使用 release 释放锁。acquire 不可以连续多次调用。<br>RLock 表示可重入的锁，可以连续多次调用 acquire，但是一定要注意acquire的次数要和release的次数相等。RLock 更常用。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock, RLock, Condition  </span><br><span class="line"></span><br><span class="line"><span class="comment"># RLock 表示可重入的锁</span></span><br><span class="line"><span class="comment"># 在同一个线程里面，可以连续调用多次acquire， 一定要注意acquire的次数要和release的次数相等。</span></span><br><span class="line"><span class="comment"># 注意，这里是同一个线程，并不是多个线程之间可以调用多次</span></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line">lock = RLock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 1. dosomething1</span></span><br><span class="line">    <span class="comment"># 2. io操作</span></span><br><span class="line">    <span class="comment"># 1. dosomething3</span></span><br><span class="line">    <span class="keyword">global</span> lock</span><br><span class="line">    <span class="keyword">global</span> total</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        lock.acquire()</span><br><span class="line">        total += <span class="number">1</span></span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">desc</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> total</span><br><span class="line">    <span class="keyword">global</span> lock</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        lock.acquire()</span><br><span class="line">        total -= <span class="number">1</span></span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thread1 = threading.Thread(target=add)</span><br><span class="line">thread2 = threading.Thread(target=desc)</span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">thread1.join()</span><br><span class="line">thread2.join()</span><br><span class="line">print(total)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 用锁会影响性能</span></span><br><span class="line"><span class="comment"># 2. 锁会引起死锁</span></span><br><span class="line"><span class="comment"># 死锁的情况 A（a，b）</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">下面的代码会出现循环等待情况，导致死锁</span></span><br><span class="line"><span class="string">A(a、b)</span></span><br><span class="line"><span class="string">acquire (a)</span></span><br><span class="line"><span class="string">acquire (b)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">B(a、b)</span></span><br><span class="line"><span class="string">acquire (a)</span></span><br><span class="line"><span class="string">acquire (b)</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-condition"><a href="#4-2-condition" class="headerlink" title="4.2 condition"></a>4.2 condition</h3><blockquote>
<p>用于线程间的复杂通信</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 条件变量， 用于复杂的线程间同步</span></span><br><span class="line"><span class="comment"># class XiaoAi(threading.Thread):</span></span><br><span class="line"><span class="comment">#     def __init__(self, lock):</span></span><br><span class="line"><span class="comment">#         super().__init__(name="小爱")</span></span><br><span class="line"><span class="comment">#         self.lock = lock</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     def run(self):</span></span><br><span class="line"><span class="comment">#         self.lock.acquire()</span></span><br><span class="line"><span class="comment">#         print("&#123;&#125; : 在 ".format(self.name))</span></span><br><span class="line"><span class="comment">#         self.lock.release()</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#         self.lock.acquire()</span></span><br><span class="line"><span class="comment">#         print("&#123;&#125; : 好啊 ".format(self.name))</span></span><br><span class="line"><span class="comment">#         self.lock.release()</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># class TianMao(threading.Thread):</span></span><br><span class="line"><span class="comment">#     def __init__(self, lock):</span></span><br><span class="line"><span class="comment">#         super().__init__(name="天猫精灵")</span></span><br><span class="line"><span class="comment">#         self.lock = lock</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     def run(self):</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#         self.lock.acquire()</span></span><br><span class="line"><span class="comment">#         print("&#123;&#125; : 小爱同学 ".format(self.name))</span></span><br><span class="line"><span class="comment">#         self.lock.release()</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#         self.lock.acquire()</span></span><br><span class="line"><span class="comment">#         print("&#123;&#125; : 我们来对古诗吧 ".format(self.name))</span></span><br><span class="line"><span class="comment">#         self.lock.release()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过condition完成协同读诗</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaoAi</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, cond)</span>:</span></span><br><span class="line">        super().__init__(name=<span class="string">"小爱"</span>)</span><br><span class="line">        self.cond = cond</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 这里使用了 with 语句，如果不实用 with 语句，应该使用 self.cond.acquire()，并在结束时使用 self.cond.release()</span></span><br><span class="line">        <span class="comment"># with 语句实际调用了 Condition 的 acquire 方法。</span></span><br><span class="line">        <span class="comment"># Condition 其实是有两层锁的，一把是 Condition 对象的锁，这种是底层锁，</span></span><br><span class="line">        <span class="comment"># 另一把是 wait 方法被调用时产生的锁，这个锁被放在一个 deque 中，并在 notify 时从 deque 中释放一个锁。</span></span><br><span class="line">        <span class="comment"># 主线程先调用 Xiaoai 线程，当 Xiaoai 线程执行 with self.cond 时，Tianmao 是无法进入 with self.cond 的。</span></span><br><span class="line">        <span class="comment"># 当 Xiaoai 线程执行 wait() 方法时，自己被阻塞，Tianmao 线程开始执行。</span></span><br><span class="line">        print(<span class="string">'A'</span>)</span><br><span class="line">        <span class="keyword">with</span> self.cond:</span><br><span class="line">            print(<span class="string">'B'</span>)</span><br><span class="line">            self.cond.wait()</span><br><span class="line">            print(<span class="string">"&#123;&#125; : 在 "</span>.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line">            print(<span class="string">'F'</span>)</span><br><span class="line"></span><br><span class="line">            self.cond.wait()</span><br><span class="line">            print(<span class="string">"&#123;&#125; : 好啊 "</span>.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line"></span><br><span class="line">            self.cond.wait()</span><br><span class="line">            print(<span class="string">"&#123;&#125; : 君住长江尾 "</span>.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line"></span><br><span class="line">            self.cond.wait()</span><br><span class="line">            print(<span class="string">"&#123;&#125; : 共饮长江水 "</span>.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line"></span><br><span class="line">            self.cond.wait()</span><br><span class="line">            print(<span class="string">"&#123;&#125; : 此恨何时已 "</span>.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line"></span><br><span class="line">            self.cond.wait()</span><br><span class="line">            print(<span class="string">"&#123;&#125; : 定不负相思意 "</span>.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TianMao</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, cond)</span>:</span></span><br><span class="line">        super().__init__(name=<span class="string">"天猫精灵"</span>)</span><br><span class="line">        self.cond = cond</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 这里使用了 with 语句，如果不实用 with 语句，应该使用 self.cond.acquire()，并在结束时使用 self.cond.release()</span></span><br><span class="line">        print(<span class="string">'C'</span>)</span><br><span class="line">        <span class="keyword">with</span> self.cond:</span><br><span class="line">            print(<span class="string">'D'</span>)</span><br><span class="line">            print(<span class="string">"&#123;&#125; : 小爱同学 "</span>.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line">            print(<span class="string">'E'</span>)</span><br><span class="line">            self.cond.wait()</span><br><span class="line">            print(<span class="string">'G'</span>)</span><br><span class="line"></span><br><span class="line">            print(<span class="string">"&#123;&#125; : 我们来对古诗吧 "</span>.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line">            self.cond.wait()</span><br><span class="line"></span><br><span class="line">            print(<span class="string">"&#123;&#125; : 我住长江头 "</span>.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line">            self.cond.wait()</span><br><span class="line"></span><br><span class="line">            print(<span class="string">"&#123;&#125; : 日日思君不见君 "</span>.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line">            self.cond.wait()</span><br><span class="line"></span><br><span class="line">            print(<span class="string">"&#123;&#125; : 此水几时休 "</span>.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line">            self.cond.wait()</span><br><span class="line"></span><br><span class="line">            print(<span class="string">"&#123;&#125; : 只愿君心似我心 "</span>.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line">            self.cond.wait()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line">    cond = threading.Condition()</span><br><span class="line">    xiaoai = XiaoAi(cond)</span><br><span class="line">    tianmao = TianMao(cond)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动顺序很重要</span></span><br><span class="line">    <span class="comment"># 在调用with cond之后才能调用wait或者notify方法</span></span><br><span class="line">    <span class="comment"># condition有两层锁， 一把底层锁会在线程调用了 wait 方法的时候释放， 上面的锁会在每次调用 wait 的时候分配一把并放入到 cond 的等待队列中，等到 notify 方法的唤醒</span></span><br><span class="line">    xiaoai.start()</span><br><span class="line">    tianmao.start()</span><br></pre></td></tr></table></figure>
<h3 id="4-3-Semaphore"><a href="#4-3-Semaphore" class="headerlink" title="4.3 Semaphore"></a>4.3 Semaphore</h3><blockquote>
<p>通过 Semaphore 控制线程并发数量</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Semaphore 是用于控制进入数量的锁</span></span><br><span class="line"><span class="comment">#文件， 读、写， 写一般只是用于一个线程写，读可以允许有多个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#做爬虫</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlSpider</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, url, sem)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.url = url</span><br><span class="line">        self.sem = sem</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        print(<span class="string">"got html text success"</span>)</span><br><span class="line">        <span class="comment"># 每调用 release 时，semaphore 都会加一</span></span><br><span class="line">        self.sem.release()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UrlProducer</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, sem)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.sem = sem</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">            <span class="comment"># 每调用 acquire 时，semaphore 都会减一</span></span><br><span class="line">            self.sem.acquire()</span><br><span class="line">            html_thread = HtmlSpider(<span class="string">"https://baidu.com/&#123;&#125;"</span>.format(i), self.sem)</span><br><span class="line">            html_thread.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 最多允许三个线程并发</span></span><br><span class="line">    sem = threading.Semaphore(<span class="number">3</span>)</span><br><span class="line">    url_producer = UrlProducer(sem)</span><br><span class="line">    url_producer.start()</span><br></pre></td></tr></table></figure>
<h3 id="5-线程池"><a href="#5-线程池" class="headerlink" title="5 线程池"></a>5 线程池</h3><h3 id="5-1-done-cancel-和-result-三个方法"><a href="#5-1-done-cancel-和-result-三个方法" class="headerlink" title="5.1 done, cancel, 和 result 三个方法"></a>5.1 done, cancel, 和 result 三个方法</h3><blockquote>
<p>done 用于获取线程是否执行完成<br>cancel 用于终止线程。注意，cancel 只能对未执行的线程终止。如果线程在执行中或者执行完成，返回 false。成功 cancel 返回 true。<br>result 获取线程的返回值。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, as_completed, wait, FIRST_COMPLETED</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> Future</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 线程池， 为什么要线程池</span></span><br><span class="line"><span class="comment"># 主线程中可以获取某一个线程的状态或者某一个任务的状态，以及返回值</span></span><br><span class="line"><span class="comment"># 当一个线程完成的时候我们主线程能立即知道</span></span><br><span class="line"><span class="comment"># futures可以让多线程和多进程编码接口一致</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(times)</span>:</span></span><br><span class="line">    time.sleep(times)</span><br><span class="line">    print(<span class="string">"get page &#123;&#125; success"</span>.format(times))</span><br><span class="line">    <span class="keyword">return</span> times</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">executor = ThreadPoolExecutor(max_workers=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 通过submit函数提交执行的函数到线程池中, submit 是立即返回</span></span><br><span class="line"><span class="comment"># 注意，这里传递的是函数名，不是函数的调用</span></span><br><span class="line">task1 = executor.submit(get_html, (<span class="number">3</span>))</span><br><span class="line">task2 = executor.submit(get_html, (<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#done方法用于判定某个任务是否完成</span></span><br><span class="line">print(task1.done())</span><br><span class="line">print(task2.cancel())</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">print(task1.done())</span><br><span class="line"></span><br><span class="line"><span class="comment">#result方法可以获取task的执行结果</span></span><br><span class="line">print(task1.result())</span><br></pre></td></tr></table></figure>
<h3 id="5-2-获取成功执行的线程返回值"><a href="#5-2-获取成功执行的线程返回值" class="headerlink" title="5.2 获取成功执行的线程返回值"></a>5.2 获取成功执行的线程返回值</h3><blockquote>
<p>使用 as_completed 或者 map 方法完成。注意，两个方法调用的对象不同。as_completed 是一个单独的函数。map 是 executor 的是一个实例方法。个人优先使用 as_completed 方式。</p>
</blockquote>
<h3 id="5-2-1-使用-as-completed-方法"><a href="#5-2-1-使用-as-completed-方法" class="headerlink" title="5.2.1 使用 as_completed 方法"></a>5.2.1 使用 as_completed 方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, as_completed, wait, FIRST_COMPLETED</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> Future</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(times)</span>:</span></span><br><span class="line">    time.sleep(times)</span><br><span class="line">    print(<span class="string">"get page &#123;&#125; success"</span>.format(times))</span><br><span class="line">    <span class="keyword">return</span> times</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">executor = ThreadPoolExecutor(max_workers=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 要获取已经成功的task的返回</span></span><br><span class="line">urls = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">all_task = [executor.submit(get_html, (url)) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line"><span class="keyword">for</span> future <span class="keyword">in</span> as_completed(all_task):</span><br><span class="line">    data = future.result()</span><br><span class="line">    print(<span class="string">"get &#123;&#125; page"</span>.format(data))</span><br></pre></td></tr></table></figure>
<h3 id="5-2-2-使用-map-方法完成"><a href="#5-2-2-使用-map-方法完成" class="headerlink" title="5.2.2 使用 map 方法完成"></a>5.2.2 使用 map 方法完成</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, as_completed, wait, FIRST_COMPLETED</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> Future</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(times)</span>:</span></span><br><span class="line">    time.sleep(times)</span><br><span class="line">    print(<span class="string">"get page &#123;&#125; success"</span>.format(times))</span><br><span class="line">    <span class="keyword">return</span> times</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">executor = ThreadPoolExecutor(max_workers=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 通过executor的map获取已经完成的task的值</span></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> executor.map(get_html, urls):</span><br><span class="line">    print(<span class="string">"get &#123;&#125; page"</span>.format(data))</span><br></pre></td></tr></table></figure>
<h3 id="5-3-等待特定的线程执行完，再向下执行"><a href="#5-3-等待特定的线程执行完，再向下执行" class="headerlink" title="5.3 等待特定的线程执行完，再向下执行"></a>5.3 等待特定的线程执行完，再向下执行</h3><blockquote>
<p>这个需求有点像 join 方法实现的功能。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, as_completed, wait, FIRST_COMPLETED</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> Future</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(times)</span>:</span></span><br><span class="line">    time.sleep(times)</span><br><span class="line">    print(<span class="string">"get page &#123;&#125; success"</span>.format(times))</span><br><span class="line">    <span class="keyword">return</span> times</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">executor = ThreadPoolExecutor(max_workers=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要获取已经成功的task的返回</span></span><br><span class="line">urls = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">all_task = [executor.submit(get_html, (url)) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line"><span class="comment"># FIRST_COMPLETED 表示当第一个线程执行完成时，便不再等待了。</span></span><br><span class="line"><span class="comment"># return_when 没有设置的时候，等待所有的线程执行完再向下执行。</span></span><br><span class="line">wait(all_task, return_when=FIRST_COMPLETED)</span><br><span class="line">print(<span class="string">"main"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="5-4-分析线程池源码-（重点）"><a href="#5-4-分析线程池源码-（重点）" class="headerlink" title="5.4 分析线程池源码 （重点）"></a>5.4 分析线程池源码 （重点）</h3><blockquote>
<p>线程池有一个非常重要的类，Future。Future 放置在 from concurrent.futures import Future 中。每个线程执行后返回的对象是 Future，即 task 的返回容器。Future 贯穿于多线程编程的始终，可以理解为一个统一的封装接口，就好像所有的对象的顶层父类都是 Object一样。<br>理解了上一点，那么，Future 对象是怎么贯穿线程生命周期的始终呢？<br>在调用 ThreadPoolExecutor 的 submit 函数时，以下面的代码为例，首先会生成 Future 对象，最后返回这个对象。在执行的过程中，生成 _WorkItem，并将 Future 对象，线程函数体，参数一起传入 _WorkItem中，再将其放入 queue 中，这个 queue 是线程安全的。放入 queue 之后，使用 _adjust_thread_count 调成线程数量。在 _adjust_thread_count 函数体中，如果当前等待的线程数小于线程池的容量，会启动线程，直到等于线程池数量。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">submit</span><span class="params">(self, fn, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> self._shutdown_lock:</span><br><span class="line">        <span class="keyword">if</span> self._shutdown:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">'cannot schedule new futures after shutdown'</span>)</span><br><span class="line"></span><br><span class="line">        f = _base.Future()</span><br><span class="line">        w = _WorkItem(f, fn, args, kwargs)</span><br><span class="line"></span><br><span class="line">        self._work_queue.put(w)</span><br><span class="line">        self._adjust_thread_count()</span><br><span class="line">        <span class="keyword">return</span> f</span><br></pre></td></tr></table></figure>
<blockquote>
<p>下面，我们来详细了解 _adjust_thread_count 的执行过程。启动一个新的线程时，执行体是 _worker，_worker 从 queue 中取出一个值，这是值是封装了我们自己写的线程函数体的 work_item，进而调用 work_item 中的 run 方法。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">def _adjust_thread_count(self):</span><br><span class="line">    <span class="comment"># When the executor gets lost, the weakref callback will wake up</span></span><br><span class="line">    <span class="comment"># the worker threads.</span></span><br><span class="line">    def weakref_cb(_, q=self._work_queue):</span><br><span class="line">        q.put(None)</span><br><span class="line">    <span class="comment"># TODO(bquinlan): Should avoid creating new threads if there are more</span></span><br><span class="line">    <span class="comment"># idle threads than items in the work queue.</span></span><br><span class="line">    num_threads = len(self._threads)</span><br><span class="line">    <span class="keyword">if</span> num_threads &lt; self._max_workers:</span><br><span class="line">        thread_name = <span class="string">'%s_%d'</span> % (self._thread_name_prefix or self,</span><br><span class="line">                                 num_threads)</span><br><span class="line">        t = threading.Thread(name=thread_name, target=_worker,</span><br><span class="line">                             args=(weakref.ref(self, weakref_cb),</span><br><span class="line">                                   self._work_queue))</span><br><span class="line">        t.daemon = True</span><br><span class="line">        t.start()</span><br><span class="line">        self._threads.add(t)</span><br><span class="line">        _threads_queues[t] = self._work_queue</span><br><span class="line"></span><br><span class="line">def _worker(executor_reference, work_queue):</span><br><span class="line">    try:</span><br><span class="line">        <span class="keyword">while</span> True:</span><br><span class="line">            work_item = work_queue.get(block=True)</span><br><span class="line">            <span class="keyword">if</span> work_item is not None:</span><br><span class="line">                work_item.run()</span><br><span class="line">                <span class="comment"># Delete references to object. See issue16284</span></span><br><span class="line">                del work_item</span><br><span class="line">                <span class="built_in">continue</span></span><br><span class="line">            executor = executor_reference()</span><br><span class="line">            <span class="comment"># Exit if:</span></span><br><span class="line">            <span class="comment">#   - The interpreter is shutting down OR</span></span><br><span class="line">            <span class="comment">#   - The executor that owns the worker has been collected OR</span></span><br><span class="line">            <span class="comment">#   - The executor that owns the worker has been shutdown.</span></span><br><span class="line">            <span class="keyword">if</span> _shutdown or executor is None or executor._shutdown:</span><br><span class="line">                <span class="comment"># Notice other workers</span></span><br><span class="line">                work_queue.put(None)</span><br><span class="line">                <span class="built_in">return</span></span><br><span class="line">            del executor</span><br><span class="line">    except BaseException:</span><br><span class="line">        _base.LOGGER.critical(<span class="string">'Exception in worker'</span>, exc_info=True)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>下面，我们再来看一下 work_item 中的 run 方法。首先，run 方法会执行我们自己写的线程函数体，得到函数的返回值，并将值设置到 Future 对象中。由此，变完成了使用 Future 统一线程的执行。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.future.set_running_or_notify_cancel():</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        result = self.fn(*self.args, **self.kwargs)</span><br><span class="line">    <span class="keyword">except</span> BaseException <span class="keyword">as</span> exc:</span><br><span class="line">        self.future.set_exception(exc)</span><br><span class="line">        <span class="comment"># Break a reference cycle with the exception 'exc'</span></span><br><span class="line">        self = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.future.set_result(result)</span><br></pre></td></tr></table></figure>
<h3 id="6-多进程编程"><a href="#6-多进程编程" class="headerlink" title="6. 多进程编程"></a>6. 多进程编程</h3><blockquote>
<p><strong>耗 cpu 的操作，用多进程编程。对于 io 操作来说， 使用多线程编程。</strong><br>由于 Python 中有 GIL 锁，Python 中的多线程编程是无法充分利用多核的优势。但是，<strong>多进程编程就能够利用多核的优势。</strong></p>
</blockquote>
<h3 id="6-1-对于耗费-cpu-的操作，多进程优于多线程"><a href="#6-1-对于耗费-cpu-的操作，多进程优于多线程" class="headerlink" title="6.1 对于耗费 cpu 的操作，多进程优于多线程"></a>6.1 对于耗费 cpu 的操作，多进程优于多线程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, as_completed</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n&lt;=<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fib(n<span class="number">-1</span>)+fib(n<span class="number">-2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 多线程</span></span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(<span class="number">3</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        all_task = [executor.submit(fib, (num)) <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">25</span>,<span class="number">40</span>)]</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> as_completed(all_task):</span><br><span class="line">            data = future.result()</span><br><span class="line">            print(<span class="string">"exe result: &#123;&#125;"</span>.format(data))</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"last time is: &#123;&#125;"</span>.format(time.time()-start_time))</span><br><span class="line">    </span><br><span class="line">	<span class="comment"># 多进程</span></span><br><span class="line">	<span class="comment"># Windows 下面执行 ProcessPoolExecutor 需要放到 main 函数下执行，不然会报错</span></span><br><span class="line">    <span class="keyword">with</span> ProcessPoolExecutor(<span class="number">3</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        all_task = [executor.submit(fib, (num)) <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">25</span>,<span class="number">40</span>)]</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> as_completed(all_task):</span><br><span class="line">            data = future.result()</span><br><span class="line">            print(<span class="string">"exe result: &#123;&#125;"</span>.format(data))</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"last time is: &#123;&#125;"</span>.format(time.time()-start_time))</span><br></pre></td></tr></table></figure>
<h3 id="6-2-对于-io-操作来说，多线程优于多进程"><a href="#6-2-对于-io-操作来说，多线程优于多进程" class="headerlink" title="6.2 对于 io 操作来说，多线程优于多进程"></a>6.2 对于 io 操作来说，多线程优于多进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">from concurrent.futures import ThreadPoolExecutor, as_completed</span><br><span class="line">from concurrent.futures import ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def random_sleep(n):</span><br><span class="line">    time.sleep(n)</span><br><span class="line">    return n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">	# 多线程</span><br><span class="line">	with ThreadPoolExecutor(3) as executor:</span><br><span class="line">        all_task &#x3D; [executor.submit(random_sleep, (num)) for num in [2]*30]</span><br><span class="line">        start_time &#x3D; time.time()</span><br><span class="line">        for future in as_completed(all_task):</span><br><span class="line">            data &#x3D; future.result()</span><br><span class="line">            print(&quot;exe result: &#123;&#125;&quot;.format(data))</span><br><span class="line"></span><br><span class="line">        print(&quot;last time is: &#123;&#125;&quot;.format(time.time()-start_time))</span><br><span class="line">    </span><br><span class="line">    # 多进程</span><br><span class="line">    with ProcessPoolExecutor(3) as executor:</span><br><span class="line">        all_task &#x3D; [executor.submit(random_sleep, (num)) for num in [2]*30]</span><br><span class="line">        start_time &#x3D; time.time()</span><br><span class="line">        for future in as_completed(all_task):</span><br><span class="line">            data &#x3D; future.result()</span><br><span class="line">            print(&quot;exe result: &#123;&#125;&quot;.format(data))</span><br><span class="line"></span><br><span class="line">        print(&quot;last time is: &#123;&#125;&quot;.format(time.time()-start_time))</span><br></pre></td></tr></table></figure>
<h3 id="6-3-fork-与多进程的区别"><a href="#6-3-fork-与多进程的区别" class="headerlink" title="6.3 fork 与多进程的区别"></a>6.3 fork 与多进程的区别</h3><blockquote>
<p>fork 会新建一个子进程</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># fork只能用于linux/unix中</span></span><br><span class="line"><span class="comment"># 调用 fork 函数之后，会完全拷贝一份父进程的数据给子进程，子进程执行 fork 之后的代码</span></span><br><span class="line">pid = os.fork()</span><br><span class="line">print(<span class="string">"bobby"</span>)</span><br><span class="line"><span class="keyword">if</span> pid == <span class="number">0</span>:</span><br><span class="line">   print(<span class="string">'子进程 &#123;&#125; ，父进程是： &#123;&#125;.'</span> .format(os.getpid(), os.getppid()))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   print(<span class="string">'我是父进程：&#123;&#125;.'</span>.format(pid))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有 sleep 代码，会出现子进程无法退出的情况。这是因为，父进程执行完了之后，由于没有 sleep 函数，父进程会直接退出，但是，此时子进程依然在执行，当子进程执行完了之后，发现父进程已经消失了，子进程就无法退出。</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h3 id="6-4-multiprocessing"><a href="#6-4-multiprocessing" class="headerlink" title="6.4 multiprocessing"></a>6.4 multiprocessing</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多进程编程</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(n)</span>:</span></span><br><span class="line">    time.sleep(n)</span><br><span class="line">    print(<span class="string">"sub_progress success"</span>)</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 下面这行代码也可以使用继承 multiprocessing.Process 方式实现，就像继承 Thread 方式实现多线程一样</span></span><br><span class="line">    progress = multiprocessing.Process(target=get_html, args=(<span class="number">2</span>,))</span><br><span class="line">    <span class="comment"># 打印 pid</span></span><br><span class="line">    print(progress.pid)</span><br><span class="line">    progress.start()</span><br><span class="line">    print(progress.pid)</span><br><span class="line">    progress.join()</span><br><span class="line">    print(<span class="string">"main progress end"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="6-5-进程池"><a href="#6-5-进程池" class="headerlink" title="6.5 进程池"></a>6.5 进程池</h3><blockquote>
<p><strong>使用进程池时，建议使用ProcessPoolExecutor，而不是multiprocessing模块。</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="comment">#多进程编程</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(n)</span>:</span></span><br><span class="line">    time.sleep(n)</span><br><span class="line">    print(<span class="string">"sub_progress success"</span>)</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 使用进程池</span></span><br><span class="line">    pool = multiprocessing.Pool(multiprocessing.cpu_count())</span><br><span class="line">    <span class="comment"># 提交任务到池子中</span></span><br><span class="line">    result = pool.apply_async(get_html, args=(<span class="number">3</span>,))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 等待所有任务完成</span></span><br><span class="line">    <span class="comment"># 在调用 join 之前，需要调用 close 方法，关闭池子</span></span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    </span><br><span class="line">    print(result.get())</span><br></pre></td></tr></table></figure>
<h3 id="6-6-imap-和-imap-unordered"><a href="#6-6-imap-和-imap-unordered" class="headerlink" title="6.6 imap 和 imap_unordered"></a>6.6 imap 和 imap_unordered</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="comment">#多进程编程</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(n)</span>:</span></span><br><span class="line">    time.sleep(n)</span><br><span class="line">    print(<span class="string">"sub_progress success"</span>)</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 使用进程池</span></span><br><span class="line">    pool = multiprocessing.Pool(multiprocessing.cpu_count())</span><br><span class="line">    <span class="comment"># imap 按顺序执行</span></span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> pool.imap(get_html, [<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>]):</span><br><span class="line">        print(<span class="string">"&#123;&#125; sleep success"</span>.format(result))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># imap_unordered</span></span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> pool.imap_unordered(get_html, [<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>]):</span><br><span class="line">        print(<span class="string">"&#123;&#125; sleep success"</span>.format(result))</span><br></pre></td></tr></table></figure>
<h3 id="6-7-进程间通信"><a href="#6-7-进程间通信" class="headerlink" title="6.7 进程间通信"></a>6.7 进程间通信</h3><h3 id="6-7-1-使用-multiprocessing-中的-Queue"><a href="#6-7-1-使用-multiprocessing-中的-Queue" class="headerlink" title="6.7.1 使用 multiprocessing 中的 Queue"></a>6.7.1 使用 multiprocessing 中的 Queue</h3><blockquote>
<p>多线程编程时通过 queue 进行通信，但是在多进程编程时，需要使用 from multiprocessing import Queue 中的 queue。<br>多进程编程时不能通过共享全局变量方式通信，因为多个进程间的变量是完全隔离的。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue, Pool, Manager, Pipe</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(queue)</span>:</span></span><br><span class="line">    queue.put(<span class="string">"a"</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(queue)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    data = queue.get()</span><br><span class="line">    print(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    queue = Queue(<span class="number">10</span>)</span><br><span class="line">    my_producer = Process(target=producer, args=(queue,))</span><br><span class="line">    my_consumer = Process(target=consumer, args=(queue,))</span><br><span class="line">    my_producer.start()</span><br><span class="line">    my_consumer.start()</span><br><span class="line">    my_producer.join()</span><br><span class="line">    my_consumer.join()</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>multiprocessing中的queue不能用于pool进程池。pool中的进程间通信需要使用manager中的queue。</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue, Pool, Manager, Pipe</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(queue)</span>:</span></span><br><span class="line">    queue.put(<span class="string">"a"</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(queue)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    data = queue.get()</span><br><span class="line">    print(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    queue = Manager().Queue(<span class="number">10</span>)</span><br><span class="line">    pool = Pool(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    pool.apply_async(producer, args=(queue,))</span><br><span class="line">    pool.apply_async(consumer, args=(queue,))</span><br><span class="line"></span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Python 中有三个 Queue，需要注意不同点。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue, Pool, Manager, Pipe</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(pipe)</span>:</span></span><br><span class="line">    pipe.send(<span class="string">"bobby"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(pipe)</span>:</span></span><br><span class="line">    print(pipe.recv())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    recevie_pipe, send_pipe = Pipe()</span><br><span class="line">    <span class="comment">#pipe只能适用于两个进程</span></span><br><span class="line">    my_producer= Process(target=producer, args=(send_pipe, ))</span><br><span class="line">    my_consumer = Process(target=consumer, args=(recevie_pipe,))</span><br><span class="line"></span><br><span class="line">    my_producer.start()</span><br><span class="line">    my_consumer.start()</span><br><span class="line">    my_producer.join()</span><br><span class="line">    my_consumer.join()</span><br></pre></td></tr></table></figure>
<h3 id="6-7-2-使用-Pipe"><a href="#6-7-2-使用-Pipe" class="headerlink" title="6.7.2 使用 Pipe"></a>6.7.2 使用 Pipe</h3><blockquote>
<p>pipe的性能高于queue。但是 pipe只能适用于两个进程。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue, Pool, Manager, Pipe</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(pipe)</span>:</span></span><br><span class="line">    pipe.send(<span class="string">"bobby"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(pipe)</span>:</span></span><br><span class="line">    print(pipe.recv())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    recevie_pipe, send_pipe = Pipe()</span><br><span class="line">    <span class="comment">#pipe只能适用于两个进程</span></span><br><span class="line">    my_producer= Process(target=producer, args=(send_pipe, ))</span><br><span class="line">    my_consumer = Process(target=consumer, args=(recevie_pipe,))</span><br><span class="line"></span><br><span class="line">    my_producer.start()</span><br><span class="line">    my_consumer.start()</span><br><span class="line">    my_producer.join()</span><br><span class="line">    my_consumer.join()</span><br></pre></td></tr></table></figure>
<h3 id="6-7-3-使用-Manager-中的数据结构"><a href="#6-7-3-使用-Manager-中的数据结构" class="headerlink" title="6.7.3 使用 Manager() 中的数据结构"></a>6.7.3 使用 Manager() 中的数据结构</h3><blockquote>
<p>Manager 类中有 dict, array, list 等数据结构。可以通过共享这些数据结构对象，进而实现通信。但是，使用这种方式需要注意同步的问题，即需要加锁，保持数据一致性。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue, Pool, Manager, Pipe</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_data</span><span class="params">(p_dict, key, value)</span>:</span></span><br><span class="line">    p_dict[key] = value</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    progress_dict = Manager().dict()</span><br><span class="line"></span><br><span class="line">    first_progress = Process(target=add_data, args=(progress_dict, <span class="string">"bobby1"</span>, <span class="number">22</span>))</span><br><span class="line">    second_progress = Process(target=add_data, args=(progress_dict, <span class="string">"bobby2"</span>, <span class="number">23</span>))</span><br><span class="line"></span><br><span class="line">    first_progress.start()</span><br><span class="line">    second_progress.start()</span><br><span class="line">    first_progress.join()</span><br><span class="line">    second_progress.join()</span><br><span class="line">    print(progress_dict)</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://blog.csdn.net/kisslotus/article/details/83990214" target="_blank" rel="noopener">https://blog.csdn.net/kisslotus/article/details/83990214</a></p>
<!-- indicate-the-source -->
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/python/" rel="tag"># python</a>
              <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag"># 多线程</a>
              <a href="/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/" rel="tag"># 多进程</a>
              <a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="tag"># 线程池</a>
              <a href="/tags/%E8%BF%9B%E7%A8%8B%E6%B1%A0/" rel="tag"># 进程池</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/12/21/%E7%BD%91%E7%BB%9C-ip%E5%9C%B0%E5%9D%80-%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81/" rel="prev" title="子网络掩码">
      <i class="fa fa-chevron-left"></i> 子网络掩码
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/05/10/python-magic-function-%E9%AD%94%E6%B3%95%E5%87%BD%E6%95%B0/" rel="next" title="python -- 魔法函数">
      python -- 魔法函数 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#GIL"><span class="nav-number">1.</span> <span class="nav-text">GIL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-多线程编程"><span class="nav-number">2.</span> <span class="nav-text">2. 多线程编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-通过Thread类实例化"><span class="nav-number">3.</span> <span class="nav-text">2.1 通过Thread类实例化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-通过继承Thread来实现多线程"><span class="nav-number">4.</span> <span class="nav-text">2.2 通过继承Thread来实现多线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-线程间通信"><span class="nav-number">5.</span> <span class="nav-text">3. 线程间通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-通过共享变量的方式"><span class="nav-number">6.</span> <span class="nav-text">3.1 通过共享变量的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-通过-queue-的方式进行线程间同步"><span class="nav-number">7.</span> <span class="nav-text">3.2 通过 queue 的方式进行线程间同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-线程间同步"><span class="nav-number">8.</span> <span class="nav-text">4. 线程间同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-Lock-和-RLock"><span class="nav-number">9.</span> <span class="nav-text">4.1 Lock 和 RLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-condition"><span class="nav-number">10.</span> <span class="nav-text">4.2 condition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-Semaphore"><span class="nav-number">11.</span> <span class="nav-text">4.3 Semaphore</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-线程池"><span class="nav-number">12.</span> <span class="nav-text">5 线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-done-cancel-和-result-三个方法"><span class="nav-number">13.</span> <span class="nav-text">5.1 done, cancel, 和 result 三个方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-获取成功执行的线程返回值"><span class="nav-number">14.</span> <span class="nav-text">5.2 获取成功执行的线程返回值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-1-使用-as-completed-方法"><span class="nav-number">15.</span> <span class="nav-text">5.2.1 使用 as_completed 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-2-使用-map-方法完成"><span class="nav-number">16.</span> <span class="nav-text">5.2.2 使用 map 方法完成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-等待特定的线程执行完，再向下执行"><span class="nav-number">17.</span> <span class="nav-text">5.3 等待特定的线程执行完，再向下执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-分析线程池源码-（重点）"><span class="nav-number">18.</span> <span class="nav-text">5.4 分析线程池源码 （重点）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-多进程编程"><span class="nav-number">19.</span> <span class="nav-text">6. 多进程编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-对于耗费-cpu-的操作，多进程优于多线程"><span class="nav-number">20.</span> <span class="nav-text">6.1 对于耗费 cpu 的操作，多进程优于多线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-对于-io-操作来说，多线程优于多进程"><span class="nav-number">21.</span> <span class="nav-text">6.2 对于 io 操作来说，多线程优于多进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-fork-与多进程的区别"><span class="nav-number">22.</span> <span class="nav-text">6.3 fork 与多进程的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-multiprocessing"><span class="nav-number">23.</span> <span class="nav-text">6.4 multiprocessing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-进程池"><span class="nav-number">24.</span> <span class="nav-text">6.5 进程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-imap-和-imap-unordered"><span class="nav-number">25.</span> <span class="nav-text">6.6 imap 和 imap_unordered</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-进程间通信"><span class="nav-number">26.</span> <span class="nav-text">6.7 进程间通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-1-使用-multiprocessing-中的-Queue"><span class="nav-number">27.</span> <span class="nav-text">6.7.1 使用 multiprocessing 中的 Queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-2-使用-Pipe"><span class="nav-number">28.</span> <span class="nav-text">6.7.2 使用 Pipe</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-3-使用-Manager-中的数据结构"><span class="nav-number">29.</span> <span class="nav-text">6.7.3 使用 Manager() 中的数据结构</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Action"
      src="/images/cat.jpg">
  <p class="site-author-name" itemprop="name">Action</p>
  <div class="site-description" itemprop="description">热爱你所坚持的，坚持你所热爱的</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">82</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">58</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">94</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Action8686" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Action8686" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:748173631@qq.com" title="E-Mail → mailto:748173631@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">null </a>
  </div>

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Action</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">307k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">4:39</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

  

    </div>
</body>
</html>
